<?xml version="1.0" encoding="UTF-8"?>
<article id="fundementals-howto" lang="tr">
	<articleinfo>
		<title>Unix ve Internetin Temelleri NASIL</title>
		<author>
			<firstname>Eric Raymond</firstname>
			<affiliation><address><email>esr@thyrsus.com</email></address></affiliation>
		</author>
		<author role="translator">
			<firstname>Cem</firstname><surname>Sönmez</surname>
			<affiliation><address><email>cem@comu.edu.tr</email></address></affiliation>
		</author>
		<revhistory>
			<para><emphasis role="bold">Bu çevirinin sürüm bilgileri:</emphasis></para>
			<revision>
				<revnumber>1.0</revnumber>
				<date>Ocak 2009</date>
				<authorinitials>cs</authorinitials>
				<revremark>İlk sürüm</revremark>
			</revision>
		</revhistory><revhistory>
			<para><emphasis role="bold">Özgün belgenin sürüm bilgileri:</emphasis></para>
			<revision>
				<revnumber>2.10</revnumber>
				<date>2007-11-28</date>
				<authorinitials>esr</authorinitials>
				<revremark>Küçük düzeltmeler</revremark> 
			</revision>
		</revhistory>
		<legalnotice><title>Yasal Açıklamalar</title><para>
				Bu belgenin, <emphasis>Unix ve Internetin Temelleri NASIL</emphasis> çevirisinin 1.0 sürümünün <emphasis role="bold">telif hakkı © 2009 <emphasis>Cem Sönmez</emphasis>'e</emphasis> aittir, özgün İngilizce sürümünün <emphasis role="bold">telif hakkı © 1999-2007 <emphasis>Eric Raymond</emphasis>'a </emphasis> aittir. Bu belgeyi, Free Software Foundation tarafından yayınlanmış bulunan <link linkend="gpl">GNU Genel Kamu Lisansının</link> 3 ya da daha sonraki sürümünün koşullarına bağlı kalarak kopyalayabilir, dağıtabilir ve/veya değiştirebilirsiniz. Bu Lisansın bir kopyasını <ulink url="http://www.gnu.org/licenses/gpl.html"/> adresinde bulabilirsiniz.
			</para>
			<para>
				BU BELGE "ÜCRETSİZ" OLARAK RUHSATLANDIĞI İÇİN, İÇERDİĞİ BİLGİLER İÇİN İLGİLİ KANUNLARIN İZİN VERDİĞİ ÖLÇÜDE HERHANGİ BİR GARANTİ VERİLMEMEKTEDİR. AKSİ YAZILI OLARAK BELİRTİLMEDİĞİ MÜDDETÇE TELİF HAKKI SAHİPLERİ VE/VEYA BAŞKA ŞAHISLAR BELGEYİ "OLDUĞU GİBİ", AŞİKAR VEYA ZIMNEN, SATILABİLİRLİĞİ VEYA HERHANGİ BİR AMACA UYGUNLUĞU DA DAHİL OLMAK ÜZERE HİÇBİR GARANTİ VERMEKSİZİN DAĞITMAKTADIRLAR. BİLGİNİN KALİTESİ İLE İLGİLİ TÜM SORUNLAR SİZE AİTTİR. HERHANGİ BİR HATALI BİLGİDEN DOLAYI DOĞABİLECEK OLAN BÜTÜN SERVİS, TAMİR VEYA DÜZELTME MASRAFLARI SİZE AİTTİR.
			</para>
			<para>
				İLGİLİ KANUNUN İCBAR ETTİĞİ DURUMLAR VEYA YAZILI ANLAŞMA HARİCİNDE HERHANGİ BİR ŞEKİLDE TELİF HAKKI SAHİBİ VEYA YUKARIDA İZİN VERİLDİĞİ ŞEKİLDE BELGEYİ DEĞİŞTİREN VEYA YENİDEN DAĞITAN HERHANGİ BİR KİŞİ, BİLGİNİN KULLANIMI VEYA KULLANILAMAMASI (VEYA VERİ KAYBI OLUŞMASI, VERİNİN YANLIŞ HALE GELMESİ, SİZİN VEYA ÜÇÜNCÜ ŞAHISLARIN ZARARA UĞRAMASI VEYA BİLGİLERİN BAŞKA BİLGİLERLE UYUMSUZ OLMASI) YÜZÜNDEN OLUŞAN GENEL, ÖZEL, DOĞRUDAN YA DA DOLAYLI HERHANGİ BİR ZARARDAN, BÖYLE BİR TAZMİNAT TALEBİ TELİF HAKKI SAHİBİ VEYA İLGİLİ KİŞİYE BİLDİRİLMİŞ OLSA DAHİ, SORUMLU DEĞİLDİR.
			</para>
			<para>
				Tüm telif hakları aksi özellikle belirtilmediği sürece sahibine aittir. Belge içinde geçen herhangi bir terim, bir ticari isim ya da kuruma itibar kazandırma olarak algılanmamalıdır. Bir ürün ya da markanın kullanılmış olması ona onay verildiği anlamında görülmemelidir.
			</para>
		</legalnotice>  
		<abstract>
			<para>Bu belge, PC-sınıfı bilgisayarların, Unix yürevi işletim sistemlerinin, ve Internet'in çalışma temellerini teknik olmayan dilde anlatıyor. </para><para>Bu belgenin İngilizce son sürümünü <ulink url="http://www.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/index.html"/> adresinde bulabilirsiniz.</para>
		</abstract>
	</articleinfo>
	
	<sect1 id="fundementals-howto-intro"><title>Giriş</title>
		<sect2 id="fundementals-howto-intro-purpose"><title>Amaç</title>
			<para>Bu belge, yaparak öğrenmeye çalışan Unix ve Internet kullanıcılarına yardımcı olmak için tasarlanmıştır. Bu yöntem belli becerileri ortaya çıkarmak için çok iyi bir yöntem oluyorken, bazen kişinin bilgi temelinde tuhaf boşluklar bırakabiliyor - tuhaf boşluklar dediğimiz şey, gerçekte ne olduğuna dair iyi bir model eksikliğinden dolayı, yaratıcı düşünme ve etkin hata ayıklamayı güçleştiren faktördür.</para> 
			<para>Tüm işlerin nasıl yürüdüğünü basit ve sade bir şekilde anlatmaya çalışacağım. Sunum, PC-sınıfı makinelerde Unix veya Linux kullanıcılarına göre ayarlanacaktır. Bununla beraber, genellikle Unix'e değineceğim, sıklıkla anlatacağım sabit olan şeyleri ise farklı makinelere ve Unix türevlerine göre anlatacağım. </para>
			<para>Intel PC kullandığınızı varsayıyorum. Eğer Alpha PowerPC ya da başka bir çeşit bilgisayar kullanıyorsanız, ayrıntılar ufak farklılıklar gösterebilir, fakat temel kavramlar aynıdır.</para>
			<para>Söylemiş olduğum şeyleri tekrarlamayacağım, bu yüzden dikkatinizi vermelisiniz, fakat bu aynı zamanda okuduğunuz her kelimeden birşeyler anlayacağınız anlamına gelir. İlk defa okuduğunuz şeyleri üstünkörü bir şekilde okumanız iyi fikir; öğrendiğiniz şeyleri kavradığınız zaman birkaç kere geriye dönüp tekrar okuyabilirsiniz.</para>
			<para>Bu sürekli gelişen bir belgedir. Bölümleri kullanıcının geribildirimlerine yanıt olarak ekliyorum, bu yüzden periyodik olarak geriye dönüp tekrar gözden geçirmelisiniz.</para>
		</sect2>
		<sect2 id="fundementals-howto-intro-new"><title>Belgenin yeni sürümleri</title>
			<para>Unix ve Internetin Temelleri NASIL'ın yeni sürümleri periyodik olarak comp.os.linux.help,comp.os.linux.announce ve news.answers'a postalanır. Bunlar ayrıca,  Linux Documentation Project anasayfasında da belirtilen çeşitli Linux WWW ve FTP sitelerine yüklenir. </para>
			<para>Son sürümünü http://www.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/index.html URL'sinden görüntüleyebilirsiniz.</para>		
			<para>Bu belge Lehçe, İspanyolca ve Türkçe dillerine çevrilmiştir.</para>
		</sect2>	
		<sect2 id="fundementals-howto-intro-feedback"><title>Geribildirim ve düzeltmeler</title>
			<para>Eğer bu belge ile ilgili herhangi bir sorunuz veya yorumunuz varsa, lütfen Eric S. Raymond'a  esr@thyrsus.com'dan mail atmaktan çekinmeyiniz. Her türlü öneri ve eleştirilerinize açığımdır. Özellikle belirli kavramların daha ayrıntılı açıklamalarının olduğu bağlantılara açığımdır. Eğer bu belgede bir hata bulursanız, lütfen bana bildirin, böylelikle ben de bir sonraki sürümde yanlışları düzeltebileyim. Teşekkürler.</para>
		</sect2>
		<sect2 id="fundementals-howto-intro-related"><title>İlgili kaynaklar</title>
			<para>Eğer bu belgeyi nasıl hackleme yapabileceğini öğrenmek için okuyorsanız, Nasıl Hacker Olunur SSS'i de okumalısınız. Bu belge bazı diğer kullanışlı kaynakların bağlantılanı içeriyor.</para>
		</sect2>
	</sect1>
	
	<sect1 id="fundementals-howto-basic-anatomy"><title>Bilgisayarınızın temel anatomisi</title>
		<para>Bilgisayarınızın içinde asıl işi yapan bir işlemci çipi bulunur. Bu çipin dahili belleği bulunur (DOS/Windows camiası "RAM", Unix camiası ise çoğu kez "çekirdek" olarak çağırır; Unix terminolojisinde bellek demir parçalarından oluşan RAM'dir. İşlemci ve bellek, bilgisayarınızın kalbi olan anakartta bulunur.</para>
		
		<para>Bilgisayarınızın bir ekranı ve klavyesi vardır. Sabit diski ve bir CD-ROM'u veya bir floppy disk'i vardır. Bu cihazlardan bazıları anakarta yerleştirilmiş denetleyici kartlar ile çalışır; diğer cihazlar ise, direkt olarak anakartta bulunan, denetleyici kartlar ile aynı fonksiyonlara sahip, özelleşmiş çipsetler aracılığı ile çalışırlar. Klavyeniz ayrı bir karta ihitiyaç duymayacak kadar basittir; denetleyici ise klavyedeki şasesine gömülüdür.</para>
		
		<para>Bu cihazların nasıl çalıştığı konusundaki detaylara daha sonra gireceğiz. Şimdilik, birlikte nasıl çalıştıkları konusunda aklımızda kalması için temel birkaç şey :</para>
		
		<para>Bilgisayarınızın kasası içindeki her parça bir veriyolu ile bağlıdır. Fiziksel olarak veriyolu; denetleyici kartlarınızın takılı olduğu şeydir (görüntü kartı, disk denetleyici, varsa ses kartı). Veriyolu, işlemciniz, ekranınız, diskiniz ve diğer herşeyiniz arasındaki veri anayoludur.</para>
		
		<para>(PC'lerle bağlantıda 'ISA', 'PCI' ve 'PCMIA' kaynaklarını gördüyseniz ve anlamadıysanız, bunlar veriyolu tipleridir. ISA ufak detaylardan dışında, 1980'de IBM orjinal PC'lerinde kullanılan veriyoludur; şimdilerde kullanım dışıdır. PCI, Çevresel Bileşen Bağlantısı, çoğu modern PC'lerde ve Macintosh'larda kullanılan veriyoludur. PCMIA, dizüstü bilgisayarlarda kullanılan, daha ufak fiziksel konnektörleri olan ISA'nın değişik bir biçimidir.) </para>
		
		<para>Herşeyi yürüten işlemci aslında diğer parçaları direkt olarak göremez; bu parçalarla veriyolu hattı aracılığı ile haberleşmek zorundadır. Sahip olduğu tek altsistem, anlık olarak hızla erişebildiği bellektir (çekirdek). Öyleyse programların çalışması için,  çekirdek(bellek) içinde bulunmaları gerekir.</para>
		
		<para>Bilgisayarınız diskten bir program ya da veri okuduğu zaman, aslında işlemci veriyolunu kullanarak disk denetleyicisine disk okuma isteği gönderiyordur. Biraz zaman sonra disk denetleyicisi, işlemciye veriyi okuduğunu ve belleğin belirli bir yerine koyduğunu belirten bir sinyali veriyolu üzerinden gönderir. İşlemci daha sonra bu veriye bakmak için veriyolunu kullanabilir.</para>
		
		<para>Klavyeniz ve ekranınız da işlemci ile veriyolu aracılığı ile haberleşir, ancak daha basit yollardan. Bunları daha sonra tartışacağız. Şimdilik, bilgisayarınızı açtığınız zaman neler olduğu hakkında yeterli bilginiz var.</para>	
	</sect1>
	
	<sect1 id="fundementals-howto-switch-on"><title>Bilgisayarı açtığınızda neler olur?</title>
		<para>Çalışan bir program olmadığında, bir bilgisayar sadece elektroniğin hareketsiz, iri bir parçasıdır. Bir bilgisayarın açıldığında yapmak zorunda olduğu ilk şey: "işletim sistemi" denen özel bir programı başlatmaktır. İşletim sisteminin görevi; diğer bilgisayar programlarının çalışmasına, bilgisayar donanımının kontrolününün karmaşık detaylarını ele alarak yardımcı olmaktır.</para>

		<para>İşletim sistemini getiren süreç, önyükleme (boot etme) olarak adlandırılır (aslında bu sıfırdan önyüklemedir ve "sıfırdan önyükleme" ile bilgisayarınızı ayağa kaldıran süreç anlamındadır). Bilgisayarınız nasıl önyükleme yapacağını bilir, çünkü önyükleme için gerekli ifadeler bir tane çipe yerleştirilmiştir, BIOS (Basic Input/Output System - Temel Giriş/Çıkış Sitemi) yongası.</para>
		
		<para>BIOS çipi bilgisayarınıza, önyükleme yükleyicisi (Linux'ta önyükleme yükleyicisi Grub ya da LILO olarak çağrılır) denilen özel bir program için, genellikle en düşük numaralı sabit disk (önyükleme diski) olan belirli bir yer bakmasını söyler. Önyükleme yükleyicisi belleğe çekilir ve başlatılır. Önyükleme yükleyicisinin işi; gerçek işletim sistemini başlatmaktır.</para>	
		
		<para>Yükleyici bu işi bir çekirdeği arayarak, belleğe yükleyerek ve başlatarak yapar. Linux'u başlattığınız ve LILO ekranını izleyen bir nokta demeti gördüğünüz zaman, çekirdek yükleniyor demektir. (Her nokta ,çekirdek kodunun farklı bir disk bloğunun yüklendiğini gösterir.)</para>
		
		<para>(Neden BIOS'un çekirdeği direk olarak yüklemediği ve önyükleme yükleyicisi ile iki adımlık bir sürec olduğunu merak edebilirsiniz. BIOS pek de akıllı değildir. Aslında çok aptaldır ve Linux onu önyükleme zamanından sonra bir daha kullanmaz. Başlangıçta BIOS, 8 bitlik ilkel PC'lerin ufak diskleri için yazılmıştı ve çekirdeği direk olarak yüklemek için diske yeteri kadar erişemiyordu. Önyükleme yükleyici aşaması, diskinizin farklı bölümlerindeki diğer işletim sistemlerini de başlatma imkanı verir. Kötü olan olay ise; bu konuda Unix pek iyi olmamasıdır.)</para>
		
		<para>Bir kere çekirdek başladığı zaman etrafına bakmak, diğer donanımları bulmak ve programları çalıştırmaya hazır hale getirir. Bu işi ise sıradan bellek yerlerini uyarmaktan ziyade, giriş/çıkış portları ile yapar - uygun özel veriyolu adresleri, cihaz denetleyicilerinin komutları için dinlediği özel veriyolu adresleridir. Çekirdek rastgele uyarı yapmaz; denetleyicilerin, hazır olanları muhtemelen nerede bulacağı ve ağer varlarsa bunların nasıl yanıt vereceği konusunda pek çok kendinden bilgiye sahiptir. Bu işleme ise özdevinimli algılama (autoprobing) denir.</para>

		<para>Önyükleme zamanıda gördüğünüz mesajların çoğu, çekirdeğinizin giriş/çıkış portları vasıtasıyla donanımı özdevinimli algılaması (autoprobing), uygun olanları bulması ve kendisini makinenize adapte etmesidir. Linux çekirdeği bu konuda, pek çok diğer Unixlerden ve DOS veya Windows'tan çok daha iyidir. Aslında, birçok eski linuxçunun Linux'un önyükleme zamanındaki akıllılığı (kurulumu görece basitleştirmesi) hakkındaki düşündüğü şey, büyük boyutta özgün Unix denemesi yapan kullanıcıların çekilmesinin önündeki temel engeldir.</para>
		
		<para>Ancak çekirdeğin tamamen yüklenmesi ve çalışması önyükleme işleminin sonu değildir; bu sadece ilk bölümdür (bazen 1. seviye çalışması (run level 1) denir). Bu ilk bölümden sonra çekirdek, 'init' denilen, toparlama süreçleri üreten özel bir sürecin kontrolünü ele alır.</para>
		
		<para>İnit sürecinin genellikle ilk işi; disklerinizi problemsiz olduğundan emin olmak amacıyla denetlemektir. Disk dosya sistemleri narin şeylerdir; eğer bir donanım hatası veya elektrik kesintisi nedeniyle hasar görürse, Unix'inizin gidişatından önce kurtarma adımlarını uygulamanız için yeterli nedenleriniz var demektir. Bu konuya daha sonra, <ulink url="http://tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/disk-layout.html#fsck">dosya sistemlerinde işlerin nasıl yanlış gittiği</ulink> konusunda konuştuğumuz zaman gireceğiz.</para>

		<para>İnit'in sonraki işi ise; birkaç artalan sürecini çalıştırmaktır. Artalan süreci, arkaplanda gizlenip birşeylerin olması bekleyen yazıcı kuyruklayıcısı, posta dinleyicisi ya da WWW sunucusu gibi bir programdır. Bu özel programlar, sıklıkla birkaç isteğin çakışmasını düzenlemekle yükümlüdürler. Bunlar artalan süreçleridir çünkü, sürekli çalışan ve tüm istekleri bilen bir programı yazmak yerine genellikle, birbirini kesmediğinden emin olunabilecek birçok (herbiri bir isteği işleyen ve hepsi aynı anda çalışan) program yazmak daha basittir. Sisteminizin başlattığı artalan süreçleri kümesi değişiklik gösterebilir, fakat neredeyse her zaman bir yazıcı kuyruklayıcı (yazıcınız için bir bekçi artalan süreci) bulunur.</para>
		
		
		
		<para>Bir sonraki adım ise kullanıcılara hazırlanmaktır. İnit konsolunuzu izlemek için, 'getty' denilen bir programın kopyasını başlatır (ve dial-in seri portlarını izlemek için belki daha fazla kopya). Bu, konsolda login promptları çıkaran programdır. Bir kere her terminal için tüm artalan süreçleri ve getty süreçleri başladığında, 2. seviyede çalışıyoruz demektir. Bu seviyede, giriş yapabilir ve programları çalıştırabilirsiniz.</para>
		
		<para>Ancak henüz bitmedi. Bir sonraki adım; ağ işlemlerini ve diğer servisleri destekleyen çeşitli artalan süreçlerini çalıştırmaktır. Bir kere bu işlem yapıdığında, 3. seviyede çalışıyoruz demektir ve sistem tam olarak kullanıma hazır demektir.</para>
	</sect1>
	
	<sect1 id="fundementals-howto-login"><title>Oturum açtığınız zaman ne olur?</title>
		
		<para>Giriş yaptığınız zaman (getty'e bir isim veriyoruz) bilgisayara kendinizi tanıtmış olursunuz. Daha sonra, sizin parolanızı alan ve makineyi kullanmak için yetkili kişi olup olmadığınızı kontrol eden login adında bir program çalıştırılır. Eğer değilseniz, giriş isteğiniz reddedilecektir. Eğer yetkili kişi iseniz, login toparlama ile ilgili birkaç şey yapar ve bir komut yorumlayıcısını çalıştırır, kabuğu. (Evet, getty ve login bir program olabilirdi. Bu programlar, burada bahsetmeyeceğimiz tarihsel nedenlerden dolayı ayrılmış durumdadır.)</para>
		
		<para>Burada, sistemin size kabuğu vermeden önce neler yaptığı konusunda daha çok şey vardır (bu konuya dosya izinleri konusunda konuştuğumuz zaman ihtiyaç duyabilirsiniz). Kendinizi bir login adı ve parolası ile tanıtırsınız. Bu login adı, her satırı bir kullanıcı hesabını tanımlayan bir satır dizisi olan, /etc/passwd olarak adlandırılan dosyanın içerisinde aranır.</para>
		
		<para>Bu alanlardan biri, hesap parolasının şifrelenmiş halidir (kimi zaman şifrelenmiş alanlar, aslında daha kısıtlı izinlerle /etc/shadow dosyasının içinde tutulur; bu durum parolanın kırılmasını zorlaştırır). Hesap parolası olarak girmiş olduğunuz şey tamamen aynı yolla şifrelenir ve login programı bunun uyumluluğunu kontrol eder. Bu metodun güvenliği şu gerçeğe bağlıdır: parolanızın sade halinden şifrelenmiş haline geçiş kolay oluyorken, tersi durum çok zordur. Böylece, parolanızın şifrelenmiş halini görseler bile, hesabınızı kullanamazlar. (Bu demek oluyor ki, parolanızı unuttuğunuz taktirde, geri almanızın bir yolu yoktur, sadece sizin seçtiğiniz şeylere bağlı olarak değiştirme imkanınız vardır.)</para>	
		
		<para>Bir kere başarılı bir giriş yaptığınızda, kullanıyor olduğunuz kişisel hesabınızla ilişkilendirilmiş hakların tümüne sahip olursunuz. Ayrıca bir grup üyesi olarak tanımlanmış olursunuz. Bir grup, sistem yöneticisi tarafından kurulan, kullanıcı topluluğuna verilen addır. Grupların, üyelerinin haklarından bağımsız olarak kendi hakları olabilir.Bir kullanıcı b,rçok gruba dahil olabilir. (Unix haklarının nasıl çalıştığı ile ilgili detaylar için, aşağıdaki <ulink url="http://tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/disk-layout.html#permissions">haklar</ulink> ile ilgili bölüme göz atabilirsiniz.)</para>

		<para>(Şunu not edelim: kullanıcılara ve gruplara ismiyle hitap edecek olsanız da, aslında sayısal ID'ler olarak tutulurlar. Parola dosyası, hesap adınızı bir kullanıcı ID'sine eşler; /etc/group dosyası, grup isimlerini sayısal grup ID'lerine eşleme işini yapar.Hesap ve gruplarla ilgilenen komutlar dönüşüm işini otomatik olarak yaparlar.)</para>
		
		<para>Hesap girdiniz, Unix dosya sisteminde kişisel dosyalarınızın bulunacağı yer olan ev dizinizi de içerir. Son olarak hesap girdiniz, login'in çalıştıracağı, komutlarınızı kabul edecek komut yorumlayıcısı olan kabuğunuzu da ayarlar.</para>
	</sect1>
	
	<sect1 id="fundementals-howto-run-programs"><title>Programları kabuktan çalıştırdığınız zaman ne olur?</title>
		
		<para>Kabuk, girmiş olduğunuz komutlar için Unix'in yorumlayıcısıdır; kabuk diye çağırılmasının sebebi işletim sistemi çekirdeğini sarıyor ve gizliyor olmasıdır. Unix'in önemli bir özelliği; kabuğun ve çekirdeğin sistem çağrılarının küçük bir kısmı ile iletişim kuran ayrı programlar olmasıdır. Bu durum, arayüzlerde farklı tatlar sağlayan çoklu kabuğu mümkün kılıyor.</para>
		
		<para>Giriş yaptıktan sonra, normal kabuğun vermiş olduğu '$' bilgi ekranını görürsünüz (başka birşey olacak şekilde özelleştirmediyseniz). Ekranda görebileceğiniz kabuk sözdizimi ve kolay şeylerden bahsetmeyeceğiz; onun yerine bilgisayarınızdaki görüntünün arkasındaki kısım olan sahne arkasına bakacağız.</para>
		
		<para>Önyükleme anından sonra ve bir program çalıştırmadan önce bilgisayarınızı, birşeyler yapmak için bekleyen süreçlerden oluşan bir hayvanat bahçesi olarak düşünebilirsiniz. Bunların tümü olaylara hizmet vermek için beklerler. Bir olay bir tuşa basmanız veya fareyi hareket ettirmeniz olabilir. Ya da eğer makineniz bir ağa takılmış durumda ise, ağ üzerinden bir veri paketinin gelmesi de bir olay olabilir.</para>
		
		<para>Çekirdek bu süreçlerden biridir. Özel bir tanesidir, çünkü diğer süreçler çalışabilirliğini o kontrol eder ve doğal olarak makinenin donanımına direk erişebilen tek süreç çekirdektir. Aslında, kullanıcı süreçleri klavye girişi almak, ekranınıza yazmak, diskten okuma ve yazma yapmak ya da bellekteki bitleri tek tek hesaplamak dışında herhangi birşey yapmak istediğinde, çekirdekten istekte bulunmak zorundadır. Bu istekler sistem çağrıları olarak bilinirler.</para>
		
		<para>Genelde, tüm giriş/çıkış'lar çekirdek üzerinden yürür, böylelikle çekirdek işlemleri planlayabilir ve süreçlerin birbirinin üzerine çıkmasına engel olur. Genellikle giriş/çıkış portların direk erişim verilerek birkaç özel kullanıcı sürecinin çekirdeği es geçmesine izin verilmiştir. X sunucuları (çoğu Unix makinelerinde ekran grafiklerini oluşturmak için öteki program isteklerini idare eden programlardır) bunun en genel örneğidir. Ancak henüz bir X sunucumuz yok; şu an komut satırına bakıyor durumdasınız.</para>	
		
		<para>Kabuk yalnızca bir kullanıcı sürecidir ve bilhassa özel bir süreç değildir. Klavye giriş/çıkış portlarını dinleyerek (çekirdek vasıtasıyla) tuş darbelerini bekler. Çekidek bunları görecek olursa, ekranınıza yansıtır. Eğer çekirdek bir 'Enter' gördüğü zaman, metninizin satırını kabuğa geçirir. Kabuk da bu tuş darbelerini komut olarak yorumlamaya çalışır.</para>
		
		<para>Diyelim ki Unix dizin listeleyicisini çağırmak için 'ls' yazdınız ve 'Enter'a bastınız. Kabuk, sizin /bin/ls dosyası içindeki komutları çalıştırma isteğinizi anlamak için kendisiyle tümleşik kuralları uygular. /bin/ls'yi bir alt süreç olarak başlatmak ve çekirdek vasıtasıyla ekrana ve klavyeye erişim izni vermek için çekirdeğe bir sistem çağrısı yapar. Daha sonra kabuk, ls'nin bitmesi için bekleyerek uykuya geçer.</para>
		
		<para>/bin/ls bittiği zaman, çekirdeğe bir sistem çağrısı yayarak bittiğini söyler. Daha sonra çekirdek kabuğu uyandırır ve çalışmaya devam edebileceğini söyler. Kabuk başka bir bilgi sistemi yayınlar ve başka bir giriş satırı için bekler.</para>
		
		<para>Bununla birlikte 'ls' çalıştığı sırada başka şeyler çalışıyor olabilir (çok uzun bir dizin listelediğinizi farzetmek zorundayız). Başka bir sanal konsol açabilir, giriş yapabilir ve bir Quake oyununa başlayabilirsiniz örneğin. Ya da, Internet'e takıldığınızı farzedin. /bin/ls çalıştığı sırada, makineniz posta gönderiyor veya alıyor olabilir.</para>
	</sect1>
	
	<sect1 id="fundementals-howto-input-devices"><title>Giriş cihazları ve kesmeler nasıl çalışır?</title>
		<para>Klavyeniz çok basit bir giriş cihazıdır; basittir çünkü az miktarda veriyi çok yavaş bir şekilde üretir (bilgisayar standartları ile). Bir tuşa bastığınızda ya da bıraktığınızda bu durum, klavye kablosuna bir donanım kesmesi için sinyal gönderir.</para>	
		
		<para>Bu tarz kesmeleri izleme işi de işletim sisteminin görevidir. Olası her bir kesme çeşidi için, kesmelerle beraber verileri (tuşa basma/bırakma değerleri gibi) çalıştırılıncaya dek saklayan bir kesme işleyicisi olacaktır.</para>
		
		<para>Tam olarak klavye kesme işleyicisinin yaptığı şey: tuş değerlerini belleğin en altında bulunan bir sistem alanına göndermektir. Orada ise, işletim sisteminin klavyeden okuma yapması beklenen programa kontrolü verdiği zaman, inceleme için kullanılabilir hale gelecektir.</para>

		<para>Disk veya ağ kartı gibi daha karmaşık giriş cihazları benzer yollarla çalışırlar. Daha önce, yerine getirilmiş olan bir disk istek sinyalini göndermek için kullanan bir disk denetleyicisinden bahsetmiştim. Disk bir kesme yapar. Disk kesme denetleyicisi, isteği yapan programın daha sonraki kullanımı için tekrar, getirilen veriyi belleğe kopyalar.</para>
		
		<para>Her bir çeşit kesmenin kendisi ile ilişkilendirilmiş bir öncelik seviyesi vardır. Düşük seviyeli kesmeler (klavye olayları gibi) yüksek öncelikli kesmeleri (saat darbeleri veya disk olayları) beklemek zorundadır. Unix, makinenin yanıt düzenini korumak için, hızlıca işlenmesi gereken olaylara yüksek öncelik verecek şekilde tasarlanmışır.</para>
		
		<para>İşletim sisteminizin önyükleme zamanı mesajlarında, IRQ numaralarını görüyor olmalısınız.Sebebine gelmeden önce biliyorsunuzdur; donanımın yanlış yapılandırılmasının en çok karşılaşılan şekli, iki farklı cihazın aynı IRQ' yu kullanmaya çalışmasıdır.</para>
		
		<para>Yanıtı burada. IRQ (Interrupt Request - Kesme İsteği) nin kısaltmasıdır. İşletim sistemi, açılması esnasında herbir donanım cihazının hangi numaralı kesmeyi kullanacak olduğunu bilmeye ihtiyacı vardır. Böylece her biri ile uygun olan işleyiciyi ilişkilendirir. Eğer iki farklı cihaz aynı IRQ'yu kullanmaya çalışırsa, kimi zaman kesmeler yanlış işleyiciye gönderilir. Genellikle bu durum cihazın kilitlenmesine ve işletim sisteminin uyku moduna geçmesine ya da çökmesine neden olacak şekilde işletim sistemini kötü bir biçimde yanıltır.</para>
	</sect1>
	
	<sect1 id="fundementals-howto-timesharing"><title>Bilgisayarım birkaç işi tek seferde nasıl yapar?</title>
		<para>Aslında yapmaz. Bilgisayarlar bir zaman diliminde yalnızca bir görevi (ya da süreci) yapabilir. Ancak bir bilgisayar görevleri çok hızlı bir şekilde değiştirebilir ve ağır olan insan duyularını, birkaç işi sanki tek bir seferde yapıyormuş gibi düşündürerek kandırır. Bu işleme "zaman paylaşımı(timesharing)" denir.</para>
		
		<para>Çekirdeğin işlerinden birisi, zaman paylaşımını yönetmektir. Çekirdeğin, planlayıcı adında, hayvanat bahçenizdeki diğer tüm (çekirdek olmayan) süreçleri hakkındaki bilgileri kendi içinde tutan bir parçası vardır. Her 1/60 saniyede, bir zamanlayıcı çekirdekteki işini bir saat kesmesi üreterek tamamlar. Planlayıcı, o anda çalışan süreçlerin hepsini durdurur, askıya alır ve başka bir sürecin kontrolüne verir.</para>
		
		<para>1/60 saniye uzun bir zaman gibi görünmeyebilir. Ancak günümüz mikroişlemcileri, çok miktarda iş yapabilen on binlerce makine komutunu çalıştırabilirler. Çok fazla süreciniz olsa bile, her biri kendi zaman diliminde bir miktar işi tamamlayabilirler.</para>
		
		<para>Pratikte, bir program kendi zaman diliminin tamamını almayabilir. Eğer bir giriş/çıkış cihazından bir kesme gelirse, çekirdek etkin olarak mevcut görevi durdurur, kesme işleyicisini çalıştırır ve daha sonra mevcut göreve geri döner. Bir yüksek öncelikli kesme fırtınası normal süreci tamamen çıkarabilir; bu yanlış davranış 'dayak' olarak adlandırılır. Neyse ki modern Unixlerde bu işlemin gerçekleşmesi oldukça zordur.</para>
		
		<para>Aslında, programların hızları, nadiren alabilecekleri makine zaman miktarı (bu kuralda birkaç istisnai durum vardır, örneğin ses veya üç boyutlu grafik nesli) ile limitlenir. Çok daha fazla sıklıkla, gecikmeler program disk sürücüsünden veya ağ bağlantısından veri beklemek zorunda olduğu zaman meydana gelir.</para>
		
		<para>Bir işletim sistemi, "Çok görevlilik" olarak adlandırılan çok sayıda eşzamanlı süreçleri düzenli olarak destekleyebilir. İşletim  sistemlerinin Unix ailesi baştan başa çok görevlilik için tasarlanmıştır ve bu işte oldukça iyidir - daha sonradan düşünülerek eklenilen ve oldukça başarısız bir biçimde yapılan Windows'lardan ya da eski Mac OS'lardan çok daha etkindir. Etkin, güvenilir çok görevlilik, ağda, iletişimde ve web servisinde Linux'u üstün kılan şeylerin büyük bir kısmını oluşturur.</para>
	</sect1>
	
	<sect1 id="fundementals-howto-memory-management"><title>Bilgisayarım süreçlerin birbiri üzerine çıkmasına nasıl engel olur?</title>
		<para>Çekirdek planlayıcısı, süreçlerin bir zamanda dilimine bölünmesi işine bakar. işletim sisteminiz de ayrıca bu süreçleri bir alana bölmek zorundadır, böylece süreçler birbirlerinin üzerine çıkamazlar; çalıştığı bellek. Tüm programların işbirliği içinde olmaya çalıştığını varsaysanız bile, içlerinden birinde, diğerlerin işini bozabilecek bir hatanın olmasını istemezsiniz. İşletim sisteminizin bu problemi çözmek için yaptığı işe bellek yönetimi denir.</para>
		
		<para>Hayvanat bahçenizdeki her süreç, kodu çalıştıracağı ve değişkenleri ve sonuçları içinde tutacağı kendi bellek alanına ihtiyaç duyar. Bu takımın salt okunur bir kod parçasından (code segment) (süreç komutlarını içeren) ve yazılabilir veri parçalasından (data segment) (tüm süreçlerin değişken belleğini içeren) oluştuğunu düşünebilirsiniz. Veri parçası her süreç için gerçekten tektir. Ancak aynı kodu iki süreç çalıştırırsa, Unix verimlilik açısından otomatik olarak bu süreçleri yalnız bir kod parçasını paylaşacak şekilde düzenler.</para>
		
		<sect2 id="fundementals-howto-memory-management-simple"><title>Sanal bellek: basit sürüm</title>
			<para>Verimlilik önemlidir, çünkü bellek pahalıdır. Kimi zaman makinenin çalıştırdığı tüm programların bütünlüğünü koruyacak kadar belleğe sahip değilsinizdir. Özellikle X sunucusu gibi büyük bir programı kullanıyorsanız. Bundan kaçınmak için  Unix, sanal bellek denilen bir tekniği kullanır. Sanal bellek, bellekteki bir süreç için kodun ve verinin tamamını tutmaya çalışmaz. Onun yerine, yalnızca nispeten daha kısa bir çalışma takımını bulundurur; sürecin geri kalan bütün durumları sabit diskinizde takas alanı denilen özel bir yerde bırakılır.</para>
			
			<para>Dikkat edin, bir önceki paragraftaki "kimi zaman", "hemen hemen her zaman" anlamında. Genellikle belleğin boyutu, çalışan programlarının boyutuna bağlı olarak küçüktü. Bu yüzden takaslama yaygındı. Bugünlerde bellek daha az pahalıdır ve alt uç makineler bile pek çoğuna sahiptir. 64 MB ve üstü modern tek kullanıclı makineler üzerinde, X'in ve tipik iş gruplarının çekirdeğe yüklenmesinden sonra takaslama olmaksızın çalıştırılmaları mümkümküdür.</para>	
		</sect2>
		<sect2 id="fundementals-howto-memory-management-detailed"><title>Sanal bellek: detaylı sürüm</title>
			<para>Aslında, son kısım bazı şeyleri bir miktar basitleştirmiştir. Evet, programlar belleğinizin çoğunu fiziksel bellekten daha çok olan, büyük, yassı adres bankası olarak görür ve takaslama bu yanılsamayı giderir. Ancak donanımınız aslında, içerisinde beş farklı tür bellekten daha azını bulundurmaz ve programların maksimum hız için ayarlanması zorunluluğu olduğu zaman aralarındaki farklılıklar iyi bir anlaşma konusu olabilir. Gerçekten de makinenizde neler olup bittiğini anlamak için, tüm bunların nasıl çalıştıklarını anlamalısınız.</para>
			
			<para>Beş bellek türü şunlardır : işlemci yazmaçları, dahili (veya çip üstü) önbellek, harici (veya çip dışı) önbellek, ana bellek ve disk. Çok tür olmasının nedeni ise basittir: hız para demektir. Bellek türlerini erişim zamanına göre artan, maliyete göre ise azalan sırada listeledim. Disk en yavaş, en ucuz ve saniyede 100 rastgele erişim yapabiliyor iken, yazmaç belleği en hızlı, en pahalı ve saniyede milyarlarca kez rastgele erişilebilir bir bellektir.</para>
			
			<para>Burada, tipik bir masaüstü makinesi için ilk 2000 hızı yansıtan bir listenin tamamı vardır. Hız ve kapasite artıp, fiyatlar düşüyor iken, bu oranların adil bir şekilde sabit olarak kalacağını ve o oranların bellek hiyerarşisini biçimlendirdiğini düşünebilirsiniz.</para>
			
			<para>Disk
				
				Size: 13000MB Accesses: 100KB/sec</para>
			
			<para>Ana Bellek
				
				Size: 256MB Accesses: 100M/sec</para>
			
			<para>Harici Önbellek
				
				Size: 512KB Accesses: 250M/sec</para>
			
			<para>Dahili Cache
				
				Size: 32KB Accesses: 500M/sec</para>
			
			<para>İşlemci
				
				Size: 28 bytes Accesses: 1000M/sec</para>
			
			<para>Herşey, en hızlı tür bellekler üzerine inşa edilemez. Bu yol çok maliyetli olabilir ve eğer öyle olmasa bile, hızlı bellek geçicidir. Güç kesildiği zaman üzerindeki verileri kaybedecektir. Böylece, bilgisayarların sabit diske veya güç kesildiği zaman verileri tutabilen geçici olmayan türdeki depolama cihazlarına sahip olması şarttır. İşlemciler ile disklerin hızları arasında devasa bir uyumsuzluk vardır. Bellek hiyerarşisinin üç orta seviyesi (dahili önbellek, harici önbellek ve ana bellek), temelde bu uçurumda bir köprü görevi görmek için vardır.</para>
			
			<para>Linux ve diğer Unixler sanal bellek denilen bir özelliğe sahiptir. Bu demek oluyor ki işletim sistemi sahip olduğundan daha fazla ana bellek varmış gibi davranır. Gerçek fiziksel ana belleğiniz, gerçekte herhangi bir zaman diliminde takas alanı denilen diskteki özel bir bölümde, çok daha büyük bir sanal bellek alanı üzerindeki pencere ya da önbellek takımı gibi davranır. Kullanıcı programlarının görüşlerinin dışında, işletim sistemi bu ilüzyonu sürdürebilmek için bellek ve disk arasında veri bloklarını ("pages") taşır. Sonuç olarak, sanal belleğiniz gerçek bellekten çok daha büyüktür, ancak çok fazla yavaş değildir.</para>
			
			<para>Sanal belleğinizin fiziksel bellekten ne kadar yavaş olduğu, işletim sisteminin takaslama algoritmalarının, programlarınızın sanal belleği kullanan yolu ile ne kadar uyumlu olduğuna bağlıdır. Neyse ki birbirine yakın zamanlarda olan bellek okuma ve yazmaları kümelenme eğilimindedirler. Bu eğilim yerellik (locality) veya daha resmi şekliyle referans yerelliği (locality of reference) olarak adlandırılır ve bu iyi birşeydir. Eğer bellek kaynakları rastgele sanal uzaydan geçerse; bir disk kadar yavaş olabilecek her yeni kaynak ve sanal bellek için diskten okuma veya yazma yapmalısınız. Ancak programların aslında sağlam bir yerellik sergilemesinden dolayı, işletim sisteminiz referans başına nispeten az takasmalama yapabilmektedir.</para>
			
			<para>Tecrübelere dayanılarak, bellek kullanım modellerinin geniş bir sınıfı için en etkili metodun oldukça basit olduğu saptanmıştır. Bu metot, LRU veya "least recently used - en yakın zamanda en az kullanılan" algotiması olarak adlandırılır. Sanal bellek sistemi ihtiyaç duyduğu için, disk bloklarını kendi "çalışma kümelerine (working set)" geçirir. Çalışma kümesi için fiziksel belleği tükettiğinde, en yakın zamanda kullanılmış bloğu atar. Tüm Unixler ve diğer pekçok sanal bellek işletim sistemi, LRU'da küçük varyasyonlar kullanır.</para>
			
			<para>Sanal bellek disk ve işlemci hızları arasındaki köprünün ilk bağlantısıdır. Açıkça işletim sistemi tarafından yönetilir. Ancak fiziksel ana belleğin hızı ve bir işlemcinin yazmaç belleklerine erişebileceği hızları arasında hala önemli bir uçurum vardır. Harici ve dahili önbellek, bu duruma bahsettiğim gibi sanal belleğe benzer bir teknik kullanarak adresler.</para>
			
			<para>Nitekim fiziksel ana belleğin, disk takas alanı üzerindeki pencere veya önbellek kümesi olarak davrandığı gibi, harici önbellek de ana bellekte pencereler gibi hareket eder. Harici önbellek daha hızlı (100 M'den ziyade, saniyede 250M erişim) ve daha küçüktür. Donanım (özellikle, bilgisayarınızın bellek denetleyicisi) LRU işini, harici önbellekteki ana bellekten getirilmiş veri blokları üzerinde yapar. Tarihsel nedenlerden dolayı önbellek takaslama ünitesi bir sayfadan ziyade, hat olarak adlandırılır.</para>

			<para>Ancak henuz bitirmedik. Dahili önbellek, harici önbellek kısımlarını önbellekleyerek, etkin hızdaki en son noktayı bize verir. Şimdi daha hızlı ve küçüktür - aslında işlemci çipinin hemen altında yer alır.</para>
			
			<para>Eğer gerçekten programlarınızı hızlandırmak istiyorsanız, bu detayları bilmek faydalı olacaktır. Sağlam bir yerellik olduğu zaman programlarınız daha hızlı çalışır, çünkü bu iş önbellekleme işini daha iyi yapar. Bu nedenle programları hızlı bir hale getirmenin en kolay yolu onları küçültmektir. Eğer bir program birçok giriş/çıkış veya ağ olaylarındaki beklemeler tarafından yavaşlatılmamışsa, genellikle uygun olacağı en küçük önbellek hızında çalışacaktır.</para>
			
			<para>Eğer programınızı bir bütün olarak küçültemiyorsanız, kritik hızdaki parçaları ayarlamak biraz çaba gerektirecektir. Böylelikle faydalı olabilecek daha sağlam bir yerelliğe sahip olacaklardır. Bu tarzdaki ayarlama tekniklerinin detayları, bu bilgilendirici rehberin de ötesinde bir alandadır. Bunlara ihtiyaç duyacağınız zamana kadar, pekçoğunu kendi kendinize çözebilecek kadar, epey bir derleyiciyle içli dışlı olacaksınız.</para>		
			
		</sect2>
		<sect2 id="fundementals-howto-memory-management-mmu"><title>Bellek Yönetim Ünitesi</title>
			<para>Takaslamadan sakınacak kadar fiziksel çekirdeğiniz olduğu zaman bile, bellek yöneticisi adında işletim sisteminizin bir parçasının hala yapacağı önemli bir işi vardır. Bellek yöneticisi, programların yalnızca kendi veri parçalarını değiştirebileceklerinden emin olmalıdır. Yani, bir program içindeki hatalı veya kötü niyetli kodların bir başka programın verisini ayıklamasını engeller. Bunu yapmak için, veri ve kod parçasının bir tablosunu tutar. Bir süreç ya da daha fazla bellek isteğinde bulunduğunda ya da belleği serbest bıraktığında (ikincisi genellikle sürecin çıkışında olur) tablo güncellenir.</para>
			
			<para>Bu tablo, komutların donanımın temelinde bulunan, MMU veya bellek yönetim ünitesi diye adlandırılan özelleştirilmiş parçasına geçirilmesinde kullanılır. Modern işlemci çipleri, hemen altında inşa edilmiş MMU'lara sahiptir. MMU'nun bellek alanları etrafına set çekmek gibi bir yeteneği vardır. Böylelikle dışarıdaki bir başvuru reddedilecek ve özel bir kesme sinyalinin çıkarılmasına neden olacaktır.</para>

			<para>Eğer hiç "Parçalama Hatası(Segmentation Fault)", "Çekirdek Boşaltıldı(Core Dumped)" veya benzer bir Unix mesajı gördüyseniz, tam olarak olan şudur; kendi parçası dışındaki belleğe(çekirdeğe) erişmeye çalışan bir program tarafından bulunulan bir girişim, ölümcül bir kesme çıkarır. Bu, program kodunda bir hata olduğunu gösterir; çekirdeğin boşalmasının arkasında, programcıya iz sürmede yardımcı olacak şekilde planlanmış tanısal bilgi yatar.</para>
			
			<para>Bir diğer yaklaşım; süreçlerin, eriştikleri belleği ayırmasının yanında, birbirlerinden korumasıdır. Onların eriştikleri dosyaları kontrol edebiliyor olmak da istersiniz. Böylece hatalı ya da kötü niyetli bir program, sistemin önemli parçalarını bozamaz. Bu nedenle Unix'te, daha sonra bahsedeceğimiz dosya izinleri vardır.</para>
		</sect2>
	</sect1>
	
	<sect1 id="fundementals-howto-store-in-memory"><title>Bilgisayarım birşeyleri bellekte nasıl saklar?</title>
		<para>Muhtemelen, bilgisayarınızdaki herşeyin sıralı bitler (ikili sayılar; bunları bir sürü ufak açma-kapama anahtarı olarak düşünebilirsiniz) olarak saklandığını biliyorsunuzdur. Burada, bu bitlerin bilgisayarınızın tek tek hesapladığı harfleri ve sayıları temsil etmede nasıl kullanıldıklarından bahsedeceğiz.</para>
		
		<para>Buraya girmeden önce, bilgisayarınızın kelime uzunluğu hakkında bilgi sahibi olmanız gerekmektedir. Kelime uzunluğu, bilgisayarınızdaki bilgi ünitelerini taşımak için tercih ettiği boyuttur. Teknik olarak, işlemcinizin aritmetik ve mantıksal hesaplamalarında kullanmak için tuttuğu alanlar olan yazmaçların genişliğidir. İnsanların, bilgisayarınızın bit boyutu("32-bit" veya "64-bit" olarak çağırırlar) hakkında yazdığında, kastettikleri şey budur.</para>

		<para>Çoğu bilgisayarlar (386,486 ve Pentium PC'ler dahil), 32 bitlik bir kelime uzunluğuna sahiptir. Eski 286 makineleri 16 bitlik bir kelime uzunluğuna sahipti. Eski model anabilgisayarlar çoğu kez 36 bitlik kelimelere sahipti. Eski DEC olan, AMD Opteron, Intel Itanium ve Alpha ve şimdiki Compaq 64 bitlik kelimelere sahiptir.</para>
		
		<para>Bilgisayarınız belleğinizi, bellek boyutuna bağlı olarak, sıfırdan çok büyük değerlere kadar numaralandırılmış kelime dizisi olarak görür. Bu değer, 286 gibi daha eski makinelerdeki programların, belleğinizin geniş miktarını adreslemek için açıklı eğilimlerde bulunmak zorunda kaldığı kelime uzunluğunuz tarafından limitlenmiştir. Onları burda anlatmayacağım; onlar hala eski programacıların kabusu oluyorlar.</para>	
		
		<sect2 id="fundementals-howto-store-in-memory-numbers"><title>Sayılar</title>
			<para>Integer sayılar, işlemcinizin kelime uzunluğuna bağlı olarak, kelimeler ya da kelime çiflerinden birisi olarak temsil edilirler. Bir 32 bitlik makine kelimesi, en genel integer temsilidir.</para>
			
			<para>Integer aritmetiği, ikili tabandaki matematiğe tam olarak olmasa da yakındır. Düşük değerli bir 1, sonraki 2, daha sonra 4 ve böylece bundan sonrası saf ikilidir. Ancak negatif işaretli sayılar ikiye tümleyen gösteriminde temsil edilirler. Yüksek değerli bit, niceliği negatif yapan işaret bitidir ve her negatif sayı, tüm bitlerin ters çevrilerek ve bir eklenerek elde edilen uygun olan pozitif değerden elde edilebilir. Bu nedenle, 32 bitlik bir makinedeki integerların -2^31 den 2^31-1'e kadar bir alanı vardır. Bu 32. bit işaret için kullanılıyor; 0, pozitif bir sayı veya sıfır, 1 ise negatif bir sayı anlamına gelir.</para>
			
			<para>Kimi bilgisayar dilleri, yalnızca sıfır ve pozitif sayılardan oluşan basit işaretsiz 2'li taban aritmetiğini kullanmanıza izin verir.</para>

			<para>Çoğu işlemciler ve bazı diller, işlemleri kayan noktalı sayılarla (bu yetenek tüm günümüz işlemci çiplerine inşa edilmiştir) işlem yapabilir. Kayan noktalı sayılar, integerlardan çok daha geniş bir değer aralığını size sunar ve parçaları ifade etmenize izin verir. Bunun yapılma şekli çeşitlidir ve burada ayrıntılı olarak bahsetmek için oldukça fazla karmaşıktır. Fakat ana fikir "bilimsel notasyon" debilen şey gibidir. Bu notasyonda 1.234*10^23 yazılabilir; bu da rakamın iki parçada, logaritmanın ondalık kısmı (1.234, mantissa) ve üslü kısım (23) olarak onun üssü şeklinde gösterilmesidir. (Bu da çarpımın 20 sıfırlı olacağı anlamına gelir, 23 üç ondalık kısmı çıkarır)</para>
		</sect2>
		<sect2 id="fundementals-howto-store-in-memory-characters"><title>Karakterler</title>
			<para>Normalde karakterler, herbiri ASCII(American Standard Code for Information Interchange) kodu olan, yedi bitle temsil edilir. Modern makinelerde, her 128 ASCII karakteri bir oktetin veya 8 bitlik bayt'ın düşük yedi bitidir. Oktetler bellek kelimeleri olarak paketlenmiştir. Böylece (örneğin) altı karakterli bir string, iki bellek kelimesi kadar yer kaplar. Bir ASCII kod tablosu için, Unix isteminizde 'man 7 ascii' yazınız.</para>
			
			<para>Önceki paragraf iki yolda yanıltıcıdır. Önemsiz olanı, 'octet' terimi formal olarak doğrudur, ancak gerçekten nadiren kullanılır. Çoğu insan octetten bayt olarak bahseder ve baytları da sekiz bit uzunluğunda farzeder. Tam olarak bayt terimi daha geneldir. Örneğin; 9 bitlik baytlardan oluşan 36 bitlik makineler (Gerçi bu durum muhtemelen bir daha asla olmayacak) kullanılmıştır.</para>
			
			<para>Daha önemli bir şey ise, dünyanın tamamının ASCII kullanmıyor olmasıdır. Aslında, dünyanın çoğu kullanamaz. ASCII, Amerikan İngilizcesi için uygun iken, aksan eksiklikleri ortaya çıkmış ve diğer dillerin kullanıcıları özel karakterlere ihtiyaç duymuşlardır. Hatta Britanya İngilizcesinin pound para biriminin işaretinin eksikliği ile başı beladadır.</para>
			
			<para>Bu problemi çözmek için birtakım denemeler vardır. Bunların tümü, ASCII'de olmayan, onu 256'lık karakter kümesinin düşük yarısı yapan, ekstra olarak yüksek bit kullanır. Bunlar için en yaygın olarak kullanılan, 'Latin-1' karakter kümesidir (daha resmi çağırımı ISO 8859-1). Bu karakter kümesi, Linux, daha eski HTML versiyonları ve X için öntanımlı karakter kümesidir. Microsoft Windows, tarihsel nedenlerden dolayı Latin-1'in atanmamış olarak bıraktığı (bu sıkıntının sebep olduğu incitici hesabı için <ulink url="http://www.fourmilab.ch/webtools/demoroniser/">demoronizer</ulink> sayfasını ziyaret ediniz) uygun olan yerlere sağ ve sol çift tırnak gibi, Latin-1'e bir demet karakter ekleyen değiştirilmiş bir versiyonunu kullanır.</para>
			
			<para>Latin-1, İngilizce, Fransızca, Almanca, İspanyolca, İtalyanca, Hollandaca, Norveççe, İsveççe, Danimarkaca ve İzlandacayı içeren batı Avrupa dillerini kullanır. Ancak, ikisi de yeterince iyi değildir ve sonuç olarak, Yunanca, Arapça, İbranice, Esperanto ve Sırp-Hırvat dili gibi dilleri kullanmak için, 9 karakter kümesi içerisinden Latin-2 serisinin bir bütünüdür. Detaylar için,<ulink url="http://czyborra.com/charsets/iso8859.html"> ISO soup alfabesi</ulink> sayfasını ziyaret ediniz.</para>
			
			<para>Nihai çözüm, Unicode (ve onun tek yumurta ikizi ISO/IEC 10646-1:1993) denilen muazzam bir standarttır. Unicode Latin-1'e, içindeki en düşük 256 yuvası ile özdeştir. Yukarıdaki bu 16 bitlik uzay, Yunanca, Kirilce, Ermenice, İbranice, Arapça, Devanagari, Bengal, Gurmukhi, Gujarati, Oriya, Tamil, Telugu, Kannada, Malayalam, Tayca, Laoca, Gürcüce, Tibetçe, Kana Japoncası dillerini, Hangul Korecesinin tümünü ve Çince/Japonca/Korece (CJK) ideogramının bir birleşimini içerir. Detaylar için, <ulink url="http://www.unicode.org/">Unicode Anasayfasını</ulink> ziyaret ediniz.</para>		
		</sect2>
	</sect1>
	
	<sect1 id="fundementals-howto-store-on-disk"><title>Bilgisayarım birşeyleri diske nasıl depolar?</title>
		
		<para>Unix'teki bir sabit diske baktığınız zaman, dosya ve dizin isimlerinin bir ağacını görürsünüz. Normalde, daha derinine bakma ihtiyacı duymayacaksınız, ancak bir disk arızası olduğunda ve dosyaları kurtarmaya ihtiyaç duyduğunuzda, aşağıda neler olup bittiğini bilmek faydalı olabilir. Ne yazık ki disk organizasyonunu, dosya seviyesinden yukarıdan aşağı doğru açıklamanın bir yolu yoktur. Bu yüzden bu durumu donanımdan yukarıya doğru açıklamak zorunda kalacağım.</para>
		
		<sect2 id="fundementals-howto-store-on-disk-low-level"><title>Düşük seviyeli disk ve dosya yapısı</title>
			<para>Diskinizin veriyi depolayan yüzey alanı, dart tahtasına benzer şekilde, pasta dilimleri şeklindeki sektörlerden oluşan dairesel izlere bölünmüştür. İzlerin dış tarafının, disk merkezindeki mile yakın olanlardan daha fazla alana sahip olmasından dolayı, dıştaki izler içerideki izlerden daha fazla sektör dilimlerine sahiptir. Herbir sektör (ya da disk bloğu), modern Unixlerde genellikle 1 ikili K (1024 8 bitlik kelime) olan, aynı boyutlara sahiptir. Her disk bloğu, tekil bir adrese ve disk blok sayısına sahiptir.</para>
			
			<para>Unix, diski disk bölümlerine ayırır. Her bölüm, ya dosya sistemi ya da takas alanı olan, diğer bölümlerden ayrı olarak kullanılan devamlı bir blok zinciridir. Parçalamanın için asıl nedenleri; çok daha yavaş ve hata yapabilir disklerin dünyasındaki arızaları telafi etmek zorunda olmasıdır. Bunlar aralasındaki sınırlar, diskinizdeki herhangi bir kötü nokta tarafından erişilemez duruma getirilen veya bozulan muhtemel disk bölümlerinizi azaltır. Bu günlerde, parçalamanın salt okunur tanımlanabilecek (kritik sistem dosyalarını değiştiriken çıkan davetsiz misafirlere karşı korumak) veya burada ele almayacağımız çeşitli nedenlerden dolayı ağ üzerinde paylaştırılabilecek olması daha önemlidir. Diskteki en düşük numaralı bölüm çoğu zaman, önyükleme için çekirdeği yerleştirebileceğiniz önyükleme bölümü gibi davranılır.</para>		
			
			<para>Herbir bölüm ya takas alanı (<ulink url="http://tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/memory-management.html#vm">sanal belleği</ulink> gerçekleştirmede kullanılan) ya da dosyaları tutmada kullanılan dosya sistemidir. Takas alanı parçalarına, yalnızca doğrusal bir blok dizisiymiş gibi davranılır.  Diğer bir taraftan, dosya sistemleri, dosya isimlerini disk bloklarına eşlemek için bir yola ihtiyaç duyar. Dosyaların büyümesinden, küçülmesinden ve zamanla değişmesinden dolayı, bir dosyanın veri blokları doğrusal bir dizi olmayacaktır, ancak kendi bölümünün tümüne dağıtılmış olabilir (işletim sisteminin ihtiyaç duyup bulabileceği boş bir veri bloğu her nerede ise). Bu dağıtmanın etkisi parçalama olarak adlandırılır.</para>
			
		</sect2>
		<sect2 id="fundementals-howto-store-on-disk-file-names"><title>Dosya isimleri ve dizinleri</title>
			<para>Her dosya sisteminde, isimlerin bloklara eşlenmesi, i-node denilen bir yapı ile yürütülür. Her dosya sisteminin (en düşük olanları ev idaresi ve burda açıklamayacağımız amaçları sınıflandırmak için kullanılır) dibinin (en düşük numaralı bloklar) yanında bu nesnelerin bir havuzu vardır. Herbir i-node bir dosyayı tanımlar. Dosya veri blokları (dizinleri içeren) i-node'ların üzerinde bulunur (yüksek numaralı bloklarda).</para>
			
			<para>Her i-node, tanımladığı dosyadaki disk blok sayılarınının bir listesini içerir. (Aslında bu yarı gerçektir, sadece küçük dosyalar için doğrudur, ancak burada diğer detaylar önemli değildir.) i-node'un dosyanın ismini içermediğine dikkat edelim.</para>
			
			<para>Dosyaların isimleri dizin yapılarında bulunur. Bir dizin yapısı, yalnızca isimleri i-node numaralarına eşler. Bunun nedeni; Unix'te, bir dosya birden fazla gerçek isme (ya da sıkı bağa) sahip olabilir. Onlar sadece, aynı i-node'a işaret ederken oluşan çoklu dizin girdileridir.</para>
		</sect2>
		<sect2 id="fundementals-howto-store-on-disk-mount-points"><title>Bağlama noktaları</title>
			<para>En basit durumda, Unix dosya sisteminizin tamamı yalnızca bir disk bölümünde bulunur. Kimi ufak Unix sistemlerinde bu düzeni görseniz de, bu durum olağandışıdır. Daha tipik olarak, muhtemelen farklı fiziksel disklerdeki çeşitli disk bölümleri arasında yayılırlar. Bu yüzden, örneğin sisteminiz bulunduğu ufak, işletim sistemi altyapı hizmetlerinin bulunduğu biraz daha büyük ve kullanıcı ev dizinlerinin bulunduğu çok daha büyük bir bölüme sahip olabilir.</para>
			
			<para>Sistem önyüklemesinden sonra doğrudan doğruya erişeceğiniz tek bölüm, (hemen hemen her zaman) önyüklemenizin yapıldığı yer olan kök bölümünüzdür. Bu bölüm, dosya sisteminizdeki öteki herşeyin bağlı bulunduğu, en üstteki düğüm olan kök dizinini tutar.</para>
			
			<para>Çok bölümlü dosya sisteminizin tümünün erişilebilir olması için, sistemdeki diğer bölümlerin bu köke bağlanılması şarttır. Önyükleme işleminin yarısında, Unixiniz bu köksüz bölümleri erişilebilir yapacaktır. Her bir bölümü, kök bölümünün üzerindeki bir dizine bağlayacaktır.</para>
			
			<para>Örneğin; /usr diye bir Unix dizinine sahipseniz, bu dizin muhtemelen Unix'inizle kurulmuş ancak, başlangıçtaki önyükleme sırasında gerekli görülmemiş, birçok programı içeren bir bölüme ait bir bağlama noktasıdır.</para>
		</sect2>
		<sect2 id="fundementals-howto-store-on-disk-looked-up"><title>Bir dosya nasıl yoklanır?</title>
			<para>Artık dosya sistemine yukarıdan aşağı doğru bakabiliriz. Bir dosyayı (mesela <filename>/home/esr/WWW/ldp/fundamentals.xml</filename> ) açtığınız zaman şunlar olur: </para>
			
			<para>Çekirdeğiniz, Unix dosya sisteminizin kökünde çalışmaya başlar (kök bölümünde). 'home' adında bir dizini arar. Genellikle 'home', başka bir yerdeki daha büyük bir kullanıcı bölümüne ait bir bağlama noktasıdır. Böylece çekirdek oraya gider. Kullanıcı bölümünün en üst seviyedeki dizin yapısında, 'esr' adında bir girdiye bakar ve bir i-node numarası çıkarır. Çekirdek bu i-node'a gider, ilişkili dosya veri bloklarının bir dizin yapısında olduğunu farzeder ve 'WWW' a bakar. Bu i-node'u çıkararak, uygun olan altdizine gidecek ve 'ldp'ye bakacaktır. Bu ise çekirdeği, başka bir dizin i-node'una kadar götürecektir. Bu i-node'a giriş yaparak, 'fundamentals.xml' için bir i-node numarası bulacaktır. Bu i-node bir dizin değildir ancak, onun yerine dosya ile ilişkili olan disk bloklarının bir listesini tutar.</para>	
		</sect2>
		<sect2 id="fundementals-howto-store-on-disk-permissions"><title>Dosya sahipliği, izinler ve güvenlik</title>
			<para>Programları, üstüne basmamaları gereken kazara veya kötü niyetli verilerden korumak için, Unix izin özelliklerine sahiptir. Bunlar aslında, Unix'in çoğunlukla pahalı paylaşılmış minibilgisayarlarda çalıştığı günlerde, aynı makinelerdeki çoklu kullanıcıları birbirlerinden koruyarak, zaman paylaşımını desteklemek amacıyla tasarlanmıştır.</para>
			
			<para>Dosya izinlerini anlamak için, <ulink url="http://tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/login.html">Giriş yaptığınız zaman ne olur ?</ulink> bölümündeki kullanıcıların ve grupların açıklamalarına yeniden bakmanız gerekir. Her dosyanın bir kullanıcısı ve grup sahibi olur. Bunlar, başlangıçta bu dosya oluşturucularınındır. chown(1) ve chgrp(1) programları ile değiştirilebilir.</para>

			<para>Bir dosya ile ilişkilendirilebilecek temel izinler 'okuma' (dosyadan veri okuma izni), 'yazma' (dosyada değişiklik yapabilme izni) ve 'çalıştırma' (dosyayı bir program olarak çalıştırabilme izni) dır. Her dosya 3 izin kümesine sahiptir; birisi kullanıcı sahibi, birisi sahiplik grubundaki herhangi bir kullanıcı ve birisi de kalan tüm kullanıcılar içindir. Giriş yaptığınız zaman sahip olduğunuz haklar; sadece kullanıcı ID'niz ile eşleşen izin bitleri, yer aldığınız gruplardan birisi ya da diğerleri için erişebilebilir olan dosyalara okuma, yazma ve çalıştırma yapabilmektir.</para>
			
			<para>Bunların birbirini nasıl etkileyebileceğini ve Unix'in bunları nasıl görüntüleyeceğine, varsayılan bir Unix sistemindeki dosya listelemesine bakarak görelim.
				<screen>snark:~$ ls -l notes
-rw-r--r--   1 esr      users         2993 Jun 17 11:00 notes</screen></para>

			<para>Bu, sıradan bir veri dosyasıdır. Listeleme bize şunu gösterir ki: bu dosyanın sahibi 'esr' kullanıcısıdır ve sahip grup olan 'users' ile oluşturulmuştur. Muhtemelen bulunduğumuz makine, her sıradan dosyayı öntanımlı olarak bu gruba dahil eder; zaman paylaşımlı makinelerde yaygın olarak görülen diğer gruplar ise "staff", "admin" veya "wheel" grubudur (açıktır ki tek kullanıcılı iş istasyonları ve PC'lerde gruplar çok önemli değildir).</para>

			<para>'-rw-r--r--' karakte dizisi, dosya için izin bitlerini temsil eder. En baştaki çizgi, dizin bitinin yeridir; eğer dosya bir dizin ise 'd', sembolik bir bağlantı ise 'l' göstermelidir. Bundan sonraki ilk üç alan kullanıcı izinleri, ikinci üçlü grup izinleri ve kalan üçlü ise diğerlerinin (sıklıkla 'diğer' izinleri denir) izinleridir. Bu dosyada, sahip kulanıcı 'esr' okuma veya yazma, diğer 'kullanıcılar' grubundakiler okuma ve 'diğer'deki herkes okuma yapabilir. Bunlar, sıradan bir dosya için tipik bir izin kümesidir.</para>
			
			<para>Şimdi çok değişik izinlere sahip bir dosyaya göz atalım. Bu dosya, GNU C derleyicisi olan GCC'dir.
				<screen>snark:~$ ls -l /usr/bin/gcc
-rwxr-xr-x   3 root     bin         64796 Mar 21 16:41 /usr/bin/gcc</screen></para>
			
			<para>Bu dosya, 'root' adında bir kullanıcıya ve 'bin' adındaki bir gruba aittir; yalnızca root tarafından yazılabilir (değiştirilebilir), ancak herhangi biri tarafından okunabilir veya çalıştırılabilir. Bu, kurulu olan sistem komutu için tipik bir sahipliği ve izin kümesidir. 'bin' grubu, bazı Unixlerdeki sistem komutları (ismi tarihi bir kalıntıdır, 'binary' nin kısaltmasıdır) ile birlikte bulunan gruplarda bulunur. Bunun yerine Unixiniz 'root' grubunu kullanabilir ('root' kullanıcısı tamamen aynı değildir!).</para>

			<para>'root' kullanıcısı, sayısal kullanıcı ID 0'ın, özel, tüm haklarını geçersiz kılabilecek ayrıcalıklı hesabının klasikleşmiş ismidir. Root erişimi kullanışlıdır ancak tehlikelidir; root olarak giriş yaptığınızda yapılan hatalı bir yazım, aynı komutun sıradan bir kullanıcı hesabı tarafından çalıştırıldığında dokunamayacağı kritik sistem dosyalarını tahrip edebilir.</para>
			
			<para>Root hesabının oldukça güçlü olmasından dolayı, ona yapılacak erişim çok dikkatlice korunmalıdır. Root parolanız, sisteminizdeki güvenlik bilgisinin en kritik tek parçasıdır ve sizden sonra gelen kırıcıların ve davetisiz misafirlerin ele geçirmeye çalışacağı şeydir.</para>
			
			<para>Parolalar hakkında : Parolaları not etmeyiniz ve kız arkadaşınızın, erkek arkadaşınızın ya da eşinizin ismi gibi kolaylıkla tahmin edilebilen parolalar seçmeyiniz. Bu, kırıcılara sonuna kadar yardımcı olmayacak kadar, şaşılacak derecede genel olan kötü bir pratiktir. Genelde, sözlükten hiçbir kelime seçmeyiniz; kırıcıların, genel seçimlerden oluşan kelime listesini çalıştırarak olası parolaları araştırdığı, sözlük denilen programlar vardır. Bir kelimenin, rakamın ve başka bir kelimeden oluşan bir kelime kombinasyonunun seçilmesi iyi bir tekniktir. Örneğin: ‘shark6cider’ ya da ‘jump3joy’. Bu seçimler, bir sözlük kırıcısı için arama uzayını oldukça genişletecektir. Kırıcıların bu belgeyi okuduktan sonra bunları sözlüklerine ekleyebileceklerinden dolayı, bu örnekleri kullanmayınız.</para>
			
			<para>Şimdi de üçüncü duruma göz atalım:
				<screen>snark:~$ ls -ld ~
drwxr-xr-x  89 esr      users          9216 Jun 27 11:29 /home2/esr
snark:~$ </screen></para>
			
			<para>Bu dosya bir dizindir (ilk izinler alanındaki 'd' dikkat ediniz). Şunu görüyoruz ki: bu dizin sadece esr tarafından yazılabilir, ancak herkes tarafından çalıştırılabilir.</para>
			
			<para>Okuma izni, dizini listeleme imkanınını size sunar. Bu demek oluyor ki: dizinin içerdiği dosya ve dizinlerin isimlerini görebilirsiniz. Yazma izni, dizin içerisinde dosya oluşturma veya silme imkanı sunar. Bir dizinin içinde bulunan dosya ve dizin isimlerinin bir listesini içerdiğini hatırlayacak olursanız, bu kurallar bir anlam ifade edecektir.</para>
			
			<para>Bir dizindeki çalıştırma izni, o dizinin altındaki dosya ve dizinleri açmak için, bu dizini geçebileceğiniz anlamına gelir. Aslında, dizin içerisindeki i-node'lara erişim iznini verir. Bir dizinin tamamen çalıştırılmaya kapalı olması yararsız olacaktı.</para>
			
			<para>Kimi zaman bir dosyanın diğerleri tarafından çalıştırılabilir olduğunu ancak okunabilir olmadığını göreceksiniz. Bu demek oluyor ki: herhangi bir kullanıcı, bunun altındaki dosya ve dizinlere erişebilir, ancak sadece isimlerini bildiği taktirde (dizin listelenemez).</para>
			
			<para>Bir dizin üzerinde okuma, yazma veya çalıştırma izninizin, onun altında bulunan dosya ve dizinlerin izinlerinde bağımsız olduğunun hatırlanması önemlidir. Özellikle, bir dizine yazma izni, orada yeni dosyalar oluşturabileceğiniz veya varolan dosyaları silebileceğiniz anlamına gelir. Ancak, otomatik olarak varolan dosyalara yazma erişim iznini size vermez.</para>
			
			<para>Son olarak, giriş programının kendi izinlerine göz atalım.
				<screen>snark:~$ ls -l /bin/login
-rwsr-xr-x   1 root     bin         20164 Apr 17 12:57 /bin/login</screen></para>
			
			<para>Bu, bir sistem komutu için bekleyeceğimiz izinleri içerir. 's' nin, sahibi çalıştırabilir bit olması gerektiğini hariç tutunuz. Bu, 'set-user-id' veya setuid bit denilen özel iznin açık bir görünümüdür. </para>
			
			<para>Normalde setuid biti, sıradan kullanıcılara root haklarını vermesi gereken programlara eklenir. Ancak kontrollü bir yolla. Çalıştırılabilir bir programda bu bite atama yapıldığı zaman, size ait olanla eşleşse de eşleşmese de, sizin adınıza program çalışırken, program dosyasının sahibinin haklarına sahip olursunuz.</para>
			
			<para>Root hesabının kendisine benzer şekilde, setuid programları kullanışlıdır, fakat tehlikelidir. Root sahipliğindeki bir setuid programını bozabilen veya değiştirebilen herhangi biri, bu durumu root hakları ile bir kabuk oluşturmak için kullanabilir. Bu nedenle, çoğu Unixlerde, bir dosyanın yazma için açılması, otomatik olarak setuid bitini kapalı hale getirir. Unix güvenliğine karşı yapılan çoğu saldırılar, onları bozmak için setuid programlarındaki hataları kullanırlar. Bilinçli sistem güvenlik yöneticileri bu sebepten dolayı, bu tarz programlar hakkında ekstra olarak dikkatli davranırlar ve yenilerini kurmak konusunda isteksizdirler.</para>
			
			<para>İzinler konusunda konuşurken gizlediğimiz birkaç önemli detay var; şöyle ki, bir dosya veya dizin ilk defa yaratıldığında, sahip grup ve izinleri ataması nasıl yapılır. Grup bir sorundur, çünkü kullanıcılar birden fazla grubun üyeleri olabilirler, ancak onlardan birisi (kullanıcının /etc/passwd dosyasında belirtilmiş olan) kullanıcının öntanımlı grubudur ve normalde kendi dosyaları kullanıcı tarafından oluşturulur.</para>
			
			<para>Başlangıç izin bitlerinin hikayesi biraz daha karışıktır. Normalde bir program, beraber çalışmaya başlaması için, izinlerini belirleyecek şekilde dosyayı oluşturur. Ancak bunlar, kullanıcı ortamında bulunan, umask denilen bir değer tarafından değiştirilecektir. Umask, bir dosya oluştururken hangi izin bitlerinin kapalı hale getirileceğini belirler; en genel ve çoğu sistemdeki öntanımlı olan değer, diğerlerinin yazabileceği biti kapalı hale getiren -------w- ya da 002 dir.</para>
			
			<para>Başlangıçtaki dizin grubu da biraz karmaşıktır. Kimi Unixlerde, yeni bir dizin, oluşturan kullanıcının öntanımlı grubunu alır (System V kuralı); diğerlerinde, onun oluşturmuş olduğu üst dizinin sahip grubunu alır (BSD kuralı). Linux da dahil kimi modern Unixlerde, dizindeki set-group-ID'nin ataması yapılarak ikinci davranış seçilebilir (chmod g+s).</para>
		</sect2>
		<sect2 id="fundementals-howto-store-on-disk-go-wrong"><title>Hangi durumlarda birşeyler ters gidebilir</title>
			
			<para>Daha önceleri, dosya sistemlerinin narin şeyler olabileceği bir ipucu idi. Artık şunu biliyoruz ki; bir dosyaya ulaşmak istediğinizde, keyfi olarak uzun olabilen bir dizin ve i-node başvuru zincirinin üzerinde seksek oynamanız şarttır. Artık sabit diskinizin kötü noktalar oluşturduğunu varsayınız.</para>
			
			<para>Eğer şanslı iseniz, yalnızca bazı dosyalara zarar verecektir. Değilseniz, bir dizin ya da i-node yapısını bozabilir ve sistem altağacınızın tümünü zindanda asılı bir halde bırakabilir. Ya da daha kötüsü, aynı disk bloğu veya i-node'da bulunan birden fazla yola işaret eden bozulmuş bir yapı ile sonuçlanır. Bu tarz bozulmalar, aslında kötü noktada bulunmayan verilere zarar verilerek yapılan,  normal dosya sistemi işlemleri yoluyla dağıtılabilir.</para>
			
			<para>Neyse ki bu tarz beklenmedik olay, disk donanımının daha güvenilir olduğu için, çok nadiren oluşur. Gene de bu olay, hiçbirşeyin yanlış olmadığından emin olmak için, Unixinizin periyodik bütünlük denetimi isteyeceği anlamına gelir. Modern Unixler, bağlamadan hemen önce önyükleme zamanında, her bölümde hızlı bir bütünlük denetimi yapar. Yapacakları her birkaç yeniden başlatma, birkaç dakikalık zaman alan, çok daha titiz bir denetleme işlemi yaparlar.</para>
			
			<para>Eğer tüm bunlar, Unixin korkunç derecede karmaşık ve bozulmaya meyilli olduğunu gösteriyorsa, bu önyükleme zamanı denetimlerinin, gerçekten feci bir hale gelmeden önce, tipik normal problemleri yakaladığını ve düzelttiğini bilmek güven verici olabilir. Diğer işletim sistemleri, önyüklemeyi bir nebze hızlandırmasına ve elle kurtarma yapmaya kalkıştığınızda çok ciddi derecede berbat etmesine rağmen bu tür araçlara sahip değildir (ve bu, ilk kısımda bulunan, Norton Utilities'in ya da her ne ise, bir kopyasına sahip olduğunuzu farzeder).</para>
			
			<para>Bugünkü Unix tasarımlarındaki eğilimlerden biri; dosya sistemi günlüklemedir. Bunlar diskteki trafiği düzenler. Böylece sistem geri geldiğinde, tutarlı durumun kurtarılabilmesi güvence altına alınmış olur. Bu durum, önyükleme zamanındaki bütünlük denetimini oldukça hızlandıracaktır.</para>
		</sect2>
	</sect1>
	
	<sect1 id="fundementals-howto-computer-languages"><title>Bilgisayar dilleri nasıl çalışır?</title>
		
		<para><ulink url="http://tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/running-programs.html">Programların nasıl çalıştığından</ulink> bahsetmiştik. Her program eninde sonunda, bilgisayarınızın makine dilindeki komutları byte akımı olarak çalıştırmak zorundadır. Ancak insan duyuları makine diliyle pek de anlaşamaz; bu durum çok nadiren oluşmuştur, hatta hackerlar arasında bile büyücülük haline gelmiştir.</para>
		
		<para>Hemen hemen tüm Unix kodları, çekirdekteki doğrudan donanım arayüz desteğinin ufak bir miktarını hariç tutar, bugünlerde yüksek seviyeli dillerde yazılmıştır('yüksek seviyeli' terimi bunları, aslında makine kodu etrafındaki ince sargı olan, 'düşük seviyeli' assembler dillerinden ayırt etme anlamına gelen bir tarihi kalıntıdır.)</para>
		
		<para>Farklı, çeşitli türde yüksek seviyeli diller vardır. Bunlardan bahsetmek amacıyla, bir programın kaynak kodunun, makinenin gerçekte çalıştırabildiği makine kodlarına çeşitli şekillerde çevirilmek zorunda olduğunun akılda tutulmasının kullanışlı olacağını anlayacaksınız.</para>
		<sect2 id="fundementals-howto-computer-languages-compiled"><title>Derlenen diller</title>
			<para>En geleneksel dil türü: derlenen bir dildir. Derlenen diller, derleyici denilen (mantıksal olarak yeterli) özel bir program tarafından, ikili makine kodunun çalıştırılabilir dosyalarına dönüştürülür. Bir kere ikili kod oluşturulduğunda, bu kodu tekrardan kaynak koduna bakmaksızın doğrudan çalıştırabilirsiniz. (Pek çok yazılım, sizin görmediğiniz koddan üretilen, derlenmiş ikili kod olarak teslim edilir.) </para>
			
			<para>Derlenen diller, kusursuz performans gösterme ve işletim sistemine tam erişime sahip olmaya meyillidir. Ancak programlanması da zordur. </para>
			
			<para>Unix'in yazıldığı dil olan C, dillerin (varyantı olan C++'la birlikte) önemli bir kısmından açık ara farkla öndedir. FORTRAN, hala mühendisler ve bilim adamları tarafından kullanılan, ancak eski ve ilkel olan bir başka bir derlenen dildir. Unix dünyasında, ana görüşe göre kullanılan başka derlenen diller yoktur. Bunun dışında, COBOL finansal ve işletme yazılımında yaygın olarak kullanılır.</para>
			
			<para>Başka birçok derlenen dil kullanılmıştır, ancak çoğunun ya nesli tükenmiştir ya da tam anlamıyla araştırma araçlarıdır. Derlenen bir dil kullanan yeni bir Unix geliştiricisi iseniz, o dil çok çok büyük bir ihtimalle C ya da C++'dır.</para>
		</sect2>
		<sect2 id="fundementals-howto-computer-languages-interpreted"><title>Yorumlanan diller</title>
			<para>Yorumlanan diller, kaynak kodu okuyan ve hesaplamalara ve sistem çağrılarına anında (on the fly) dönüştüren bir yorumlayıcı programına bağlı bulunur. Kaynağın kodun yürüteceği her zaman diliminde yeniden yorumlanması (ve mevcut yorumlayıcı) şarttır.</para>
			
			<para>Yorumlanan diller, derlenen dillere göre daha yavaş olmaya meyillidir ve çoğu zaman işletim sisteminin ve donanımın alt kısmına sınırlı erişime sahiptir. Diğer bir taraftan, basit olmaya meyillidir ve derlenen dillere göre kod hatalarında daha bağışlayıcıdır.</para>
			
			<para>Kabuk, bc(1), sed(1) ve awk(1)'yi içeren birçok Unix hizmeti; etkin, ufak derlenen dillerdir. BASICler genellikle yorumlanan dillerdir. Tcl gibi. Tarihe göre, en önemli yorumlayıcı dil LISP (varislerinin çoğundan daha büyük gelişme) olmuştur. Bugün, Unix kabukları ve Emacs düzenleyicisinde bulunan Lisp, muhtemelen en önemli, saf yorumlanan dillerdir.</para>
		</sect2>
		<sect2 id="fundementals-howto-computer-languages-p-code"><title>P-code diller</title>
			<para>1990'dan beri, derlemeyi ve yorumlamayı kullanan bir çeşit melez dil artarak önemli bir hal aldı. P-code diller, kaynağın, gerçekte yürüttüğünüz ancak makine dili olmayan, sıkıştırılmış bir ikili koda dönüştürülmesi açısından derlenen dillerle benzerlik gösterir. Onun yerine genellikle gerçek makine dilinden daha basit ama daha güçlü sözde kod (ya da p-code) vardır. Programı yürüttüğünüzde, p-code'u yorumlarsınız.</para>
			
			<para>P-code, neredeyse derlenen bir ikili kod kadar hızlı çalışabilir (p-code yorumlayıcıları daha basit, ufak ve hızlı yapılabilir). Ancak p-code diller, iyi bir yorumlayıcının esnekliğini ve gücünü bulundurabilir.</para>
			
			<para>Önde gelen p-code dilleri Python, Perl ve Java'dır.</para>
		</sect2>
	</sect1>
	
	<sect1 id="fundementals-howto-internet"><title>Internet nasıl çalışır?</title>
		<para>Internetin nasıl çalıştığı konusunda size yardımcı olmak için, Linux Belgelendirme Projesinin web anasayfasındaki bu dökümanın, ön sayfasındaki bir tarayıcıyı göstererek, tipik bir Internet işlemi yaptığınız zaman neler olduğuna bakacağız. Bu belge

			<screen><ulink url="http://www.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/index.html"/></screen></para>

		<para>Bu, www.tldp.org konağının, World Wide Web dışa aktarma dizini altındaki HOWTO/Unix-and-Internet-Fundamentals-HOWTO/index.html dosyasında bulunduğu anlamına gelir.</para>
		
		<sect2 id="fundementals-howto-internet-names"><title>İsimler ve konumlar</title>
			<para>Tarayıcınızın yapması gereken ilk şey: belgenin bulunduğu makineye bir ağ bağlantısı kurmaktır. Bunu yapmak için ilk başta, www.tldp.org konağının ('host', 'host makinesi' ya da 'ağ konağı'nın kısaltmasıdır; www.tldp.org, tipik bir konak adıdır) konumuna olan ağı bulmak zorundadır. İlgili konum, aslında IP adresi denilen sayıdır (bu terimin 'IP' kısmını daha sonra açıklayacağız).</para>
			
			<para>Bunu yapmak için tarayıcınız, isim sunucusu denilen bir programı sorgular. İsim sunucusu makinenizde bulunabilir, ancak konuştuğunuz servis makinesinde çalışması daha muhtemeldir. Bir ISP ile kaydolduğunuz zaman kurulum yordamının parçası, hemen hemen kesinlikle, Internet yazılımınıza ISP ağının üzerindeki isim sunucusunun IP adresini bildirmesi gereklidir.</para>
			
			<para>Faklı makinelerdeki isim sunucuları birbirleriyle, konak isimlerini çözümlemek için gereken tüm bilgileri takas yaparak ve güncel tutarak haberleşirler (onları IP adreslerine eşleyerek). İsim sunucunuz, www.tldp.org çözümleme işlemindeki, üç ya da dört farklı yerdeki ağ arasında sorgulama yapmalıdır, ancak bu durum genellikle çok hızlı olur (bir saniyeden daha az). İsim sunucusu detaylarına bir sonraki bölümde bakacağız.</para>
			
			<para>İsim sunucusu, www.tldp.org'un IP adresinin 152.19.254.81 olduğunu tarayıcınıza bildirecektir. Makineniz bunu bilerek, bitleri www.tldp.org'le doğrudan takas yapabilme imkanına sahip olacaktır.</para>
		</sect2>
		<sect2 id="fundementals-howto-internet-dns"><title>Alan Adı Sistemi</title>
			<para>Konak isimlerini Ip adreslerine çevirirken birlikte çalışan programların ve veritabanlarının ağlarının tümü 'DNS' olarak adlandırılır (Domain Name System). 'DNS sunucusu' terimine atıfta bulunulduğunu gördüğünüzde, yalnıca isim sunucusunu çağırdığımız anlamına gelir. Şimdi, sistemin tümünün nasıl çalıştığından bahsedeceğim.</para>
			
			<para>Internet konak isimleri, noktalarla birbirinden ayrılmış kısımlarda oluşur. Bir alan, yaygın isim soneklerini paylaşan makinelerin bir toplamıdır. Örneğin; www.tldp.org makinesi, .org etki alanının .tldp.org alt etki alanında bulunur.</para>
			
			<para>Her alan, alandaki diğer makinelerin IP adreslerinden haberdar olan yetkili bir isim sunucusu tarafından tanımlanır. Yetkili (ya da 'birincil') isim sunucusu, bozulacağı durumda yedekleme yapmalıdır; bir ikincil isim sunucusuna ya da ('ikincil DNS') atıfta bulunulduğunu görürseniz, bunlardan birinden bahsediyoruz demektir. Bu ikinciller tipik olarak, her birkaç saatte bir birincillerinden bilgilerini yenilerler, böylece birincil üzerindeki alan adından IP'ye eşleme yapılacak bir değişiklik otomatik olarak yayılır.</para>
			
			<para>Şimdi, burası önemli bir bölümdür. Bir alan için isim sunucuları, diğer alanlarda bulunan (kendi alt alanları içeren) tüm makinelerin konumlarını bilmek zorunda değildir; yalnızca isim sunucularının konumlarını bilmek zorundadır. Örneğimizde, .org alanı için yetkili isim sunucuları, .tldp.org içim isim sunucularının Ip adreslerinden haberdadır, ancak .tldp.org'daki diğer makinelerin tümünden değildir.</para>
			
			<para>DNS sistemindeki etki alanları, ters çevrilmiş büyük bir ağaç gibi düzenlenir. En tepedekiler kök sunuculardır. Herkes, kök sunucuların Ip adreslenebilir, bunlar DNS yazılımınıza tel ile bağlıdırlar. Kök sunucular, .com ve .org gibi üst seviye etki alanları için olan isim sunucularının IP adreslerini bilirler, ancak bu etki alanlarının içerisindeki makinelerin adreslerini bilmezler. Her üst seviye alan sunucusu, etki alanlarının direk olarak altında bulunan isim sunucularından haberdardır, vesaire.</para>
			
			<para>DNS'nin dikkatlice tasarlanmasıyla, her makine, ihtiyaç duyduğu ağacın biçimi hakkındaki bilginin az bir miktarı ile çıkabilir ve alt ağaçlardaki yerel değişiklikler, bir yetkilili sunucunun isim-IP adres eşleme veritanının değiştirilmesiyle basitçe yapılabilir.   </para>
			
			<para>www.tldp.org adresinin IP adresi için sorgulama sırasında aslında gerçekleşen şey: İlk başta isim sunucunuz, .org için bir isim sunucusunu nerede bulabileceğini söylemesi için kök sunucusuna sorar. Bir kere bunu öğrendikten sonra, .tldp.org isim sunucusunun IP adresini söylemesi için .org sunucusuna sorar. Bir kere bunu öğrendikten sonra da, www.tldp.org. konağının adresini söylemesi için .tldp.org isim sunucusuna sorar.</para>
			
			<para>Çoğu zaman aslında isim sunucunuz bu kadar katı çalışmaz. İsim sunucuları çok fazla önbellekleme yapar; isim sunucunuz bir konak adı çözümlediği zaman, kısa bir süreliğine, bellekte bulunan sonuç IP adresle olan ilişkisini tutar. Bu nedenle, yeni bir web sitesini ziyaret ettiğinizde, genellikle sadece getiriyor olduğunuz ilk sayfa konağının aranması hakkında tarayıcınızdan bir mesaj görürsünüz. Sonuç olarak, isim-adres eşlemesinin süresi biter ve DNS'niz yeniden sorgulama yapmak zorundadır. Bu önemlidir, böylece bir konak adı adresi değiştirdiği zaman, sonsuza dek boş boş dolanan geçersiz bilgiye sahip olmazsınız. Bir site için önbelleklemiş olduğunuz IP adresi de, konak erişilemez durumda olduğunda reddedilir.</para>
		</sect2>
		<sect2 id="fundementals-howto-internet-packets"><title>Paketler ve Yönlendiriciler</title>
			<para>Tarayıcının yapmak istediği şey, www.tldp.org üzerindeki Web sunucusuna şuna benzer bir komut olarak gönderilir:
				
				<screen>GET /LDP/HOWTO/Fundamentals.html HTTP/1.0</screen>
			</para>
	
			<para>Nasıl olduğu buradadır. Komut, kaynak adres (makinenizin Ip adresi), hedef adres (152.19.254.81) ve bunun bir World Wide Web isteği olduğunu belirten bir servis veya port numarası (bu durumda 80) gibi üç önemli şeyle sarılmış, telgrafa benzer bir bit bloğu olan bir paket haline getirilir.</para>

			<para>Daha sonra makineniz, paketinizi, yönlendirici denilen özel bir makineye ulaşıncaya dek, telin (ISP bağlantınız ya da yerel ağ) altına nakleder. Yönlendirici, belleğinde, her zaman tam olmayan, fakat birinin ağınızın komşuluğunu tamamı ile açıklayan ve Internet üzerinden diğer komşuluklara nasıl gidebileceğimizi bilen bir Internet haritasını taşır.</para>

			<para>Paketiniz hedefine ulaşıncaya dek çeşitli yönlendiriciler üzerinden geçebilir. Yönlendiriler akıllıdır. Yönlendiriciler, diğer yönlendiricilerin bir paket alımını onaylamanın ne kadar zaman alacağını izlerler. Ayrıca bu bilgiyi, hızlı bağlantılar üzerindeki trafiği yönetmek için kullanırlar. Bunu, başka bir yönlendiricinin (veya bağın) düştüğünü farketmek için ve bir başka yönlendirici bularak bu durumu telafi etmek için kullanırlar.</para>

			<para>Bir efsaneye göre; Internet, nükleer savaşta hayatta kalmak için tasarlanmıştır. Bu doğru değildir, ancak güvenilmez bir dünyada, kat kat donanınımın haricinde güvenilir performans sağlaması konusunda aşırı derecede iyidir. Bu durum direk olarak, birkaç ağır ve zayıf anahtarlardan daha ziyade, binlerce yönlendirici üzerinden dağıtılması olan zekasından kaynaklanır (telefon ağı gibi). Bu durum, başarısızlıkların iyi yerelleştirilmesine eğilimli olduğu ve ağın bunlar etrafından yönlendirme yapabileceği anlamına gelir.</para>

			<para>Bir kere paketiniz hedef makineye ulaştığı zaman bu makine, paketi web sunucunda beslemek için servis numarasını kullanır. Web sunucusu, paketin kaynak IP adres komutuna bakarak, nereye cevaplama yapılacağını söyleyebilir. Web sunucusu bu belgeyi geri döndürdüğü zaman, bu belge birkaç pakete parçalanacaktır.Paket boyutları, ağdaki iletim araçlarına ve servis türüne bağlı olarak çeşitlilik gösterir.</para>
		</sect2>
		<sect2 id="fundementals-howto-internet-tcp-ip"><title>TCP ve IP</title>
			<para>Birden fazla paket iletiminin nasıl ele alındığını anlamak için, Internetin aslında diğerlerin üzerine yığılmış olan iki protokolü olduğunu bilmeniz gerekir.</para>

			<para>Düşük seviye olan IP (Internet Protocol), tekil olan paketleri, ağ üzerinden iki bilgisayarın bilgi alışverişinin kaynak ve hedef adresleri ile birlikte etiketlemesinden sorumludur. Mesela http://www.tldp.org'e eriştiğinizde; gönderdiğiniz paketler, 192.168.1.101 gibi bilgisayarınızın IP adresine ve www.tldp.org'un IP adresi olan 152.2.210.81'e sahip olacaktır. Birileri size bir yazı gönderdiğinde sizin ev adresiniz nasıl çalışıyorsa, bu adresler de aynı yolla çalışır. Postane, bu adresleri okuyabilir, nerede olduğunuza ve Internet trafiğindeki bir yönlendiricinin yaptığı gibi yazıyı size en iyi şekilde nasıl yönlendirebileceğine karar verebilir.</para>

			<para>Daha üst seviye olan TCP (Transmission Control Protocol), güvenilirliği sağlar. İki makine bir TCP bağlantısını görüştüğünde (IP kullanarak yaptıkları) alıcı, paketin onayını gönderene geri yollayacağını bilir. Gönderici bazı zaman aşımı noktalarında bir onay görmez ise, bu paketi tekrar gönderir. Ayrıca, gönderici her TCP paketine, düzensiz gösterim durumunda paketleri yeniden toplamak için kullanabileceği bir sıra numarası verir. (Bu durum, bir bağlantı sırasında ağ bağlantılarında iniş veya çıkışlar olduğu durumda kolayca oluşur.)</para>

			<para>TCP/IP paketleri ayrıca, kötü bağlantılar tarafından bozulmuş verinin belirlenmesini etkin hale getirmek için, bir sağlama toplamı içerir. (Sağlama toplamı, paketin geri kalanı kullanılarak hesaplanır; ya paketin geri kalanı ya da sağlama toplamı bir şekilde  bozulmuştur, yeniden hesaplama ve karşılaştırma kuvvetle muhtemelen hata verecektir.) Böylece, TCP/IP ve isim sunucularını kullanan birisinin bakış açısıyla, konak adı/servis numarası ikilileri arasındaki byte akımlarının geçişi için güvenilir bir yol gibi görünür. Ağı protokollerini kaleme alan insanlar, neredeyse hiçbir zaman, bu seviyenin altında gelişen paketleme, yeniden paket toplama, hata kontrolü, sağlama toplaması ve yeniden iletim  hakkında düşünmek zorunda değildir.</para>
		</sect2>
		<sect2 id="fundementals-howto-internet-http"><title>HTTP, bir uygulama protokolü</title>
			<para>Şimdi tekrar örneğimize geri dönelim. Web tarayıcıları ve sunucuları, TCP/IP'nin en üstünde çalışan, basitçe bayt stringlerini geriye ve dışarıya geçirmede kullanan bir uygulama protokolü üzerinden konuşurlar. Bu protokol HTTP (Hyper-Text Transfer Protocol) olarak adlandırılır ve bunu daha önce bir komutta görmüştük - yukarıda gösterilmiş olan GET.</para>

			<para>GET komutu www.tldp.org web sunucusuna 80 servis numarası ile gittiği zaman, 80 portunu dinleyen bir artalan sunucusuna dağıtılır. Çoğu Internet servisi, hiçbirşey yapmayan ancak portları bekleyen, gelen komutları izleyen ve çalıştıran artalan sunucuları tarafından gerçekleştirilirler. </para>

			<para>Eğer Internet tasarımı bir kuralın tümüne sahip ise, tüm parçalar basit ve mümkün olduğunca insanlarca erişilebilir olmalıdır. HTTP ve onunla ilişkili olanlar (konaklar arasında elektronik posta geçişinde kullanılan Simple Mail Transfer Protocol, SMTP gibi), satırbaşı/satır beslemesi ile biten ve basit olan basılabilir komutları kullanmaya eğilimlidir.</para>
			
			<para>Bu sonuna kadar verimsizdir. Bazı durumlarda, sıkı kodlanmış ikili protokolleri kullanarak daha çok hız elde edebilirsiniz. Ancak tecrübeler şunu gösteriyor ki; komutlara sahip olmanın avantajları, birşeyleri hileli ve şeffaf olmayan hale getirebilmenizin maliyetinde elde edebileceğiniz, etkinlikdeki herhangi bir marjinal faydadan daha önemli olduğunu açıklamak ve anlamak, insanlar için kolay olur.</para>
				<para>Bu nedenle, sunucunun size TCP/IP yolu ile geri gönderdiği şey de metindir. Yanıtın başlangıcı şuna benzer bir şeye benzeyecektir (birkaç başlık saklanmıştır):
				
				<screen>HTTP/1.1 200 OK
Date: Sat, 10 Oct 1998 18:43:35 GMT
Server: Apache/1.2.6 Red Hat
Last-Modified: Thu, 27 Aug 1998 17:55:15 GMT
Content-Length: 2982
Content-Type: text/html</screen></para>
	
			<para>Bu başlıklar bir satır boşluk ve web sayfasının metni ile devam ettirilecektir (düşen bağlantıdan sonra). Tarayıcınız yalnızca bu sayfayı görüntüler. Başlıklar bunun nasıl oluduğunu söyler (özellikle Content-Type başlığı, geri dönen verinin gerçekten HTML olduğunu söyler).</para>
		</sect2>
	</sect1>
	
	<sect1 id="fundementals-howto-more"><title>Daha fazla bilgi edinmek için</title>
		<para>Burada değinmiş olduğumuz konular hakkında daha fazla bilgi sahibi olmak için okuyabileceğiniz kitapların listesi olan bir <ulink url="http://docs.comu.edu.tr/howto/reading-list.html">Linux Okuma Listesi Nasıl</ulink> belgesi vardır. Ayrıca, <ulink url="http://docs.comu.edu.tr/howto/hacker-howto.html">Nasıl Hacker Olunur</ulink> belgesini de okumak isteyebilirsiniz.</para>
	</sect1>
</article>