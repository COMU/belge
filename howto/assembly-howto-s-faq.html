<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-9"><meta name="date" content="2006-04-25T01:45:23+03:00"><title>Sýkça Sorulan Sorular</title><link rel="icon" type="image/png" href="../images/belgeler-logo.png"><link rel="stylesheet" href="../belgeler.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V-special(derived from 1.49 for Turkish Linux Documentation WG by Nilgün Belma Bugüner - nilgun@superonline.com)"><link rel="home" href="../KiTAPLIK/index.html" title="Linux Kitaplýðý"><link rel="up" href="../howto/assembly-howto.html" title="Linux Makina Dili NASIL"><link rel="previous" href="../howto/assembly-howto-s-res.html" title="Özkaynaklar"><link rel="next" href="../howto/assembly-howto-app.html" title="Ekler"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><table width="100%" summary="Navigation header" cellpadding="1" cellspacing="0" border="0"><tr><td bgcolor="black" class="navoutline"><table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td bgcolor="white" class="navinline"><table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><th colspan="3" align="center">Sýkça Sorulan Sorular</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="../howto/assembly-howto-s-res.html">Önceki</a> </td><th width="60%" align="center">Linux Makina Dili NASIL</th><td width="20%" align="right"> <a accesskey="n" href="../howto/assembly-howto-app.html">Sonraki</a></td></tr></table></td></tr></table></td></tr></table><dl><div class="sect1"><dt><div> <h2 class="title" style="clear: both"><a name="assembly-howto-s-faq"></a>Sýkça Sorulan Sorular</h2></div></dt><dd><p>
Aþaðýda Linux sembolik makina dili ile programlamada sýkça sorulan sorular (cevaplarý ile) verilmiþtir. Bazý soruar ve cevaplarý <a class="link" href="../howto/assembly-howto-s-res.html#assembly-howto-s-res-list" title="Listeler">linux-assembly ileti listesi</a>nden alýnmýþtýr.
</p><div class="qandaset"><dl><dt>2.8.1.  <a href="../howto/assembly-howto-s-faq.html#id1">
Linux altýnda nasýl grafik programlama yaparým?
</a></dt><dt>2.8.2.  <a href="../howto/assembly-howto-s-faq.html#id2">
Saf (pure) sembolik makina kodunu Linux altýnda nasýl derlerim?
</a></dt><dt>2.8.3.  <a href="../howto/assembly-howto-s-faq.html#id3">Baþka faydalý araçlar var mý?</a></dt><dt>2.8.4.  <a href="../howto/assembly-howto-s-faq.html#id4">
Linux'tan (BSD, BeOS, v.b.) BIOS iþlevlerine nasýl eriþebilirim?
</a></dt><dt>2.8.5.  <a href="../howto/assembly-howto-s-faq.html#id5">
Sembolik makina dilinde çekirdek modülleri yazmak mümkün mü?
</a></dt><dt>2.8.6.  <a href="../howto/assembly-howto-s-faq.html#id6">
Belleði dinamik olarak nasýl tahsis edebilirim?
</a></dt><dt>2.8.7.  <a href="../howto/assembly-howto-s-faq.html#id7">
select sistem çaðrýlarýný nasýl kullanacaðýmý anlayamýyorum!
</a></dt></dl><p></p><hr><p></p><dl><dt class="question"><a name="id1"></a><a name="id1"></a><b>2.8.1. </b> <b>
Linux altýnda nasýl grafik programlama yaparým?
</b></dt><dd class="answer"><b></b> <p>
<a class="ulink" href="mailto:paulf%C2%A0(at)%C2%A0icom.co.za">Paul Furber</a>'den bir cevap:
</p><p>
<pre class="literallayout">
Pekala, Linux'ta grafik iþleri için pekçok araç vardýr. Hangisini
kullanacaðýnýz ne yapmak istediðinize baðlýdýr. Tüm bilgilere sahip
bir web sayfasý yoktur ama iþte bir kaç püf nokta:

SVGALib: Bu, konsoldan SVGA eriþimi için C kütüphanesidir.
Artýlarý: öðrenmesi kolay, iyi kodlama örnekleri, DOS'taki gfx
kütüphanesinden pek de farklý deðil, DOS'taki tüm etkiler az bir
deðiþiklikle dönüþtürülebilir.
Eksileri: program doðrudan donanýma eriþtiði için, çalýþmak için root
eriþim yetkilerine gerek duyar, her çip (chipset) ile çalýþmaz,
X-Windows altýnda çalýþmaz.
http://ftp.is.co.za'da svgalib-1.4.x diye aratýn.

Framebuffer: SVGA ile ilgili kendinizce yapýlabilen grafikler
Artýlarý: hýzlý, doðrusal olarak haritalanmýþ video eriþimi,
eðer isterseniz ASM kullanýlabilir :)
Eksileri: çekirdek içinde derlenmeli, çipsete özgün özellikler,
çalýþmasý için X kapatýlmalý, iyi linux sistem çaðrýlarý ve çekirdek
bilgisine dayanýr, hata ayýklamasý zordur
Örnekler: asmutils (http://www.linuxassembly.org), yaprak örneði,
framebuffer kodu ve asm ile ilgili ipuçlarý için benim sayfam
(http://ma.verick.co.za/linux4k/)

Xlib: XFree86 için uygulama ve geliþtirme kütüphaneleri.
Artýlarý: X uygulamanýz üzerinde tam bir kontrol
Eksileri: Öðrenmesi zor, çalýþmasý korkunç ve az da olsa X'in düþük
seviyede nasýl çalýþtýðý bilgisini gerektirir
Tavsiye edilmez, ama onu için bu kadar yanýp tutuþuyorsanýz durmayýn.
Muhtemelen tüm baþlýk ve kütüphane  dosyalarý yüklenmiþtir, dolayýsiyle
ihtiyacýnýz olana sahipsiniz.

Düþük seviyeli API'ler: PTC, SDL, GGI ve Clanlib'i içerir.
Artýlarý: çok esnek, X veya konsolda çalýþýr, video donanýmýný soyutlar
onun için düzgün doðrusal bir yüzey çizebilirsiniz, pekçok güzel örnek kod,
OpenGL ve ses kütüphaneleri gibi diðer API'lere baðlantý kurabilir
Microsoft DirectX sürümleri özgürdür.
Artýlarý: Kendi yaptýðýnýz kadar hýzlý deðildir, geliþim sürecince bazen
sürümler çok sýk deðiþir.
Örnekler: PTC ve GGI mükemmel demolara sahiptir, SDL ise oyunlar için,
sdlQuake, Myth II, Civ CTP ve ayrýca Clanlib'de kullanýlmýþtýr.

Yüksek seviyeli API'ler: OpenGL - baþka var mý?
Artýlarý: temiz API, yüzlerce iþlevsellik ve örnek, endüstriyel
standart; bundan dolayý mesela SGI'dan öðrenilebilir
Eksileri: donaným hýzlandýrýlmasý normalde bir zorunluluktur,
bazý sürümler ve platformlar arasýnda acayiplikler
Örnekler: çokça - baðlantýlar bölümü altýndaki www.mesa3d.org kýsma bakýnýz.

Bakmayý sürdürmek için svgalib örneklerini inceleyin ve ayný zamanda
SDL'yý yükleyin ve çalýþýr duruma getirin. Bundan sonrasýnda ise limit
gökyüzüdür.
</pre>
</p><p></p></dd><dt class="question"><a name="id2"></a><a name="id2"></a><b>2.8.2. </b> <b>
Saf (pure) sembolik makina kodunu Linux altýnda nasýl derlerim?
</b></dt><dd class="answer"><b></b> <p>
Sembolik Makina Dili Hata Ayýklayýcýsý'nýn (<a class="ulink" href="http://ald.sourceforge.net/" target="_top">Assembly Language Debugger</a>), sembolik makina kodlarýyla çalýþmasý için tasarlanmýþ eski bir sürümü vardýr ve de Linux ve *BSD üzerinde çalýþmabilmesi için yeterince taþýnabilirdir. Halihazýrda iþlevseldir ve de doðru seçim olacaktýr, bir bakýn!
</p><p>
<b><tt>gdb</tt></b>'yi de deneyebilirsiniz ;). Kaynak kod hata ayýklayýcýsý olmasýna raðmen, saf sembolik makina kodlarýný ayýklamak için de kullanýlabilir, biraz hileyle <b><tt>gdb</tt></b>'ye istediðinizi yapmanýzý söyleyebilirsiniz (maalesef <b><tt>nasm</tt></b>'ýn <tt>g</tt> seçeneði <b><tt>gdb</tt></b> için yeterli bilgi üretmemektedir; sanýrým bu <b><tt>nasm</tt></b>'ýn bir açýðý). Aþaðýda Dmitry Bakhvalov <span class="email">&lt;dl (at) gazeta.ru&gt;</span>'dan bir cevap var:
</p><p>
<pre class="literallayout">
Kiþisel olarak, gdb'yi asm uygulamarýnýnýn hatalarýný bulmak için
kullanýrým. þunu deneyin:

1) Derlemek için aþaðýdaki kodu kullanýn:
   $ nasm -f elf -g smth.asm
   $ ld -o smth smth.o

2) gdb'yi çalýþtýrýn
   $ gdb smth

3) gdb içinde:
   (gdb) disassemble _start
   at _start+1'e bir kesme koyun
    (eðer at _start konursa çalýþmaz, nedenini bilmiyorum)
   (gdb) b *0x8048075

   kodu takip edebilmek için aþaðýdaki kodu kullanýrým
   (gdb)define n
   &gt;ni
   &gt;printf "eax=%x ebx=%x ...etc...",$eax,$ebx,...etc...
   &gt;disassemble $pc $pc+15
   &gt;end

   daha sonra programý r parametresiyle çalýþtýrýp, n ile hata ayýklayýn

   Umarým yardýmcý olmuþtur.
</pre>
</p><p>
???'dan ek bir bilgi:
</p><p>
<pre class="literallayout">
  .gdbinit'imin içinde epeydir kullandýðým bir makro var,
  ve eminim hayatý daha kolay hale getiriyor.
  Az farkla: "x /8i $pc"' kullanýrým bu da belli sayýdaki çevrilmemiþ
  koda müsaade eder.  Daha sonra iyi þekilde boyutu seçilmiþ xterm'imle
  gdb çýktýsý tazelenmiþ olarak ve kaydýrma gerektirmeden görünür.
</pre>
</p><p>
Eðer kodunuza kesmeler koymak istiyorsanýz, sadece <tt>int 3</tt> ifadesini kesme olarak kullanabilirsiniz. (<b><tt>gdb</tt></b> içerisine elle adresi gömmek yerine).
</p><p>
Eðer gas kullanýyorsanýz, gas ve gdp ile ilgili <a class="ulink" href="http://linuxassembly.org/resources.html#tutorials" target="_top">belgelere</a> baþvurmalýsýnýz..
</p><p></p></dd><dt class="question"><a name="id3"></a><a name="id3"></a><b>2.8.3. </b> <b>Baþka faydalý araçlar var mý?</b></dt><dd class="answer"><b></b> <p>
Elbette, <b><tt>strace</tt></b> size yardým edebilir (FreeBSD'de <b><tt>ktrace</tt></b> ve <b><tt>kdump</tt></b>), bu sistem çaðrý ve sinyallerini takip etmek için kullanýlýr. Ayrýntýlar için kýlavuz sayfasýný (<b><tt>man trace</tt></b>) ve <b><tt>strace --help</tt></b> komutunu deneyiniz.
</p><p></p></dd><dt class="question"><a name="id4"></a><a name="id4"></a><b>2.8.4. </b> <b>
Linux'tan (BSD, BeOS, v.b.) BIOS iþlevlerine nasýl eriþebilirim?
</b></dt><dd class="answer"><b></b> <p>
Kýsa cevap: Hiç bir þekilde. Bu korumalý bir kiptir, yerine iþletim sistemi servislerini kullanýn. Tekrar ediyorum, <tt>int 0x10</tt>, <tt>int 0x13</tt>, v.b.'yi kullanamazsýnýz. Ne þans ki, hemen her þey sistem çaðrýlarý ve kütüphane iþlevleri ile ifade edilebilmektedir. En kötü durumda, port eriþimini deneyebilir ve bir çekirdek yamasýyla istenileni gerçekleþtirmeyi deneyebilirsiniz veya LRMI kütüphanesini kullanarak BIOS iþlevlerine eriþmeyi deneyin.
</p><p></p></dd><dt class="question"><a name="id5"></a><a name="id5"></a><b>2.8.5. </b> <b>
Sembolik makina dilinde çekirdek modülleri yazmak mümkün mü?
</b></dt><dd class="answer"><b></b> <p>
Evet, aslýnda mümkün. Her ne kadar genelde iyi bir fikir olmamasýna raðmen (bir þeyleri çok zor hýzlandýracaktýr), böylesine bir yönteme ihtiyaç olabilir. Bir modülün kendisini yazmak o kadar da zor deðildir - bir modülün kendisinin öntanýmlý evrensel iþlevleri olmalýdýr, ayný zamanda bazý harici iþlevleri de çekirdekten çaðýrmasý gerekebilir. Ayrýntýlar için çekirdek kaynak koduna (bir modül olarak derlenebilenlere) bakýnýz.
</p><p>
Bu arada, iþte size en basitinden bir çekirdek modülü
(kaynak APJ #8'den mammon_'un örneðine dayanmaktadýr):
</p><p>
<div class="programlisting" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="programlisting">section .text

        global init_module
        global cleanup_module
        global kernel_version

        extern printk

init_module:
        push    dword str1
        call    printk
        pop     eax
        xor     eax,eax
        ret

cleanup_module:
        push    dword str2
        call    printk
        pop     eax
        ret

str1            db      "init_module done",0xa,0
str2            db      "cleanup_module done",0xa,0

kernel_version  db      "2.2.18",0
</pre> </td></tr></table></div>
</p><p>
Bu örneðin yaptýðý tek þey yaptýklarýný rapor etmekdir. <tt>kernel_version</tt>'unu sizinkine uygun halde deðiþtirin ve modülü þöyle derleyin:
</p><p>
<div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">$ <b><tt>nasm -f elf -o module.m module.asm</tt></b>
$ <b><tt>ld -r -o module.o module.m</tt></b>
</pre> </td></tr></table></div>
</p><p>
Artýk onunla <b><tt>insmod/rmmod/lsmod</tt></b> (root yetkileri gerekir) kullanarak oynayabilirsiniz; çok eðlenceli, deðil mi?
</p><p></p></dd><dt class="question"><a name="id6"></a><a name="id6"></a><b>2.8.6. </b> <b>
Belleði dinamik olarak nasýl tahsis edebilirim?
</b></dt><dd class="answer"><b></b> <p>
<a class="ulink" href="" target="_top">H-Peter Recktenwald</a>'dan özlü bir cevap:
</p><p>
<div class="programlisting" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="programlisting">ebx := 0        (in fact, any value below .bss seems to do)
sys_brk
eax := current top (of .bss section)

ebx := [ current top &lt; ebx &lt; (esp - 16K) ]
sys_brk
eax := new top of .bss
</pre> </td></tr></table></div>
</p><p>
<a class="ulink" href="mailto:ee97034%C2%A0(at)%C2%A0fe.up.pt">Tiago Gasiba</a>'dan daha geliþmiþ bir cevap:
</p><p>
<div class="programlisting" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="programlisting">section .bss

var1    resb    1

section .text

;
;allocate memory
;

%define LIMIT   0x4000000          ; yaklaþýk 100Megs

        mov     ebx,0              ; data bölümünün en alt kýsmýný elde et
        call    sys_brk

        cmp     eax,-1             ; tamam mý?
        je      erro1

        add     eax,LIMIT          ; +LIMIT bellek kýsmýný tahsis et
        mov     ebx,eax
        call    sys_brk

        cmp     eax,-1             ; tamam mý?
        je      erro1

        cmp     eax,var1+1         ; data bölümü büyüdü mü?
        je      erro1

;
;tahsis edilmiþ alaný kullan
;
                                   ; þimdi eax data bölümünün alt kýsmýný
                                   ; barýndýrýr
        mov     ebx,eax            ; alt kýsmý kaydet
        mov     eax,var1           ; eax=data bölümün baþlangýç kýsmý
repeat:
        mov     word    [eax],1    ; 1'lerle doldur
        inc     eax
        cmp     ebx,eax            ; þu anki pozisyon = en alt?
        jne     repeat

;
;belleði serbest býrak
;

        mov     ebx,var1           ; belleði geri ver
        call    sys_brk            ; baþlangýcýný=var1 yaparak

        cmp     eax,-1             ; tamam mý?
        je      erro2
</pre> </td></tr></table></div>
</p><p></p></dd><dt class="question"><a name="id7"></a><a name="id7"></a><b>2.8.7. </b> <b>
select sistem çaðrýlarýný nasýl kullanacaðýmý anlayamýyorum!
</b></dt><dd class="answer"><b></b> <p>
<a class="ulink" href="mailto:mochel%C2%A0(at)%C2%A0transmeta.com">Patrick Mochel</a>'den bir cevap
</p><p>
<pre class="literallayout">
sys_open'ý çaðýrdýðýnýz zaman, sürecinizle ilgili açýk olan tüm
dosya tanýtýcýlarýnýn olduðu bir tablodan bir indis olarak, bir
dosya tanýtýcý döndürür. stdin, stdout ve stderr için sýrasýyla
0, 1 ve 2'dir, çünkü bunlar süreciniz için her zaman açýk durur.
Ayný zamanda ilk açtýðýnýz dosya tanýtýcýsýnýn 3 olocaðýný ve
artacaðýný unutmayýn.

Ýndislemeyi anlamak select'in ne yaptýðýný anlamanýzý saðlar.
select'i çaðýrdýðýnýz zaman, okumak için, yazmak için, istisnai
durumlarý belirlemek için belli bir dosya tanýtýcýsýný beklediðinizi
belirtiyorsunuzdur. Süreciniz 1024 açýk dosya tanýtýcýsýna sahip olabilir,
dolayýsiyle fd_set sadece bir bit maskesi gibi çalýþarak hangi
dosya tanýtýcýsýnýn hangi iþlem için geçerli olduðunu belirtir.
Bir þeyler ifade etti mi?

Her açtýðýnýz fd birer indis olduðu için, her bir fd_set için on
veya off olmaya ihtiyacý vardýr, sadece 1024 bitlik bir fd_set yapýsýna
ihtiyacýnýz vardýr. Yapýyý belirtmek için 1024 / 32 = 32 long gereklidir.

Þimdi basit bir örnekle açýklayalým.
Farzedelimki dosya tanýtýcýyý okumaya çalýþýyorsunuz (zamanaþýmý olmadan).

- fd_set'e belleði tahsis et

.data

my_fds: times 32 dd 0

- okumak istediðiniz dosya tanýtýcýyý açýn

- fd_set yapýsýndaki bitini ayarlayýn

    Öncelikle, 32 dwords'ün hangisinde bitin olduðunu belirlemelisiniz.

    Daha sonra, bts'yi kullanarak bu dword içindeki biti ayarlayýn,
    bts biti 32'ye bölümden kalana göre ayarlayacaktýr.
    Bu da önce hangi dword ile çalýþmaya baþlamanýzý belirlemenin sebebidir.

    mov edx, 0
    mov ebx, 32
    div ebx

    lea ebx, my_fds
    bts ebx[eax * 4], edx

- son adýmý okumak istediðiniz dosya tanýtýcýlar için yineleyin

- belli bir eylem beklediðiniz diðer iki fd_set'in herbiri için de
  tüm örneði tekrarlayýn

Bundan, geriye denklemin diðer iki parçasý kalýr - n parametresi ve
zaman aþýmý parametresi. Zaman aþýmý parametresini okuyucuya örnek
olarak býrakýyorum (evet, tembelim), fakat kýsaca n parametresiyle
ilgili konuþacaðým.

Bu, seçtiðiniz dosya tanýtýcýlarý içerisindeki en büyük deðere sahip
olanýn deðeri (herhangi bir fd_set'ten) artý birdir. Neden artý bir?
Çünkü, bu deðerden maskeyi belirlemek kolaydýr. Farzedin ki x dosya
göstericisi üzerinde bir veri var, fakat sizin ilgilendiðiniz en yüksek
olan (n-1). fd_set sadece bir bit maskesi olduðundan, çekirdeðin
select'en geri dönmesi veya dönememesi için verimli bir yola ihtiyacý
vardýr. Dolayýsiyle, bu, ilgilendiðiniz bitleri maske dýþýnda býrakýr,
halihazýrda atanmýþ bitlerde herhangi bir deðer var mý diye kontrol eder,
eðer varsa geri döner. Aslýnda, fantastik olduðunu söylemek düþündüðüm kadar
kolay deðil. Çekirdeðin bu maskeyi nasýl belirlediðini görmek için,
çekirdek kaynak aðacýndaki fs/select.c'ye bakýnýz.

Herneyse, bu numarayý bilmeye ihtiyacýnýz vardýr, en kolay yol da açýlmýþ
olan en son dosya tanýtýcýnýn numarasýný bir yerlere kaydetmektir.

Evet, bildiklerim bunlar. Yukarýdaki kodla ilgili uyarý (her zaman ki gibi)
þu: test edilmemiþtir. Sanýrým çalýþýr, eðer çalýþmazsa beni haberdar edin.
Fakat, eðer evrensel bir nükleer felakete sebep olursa, o zaman aramayýn. ;)
</pre>
</p><p></p></dd></dl></div><p>
<i>Þimdilik hepsi bu kadar.</i>.
</p></dd></div></dl><h1></h1><table width="100%" summary="Navigation header" cellpadding="1" cellspacing="0" border="0"><tr><td bgcolor="black" class="navoutline"><table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td bgcolor="white" class="navinline"><table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td width="40%" align="left"><a accesskey="p" href="../howto/assembly-howto-s-res.html">Önceki</a> </td><td width="20%" align="center"><a accesskey="u" href="../howto/assembly-howto.html">Üst Ana Baþlýk</a></td><td width="40%" align="right"> <a accesskey="n" href="../howto/assembly-howto-app.html">Sonraki</a></td></tr><tr><td width="40%" align="left" valign="top">Özkaynaklar </td><td width="20%" align="center"><a accesskey="h" href="../KiTAPLIK/index.html">Baþlangýç</a></td><td width="40%" align="right" valign="top"> Ekler</td></tr><tr><td colspan="3" align="center">
                  Bir <a href="http://www.belgeler.org/">Linux Kitaplýðý</a> Sayfasý
                </td></tr></table></td></tr></table></td></tr></table></body></html>
