<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-9"><meta name="date" content="2009-01-07T20:31:45+02:00"><title>Bilgisayarým süreçlerin birbiri üzerine çýkmasýna nasýl engel olur?</title><link rel="icon" type="image/png" href="../images/belgeler-logo.png"><link rel="stylesheet" href="../belgeler.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V-special(derived from 1.49 for Turkish Linux Documentation WG by Nilgün Belma Bugüner - nilgun@superonline.com)"><link rel="home" href="../KiTAPLIK/index.html" title="Linux Kitaplýðý"><link rel="up" href="../howto/fundementals-howto.html" title="Unix ve Internetin Temelleri NASIL"><link rel="previous" href="../howto/fundementals-howto-timesharing.html" title="Bilgisayarým birkaç iþi tek seferde nasýl yapar?"><link rel="next" href="../howto/fundementals-howto-store-in-memory.html" title="Bilgisayarým birþeyleri bellekte nasýl saklar?"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><table width="100%" summary="Navigation header" cellpadding="1" cellspacing="0" border="0"><tr><td bgcolor="black" class="navoutline"><table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td bgcolor="white" class="navinline"><table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><th colspan="3" align="center">Bilgisayarým süreçlerin birbiri üzerine çýkmasýna nasýl engel olur?</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="../howto/fundementals-howto-timesharing.html">Önceki</a> </td><th width="60%" align="center">Unix ve Internetin Temelleri NASIL</th><td width="20%" align="right"> <a accesskey="n" href="../howto/fundementals-howto-store-in-memory.html">Sonraki</a></td></tr></table></td></tr></table></td></tr></table><dl><div class="sect1"><dt><div> <h2 class="title" style="clear: both"><a name="fundementals-howto-memory-management"></a>Bilgisayarým süreçlerin birbiri üzerine çýkmasýna nasýl engel olur?</h2></div></dt><dd><p>Çekirdek planlayýcýsý, süreçlerin bir zamanda dilimine bölünmesi iþine bakar. iþletim sisteminiz de ayrýca bu süreçleri bir alana bölmek zorundadýr, böylece süreçler birbirlerinin üzerine çýkamazlar; çalýþtýðý bellek. Tüm programlarýn iþbirliði içinde olmaya çalýþtýðýný varsaysanýz bile, içlerinden birinde, diðerlerin iþini bozabilecek bir hatanýn olmasýný istemezsiniz. Ýþletim sisteminizin bu problemi çözmek için yaptýðý iþe bellek yönetimi denir.</p><p>Hayvanat bahçenizdeki her süreç, kodu çalýþtýracaðý ve deðiþkenleri ve sonuçlarý içinde tutacaðý kendi bellek alanýna ihtiyaç duyar. Bu takýmýn salt okunur bir kod parçasýndan (code segment) (süreç komutlarýný içeren) ve yazýlabilir veri parçalasýndan (data segment) (tüm süreçlerin deðiþken belleðini içeren) oluþtuðunu düþünebilirsiniz. Veri parçasý her süreç için gerçekten tektir. Ancak ayný kodu iki süreç çalýþtýrýrsa, Unix verimlilik açýsýndan otomatik olarak bu süreçleri yalnýz bir kod parçasýný paylaþacak þekilde düzenler.</p><dl><div class="sect2"><dt><div> <h3 class="title"><a name="fundementals-howto-memory-management-simple"></a>Sanal bellek: basit sürüm</h3></div></dt><dd><p>Verimlilik önemlidir, çünkü bellek pahalýdýr. Kimi zaman makinenin çalýþtýrdýðý tüm programlarýn bütünlüðünü koruyacak kadar belleðe sahip deðilsinizdir. Özellikle X sunucusu gibi büyük bir programý kullanýyorsanýz. Bundan kaçýnmak için  Unix, sanal bellek denilen bir tekniði kullanýr. Sanal bellek, bellekteki bir süreç için kodun ve verinin tamamýný tutmaya çalýþmaz. Onun yerine, yalnýzca nispeten daha kýsa bir çalýþma takýmýný bulundurur; sürecin geri kalan bütün durumlarý sabit diskinizde takas alaný denilen özel bir yerde býrakýlýr.</p><p>Dikkat edin, bir önceki paragraftaki "kimi zaman", "hemen hemen her zaman" anlamýnda. Genellikle belleðin boyutu, çalýþan programlarýnýn boyutuna baðlý olarak küçüktü. Bu yüzden takaslama yaygýndý. Bugünlerde bellek daha az pahalýdýr ve alt uç makineler bile pek çoðuna sahiptir. 64 MB ve üstü modern tek kullanýclý makineler üzerinde, X'in ve tipik iþ gruplarýnýn çekirdeðe yüklenmesinden sonra takaslama olmaksýzýn çalýþtýrýlmalarý mümkümküdür.</p></dd></div></dl><dl><div class="sect2"><dt><div> <h3 class="title"><a name="fundementals-howto-memory-management-detailed"></a>Sanal bellek: detaylý sürüm</h3></div></dt><dd><p>Aslýnda, son kýsým bazý þeyleri bir miktar basitleþtirmiþtir. Evet, programlar belleðinizin çoðunu fiziksel bellekten daha çok olan, büyük, yassý adres bankasý olarak görür ve takaslama bu yanýlsamayý giderir. Ancak donanýmýnýz aslýnda, içerisinde beþ farklý tür bellekten daha azýný bulundurmaz ve programlarýn maksimum hýz için ayarlanmasý zorunluluðu olduðu zaman aralarýndaki farklýlýklar iyi bir anlaþma konusu olabilir. Gerçekten de makinenizde neler olup bittiðini anlamak için, tüm bunlarýn nasýl çalýþtýklarýný anlamalýsýnýz.</p><p>Beþ bellek türü þunlardýr : iþlemci yazmaçlarý, dahili (veya çip üstü) önbellek, harici (veya çip dýþý) önbellek, ana bellek ve disk. Çok tür olmasýnýn nedeni ise basittir: hýz para demektir. Bellek türlerini eriþim zamanýna göre artan, maliyete göre ise azalan sýrada listeledim. Disk en yavaþ, en ucuz ve saniyede 100 rastgele eriþim yapabiliyor iken, yazmaç belleði en hýzlý, en pahalý ve saniyede milyarlarca kez rastgele eriþilebilir bir bellektir.</p><p>Burada, tipik bir masaüstü makinesi için ilk 2000 hýzý yansýtan bir listenin tamamý vardýr. Hýz ve kapasite artýp, fiyatlar düþüyor iken, bu oranlarýn adil bir þekilde sabit olarak kalacaðýný ve o oranlarýn bellek hiyerarþisini biçimlendirdiðini düþünebilirsiniz.</p><p>Disk
				
				Size: 13000MB Accesses: 100KB/sec</p><p>Ana Bellek
				
				Size: 256MB Accesses: 100M/sec</p><p>Harici Önbellek
				
				Size: 512KB Accesses: 250M/sec</p><p>Dahili Cache
				
				Size: 32KB Accesses: 500M/sec</p><p>Ýþlemci
				
				Size: 28 bytes Accesses: 1000M/sec</p><p>Herþey, en hýzlý tür bellekler üzerine inþa edilemez. Bu yol çok maliyetli olabilir ve eðer öyle olmasa bile, hýzlý bellek geçicidir. Güç kesildiði zaman üzerindeki verileri kaybedecektir. Böylece, bilgisayarlarýn sabit diske veya güç kesildiði zaman verileri tutabilen geçici olmayan türdeki depolama cihazlarýna sahip olmasý þarttýr. Ýþlemciler ile disklerin hýzlarý arasýnda devasa bir uyumsuzluk vardýr. Bellek hiyerarþisinin üç orta seviyesi (dahili önbellek, harici önbellek ve ana bellek), temelde bu uçurumda bir köprü görevi görmek için vardýr.</p><p>Linux ve diðer Unixler sanal bellek denilen bir özelliðe sahiptir. Bu demek oluyor ki iþletim sistemi sahip olduðundan daha fazla ana bellek varmýþ gibi davranýr. Gerçek fiziksel ana belleðiniz, gerçekte herhangi bir zaman diliminde takas alaný denilen diskteki özel bir bölümde, çok daha büyük bir sanal bellek alaný üzerindeki pencere ya da önbellek takýmý gibi davranýr. Kullanýcý programlarýnýn görüþlerinin dýþýnda, iþletim sistemi bu ilüzyonu sürdürebilmek için bellek ve disk arasýnda veri bloklarýný ("pages") taþýr. Sonuç olarak, sanal belleðiniz gerçek bellekten çok daha büyüktür, ancak çok fazla yavaþ deðildir.</p><p>Sanal belleðinizin fiziksel bellekten ne kadar yavaþ olduðu, iþletim sisteminin takaslama algoritmalarýnýn, programlarýnýzýn sanal belleði kullanan yolu ile ne kadar uyumlu olduðuna baðlýdýr. Neyse ki birbirine yakýn zamanlarda olan bellek okuma ve yazmalarý kümelenme eðilimindedirler. Bu eðilim yerellik (locality) veya daha resmi þekliyle referans yerelliði (locality of reference) olarak adlandýrýlýr ve bu iyi birþeydir. Eðer bellek kaynaklarý rastgele sanal uzaydan geçerse; bir disk kadar yavaþ olabilecek her yeni kaynak ve sanal bellek için diskten okuma veya yazma yapmalýsýnýz. Ancak programlarýn aslýnda saðlam bir yerellik sergilemesinden dolayý, iþletim sisteminiz referans baþýna nispeten az takasmalama yapabilmektedir.</p><p>Tecrübelere dayanýlarak, bellek kullaným modellerinin geniþ bir sýnýfý için en etkili metodun oldukça basit olduðu saptanmýþtýr. Bu metot, LRU veya "least recently used - en yakýn zamanda en az kullanýlan" algotimasý olarak adlandýrýlýr. Sanal bellek sistemi ihtiyaç duyduðu için, disk bloklarýný kendi "çalýþma kümelerine (working set)" geçirir. Çalýþma kümesi için fiziksel belleði tükettiðinde, en yakýn zamanda kullanýlmýþ bloðu atar. Tüm Unixler ve diðer pekçok sanal bellek iþletim sistemi, LRU'da küçük varyasyonlar kullanýr.</p><p>Sanal bellek disk ve iþlemci hýzlarý arasýndaki köprünün ilk baðlantýsýdýr. Açýkça iþletim sistemi tarafýndan yönetilir. Ancak fiziksel ana belleðin hýzý ve bir iþlemcinin yazmaç belleklerine eriþebileceði hýzlarý arasýnda hala önemli bir uçurum vardýr. Harici ve dahili önbellek, bu duruma bahsettiðim gibi sanal belleðe benzer bir teknik kullanarak adresler.</p><p>Nitekim fiziksel ana belleðin, disk takas alaný üzerindeki pencere veya önbellek kümesi olarak davrandýðý gibi, harici önbellek de ana bellekte pencereler gibi hareket eder. Harici önbellek daha hýzlý (100 M'den ziyade, saniyede 250M eriþim) ve daha küçüktür. Donaným (özellikle, bilgisayarýnýzýn bellek denetleyicisi) LRU iþini, harici önbellekteki ana bellekten getirilmiþ veri bloklarý üzerinde yapar. Tarihsel nedenlerden dolayý önbellek takaslama ünitesi bir sayfadan ziyade, hat olarak adlandýrýlýr.</p><p>Ancak henuz bitirmedik. Dahili önbellek, harici önbellek kýsýmlarýný önbellekleyerek, etkin hýzdaki en son noktayý bize verir. Þimdi daha hýzlý ve küçüktür - aslýnda iþlemci çipinin hemen altýnda yer alýr.</p><p>Eðer gerçekten programlarýnýzý hýzlandýrmak istiyorsanýz, bu detaylarý bilmek faydalý olacaktýr. Saðlam bir yerellik olduðu zaman programlarýnýz daha hýzlý çalýþýr, çünkü bu iþ önbellekleme iþini daha iyi yapar. Bu nedenle programlarý hýzlý bir hale getirmenin en kolay yolu onlarý küçültmektir. Eðer bir program birçok giriþ/çýkýþ veya að olaylarýndaki beklemeler tarafýndan yavaþlatýlmamýþsa, genellikle uygun olacaðý en küçük önbellek hýzýnda çalýþacaktýr.</p><p>Eðer programýnýzý bir bütün olarak küçültemiyorsanýz, kritik hýzdaki parçalarý ayarlamak biraz çaba gerektirecektir. Böylelikle faydalý olabilecek daha saðlam bir yerelliðe sahip olacaklardýr. Bu tarzdaki ayarlama tekniklerinin detaylarý, bu bilgilendirici rehberin de ötesinde bir alandadýr. Bunlara ihtiyaç duyacaðýnýz zamana kadar, pekçoðunu kendi kendinize çözebilecek kadar, epey bir derleyiciyle içli dýþlý olacaksýnýz.</p></dd></div></dl><dl><div class="sect2"><dt><div> <h3 class="title"><a name="fundementals-howto-memory-management-mmu"></a>Bellek Yönetim Ünitesi</h3></div></dt><dd><p>Takaslamadan sakýnacak kadar fiziksel çekirdeðiniz olduðu zaman bile, bellek yöneticisi adýnda iþletim sisteminizin bir parçasýnýn hala yapacaðý önemli bir iþi vardýr. Bellek yöneticisi, programlarýn yalnýzca kendi veri parçalarýný deðiþtirebileceklerinden emin olmalýdýr. Yani, bir program içindeki hatalý veya kötü niyetli kodlarýn bir baþka programýn verisini ayýklamasýný engeller. Bunu yapmak için, veri ve kod parçasýnýn bir tablosunu tutar. Bir süreç ya da daha fazla bellek isteðinde bulunduðunda ya da belleði serbest býraktýðýnda (ikincisi genellikle sürecin çýkýþýnda olur) tablo güncellenir.</p><p>Bu tablo, komutlarýn donanýmýn temelinde bulunan, MMU veya bellek yönetim ünitesi diye adlandýrýlan özelleþtirilmiþ parçasýna geçirilmesinde kullanýlýr. Modern iþlemci çipleri, hemen altýnda inþa edilmiþ MMU'lara sahiptir. MMU'nun bellek alanlarý etrafýna set çekmek gibi bir yeteneði vardýr. Böylelikle dýþarýdaki bir baþvuru reddedilecek ve özel bir kesme sinyalinin çýkarýlmasýna neden olacaktýr.</p><p>Eðer hiç "Parçalama Hatasý(Segmentation Fault)", "Çekirdek Boþaltýldý(Core Dumped)" veya benzer bir Unix mesajý gördüyseniz, tam olarak olan þudur; kendi parçasý dýþýndaki belleðe(çekirdeðe) eriþmeye çalýþan bir program tarafýndan bulunulan bir giriþim, ölümcül bir kesme çýkarýr. Bu, program kodunda bir hata olduðunu gösterir; çekirdeðin boþalmasýnýn arkasýnda, programcýya iz sürmede yardýmcý olacak þekilde planlanmýþ tanýsal bilgi yatar.</p><p>Bir diðer yaklaþým; süreçlerin, eriþtikleri belleði ayýrmasýnýn yanýnda, birbirlerinden korumasýdýr. Onlarýn eriþtikleri dosyalarý kontrol edebiliyor olmak da istersiniz. Böylece hatalý ya da kötü niyetli bir program, sistemin önemli parçalarýný bozamaz. Bu nedenle Unix'te, daha sonra bahsedeceðimiz dosya izinleri vardýr.</p></dd></div></dl></dd></div></dl><h1></h1><table width="100%" summary="Navigation header" cellpadding="1" cellspacing="0" border="0"><tr><td bgcolor="black" class="navoutline"><table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td bgcolor="white" class="navinline"><table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td width="40%" align="left"><a accesskey="p" href="../howto/fundementals-howto-timesharing.html">Önceki</a> </td><td width="20%" align="center"><a accesskey="u" href="../howto/fundementals-howto.html">Üst Ana Baþlýk</a></td><td width="40%" align="right"> <a accesskey="n" href="../howto/fundementals-howto-store-in-memory.html">Sonraki</a></td></tr><tr><td width="40%" align="left" valign="top">Bilgisayarým birkaç iþi tek seferde nasýl yapar? </td><td width="20%" align="center"><a accesskey="h" href="../KiTAPLIK/index.html">Baþlangýç</a></td><td width="40%" align="right" valign="top"> Bilgisayarým birþeyleri bellekte nasýl saklar?</td></tr><tr><td colspan="3" align="center">
                  Bir <a href="http://www.belgeler.org/">Linux Kitaplýðý</a> Sayfasý
                </td></tr></table></td></tr></table></td></tr></table></body></html>
