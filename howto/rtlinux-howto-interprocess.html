<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-9"><meta name="date" content="2006-04-25T01:55:49+03:00"><title>Süreçlerarasý Ýletiþim</title><link rel="icon" type="image/png" href="../images/belgeler-logo.png"><link rel="stylesheet" href="../belgeler.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V-special(derived from 1.49 for Turkish Linux Documentation WG by Nilgün Belma Bugüner - nilgun@superonline.com)"><link rel="home" href="../KiTAPLIK/index.html" title="Linux Kitaplýðý"><link rel="up" href="../howto/rtlinux-howto.html" title="RTLinux NASIL"><link rel="previous" href="../howto/rtlinux-howto-compile.html" title="Derleme ve Çalýþtýrma"><link rel="next" href="../howto/rtlinux-howto-whatisnext.html" title="Sonrasý"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><table width="100%" summary="Navigation header" cellpadding="1" cellspacing="0" border="0"><tr><td bgcolor="black" class="navoutline"><table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td bgcolor="white" class="navinline"><table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><th colspan="3" align="center">Süreçlerarasý Ýletiþim</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="../howto/rtlinux-howto-compile.html">Önceki</a> </td><th width="60%" align="center">RTLinux NASIL</th><td width="20%" align="right"> <a accesskey="n" href="../howto/rtlinux-howto-whatisnext.html">Sonraki</a></td></tr></table></td></tr></table></td></tr></table><dl><div class="sect1"><dt><div> <h2 class="title" style="clear: both"><a name="rtlinux-howto-interprocess"></a>Süreçlerarasý Ýletiþim</h2></div></dt><dd><p>
Önceki bölümlerde gördüðümüz örnek program bir gerçek zamanlý süreç olarak bilinen süreçtir. Bir uygulama programýnýn her bir parçasý gerçek zamanlý olmak zorunda deðildir. Programýn sadece hassas zaman kýsýtlamalarý gerektiren bölümleri bir gerçek zamanlý süreç gibi yazýlmalýdýr. Diðer bölümleri kullanýcý seviyesinde yazýlýp çalýþtýrýlabilir. Kullanýcý seviyesinde çalýþan süreçleri yazmak, çalýþtýrmak ve hatalarýný ayýklamak gerçek zamanlý evrelerden çoðunlukla daha kolaydýr. Fakat tam bu noktada, kullanýcý seviyesindeki Linux süreçleri ile gerçek zamanlý evreler arasýnda iletiþimi saðlayacak bir yöntem ihtiyacý ortaya çýkar.
</p><p>
Süreçlerarasý iletiþimin çeþitli yollarý vardýr. Biz en önemli ve en ortak iletiþim yolundan, gerçek zamanlý FIFO'dan bahsedeceðiz.
</p><dl><div class="sect2"><dt><div> <h3 class="title"><a name="rtlinux-howto-realtimefifo"></a>Gerçek Zamanlý FIFO</h3></div></dt><dd><p>
Gerçek zamanlý FIFOlar tek yönlü kuyruklardýr (First In First Out - ilk giren ilk çýkar). Yani bir süreç FIFOnun bir ucunda veri yazarken diðer süreçler FIFOnun diðer ucundan bilgileri okuyabilir. Genellikle bu süreçlerin bir tanesi gerçek zamanlý evre, diðeri kullanýcý seviyesindeki süreçtir.
</p><p>
Gerçek zamanlý FIFOlar aslýnda, ana numarasý 150 olan karakter aygýtlarýdýr (/dev/rtf*). Gerçek zamanlý evreler kullanacaklarý FIFO'larý belirtmek için bir tamsayý kullanýr (örneðin,  <tt>/dev/rtf2</tt> için 2). FIFOlarýn numaralarý için bir sýnýr vardýr. FIFOlarla çalýþmak için  <tt>rtf_create(), rtf_destroy(), rtf_get(), rtf_put()</tt> vb iþlevler vardýr.
</p><p>
Diðer taraftan, Linux kullanýcý süreci gerçek zamanlý FIFOlarý normal karakter aygýtlarý gibi görür. Bu yüzden <tt>open(), close(), read()</tt> ve <tt>write()</tt> gibi iþlevler bu aygýtlarda kullanýlabilir.
</p></dd></div></dl><dl><div class="sect2"><dt><div> <h3 class="title"><a name="rtlinux-howto-fifoprog"></a>FIFO Kullanan Bir Uygulama</h3></div></dt><dd><p>
Ýlk olarak, PC hoparlöründen müzik çalan (sadece iki notalý) basit bir C programýný (dosya adý pcaudio.c olan) göz önüne alalým. Þimdi, nota çalmak için sadece <tt>/dev/rtf3</tt> karakter aygýtýna yazmamýz gerektiðini varsayalým. (Sonra, bir gerçek zamanlý sürecin FIFOdan (<tt>/dev/rtf3</tt>) okumasýný ve PC hoparlörüne göndermesini göreceðiz)
</p><p>
<div class="programlisting" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="programlisting">#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

#define DELAY 30000

void make_tone1(int fd)
{
        static char buf = 0;
        write (fd, &amp;buf, 1);
}

void make_tone2(int fd)
{
        static char buf = 0xff;
        write (fd, &amp;buf, 1);
}

main()
{
        int i, fd = open ("/dev/rtf3", O_WRONLY);
        while (1)
        {
                for (i=0;i&lt;DELAY;i++);
                make_tone1(fd);
                for (i=0;i&lt;DELAY;i++);
                make_tone2(fd);
        }
}</pre> </td></tr></table></div>
</p><p>
Þimdi, yukarda görünen program (<tt>pcaudio.c</tt>) derlenir ve çalýþtýrýlýrsa, bir kare dalgaya uygun düzenli pýtýrtýlar oluþturmalý. Fakat bundan önce '<tt>/dev/rtf3</tt>'ten okumak için bir modüle ve uygun veriyi PC hoparlörüne göndermeye ihtiyacýmýz var. Bu gerçek zamanlý programý rtlinux kaynak aðacýnda (<tt>/usr/src/rtlinux/examples/sound/</tt>) bulabilirsiniz. sound.o modülünü '<b><tt>insmod</tt></b>' komutunu kullanarak çekirdeðe ekleyin.
</p><p>
Aygýttan okumak için modülü ekledikten sonra, programýmýzý artýk çalýþtýrabiliriz ('gcc' kullanarak derleyin) ve sonra oluþan 'a.out'u çalýþtýrýn. Bu þekilde süreç, sistemde baþka süreç olmadýðý  zaman (zamanýn tükenmesi) biraz daha düzenli tonlar üretir. Fakat diðer konsolda X sunucusu  baþlatýldýðý zaman tonda sessizlik daha uzun süreli olmaya baþlar. Sonunda bir 'find' komutu çalýþtýrýldýðý zaman (<tt>/usr</tt> dizininde bir dosya için) örnek ses tamamen bozulur. Bunun ardýndaki sebep, veriyi gerçek zamanlý olmayan FIFO üstünde yazmamýzdýr.
</p><p>
Seste herhangi bir karýþýklýk meydana gelmesin diye biz þimdi bu süreç gerçek zamanlý nasýl çalýþýr, onu göreceðiz. Önce yukarýdaki programý bir gerçek zamanlý programa dönüþtürelim. (Dosya adý <tt>rtaudio.c</tt>)
</p><p>
<div class="programlisting" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="programlisting">
#include &lt;rtl.h&gt;
#include &lt;pthread.h&gt;
#include &lt;rtl_fifo.h&gt;
#include &lt;time.h&gt;

#define FIFO_NO 3
#define DELAY 30000
pthread_t thread;

void * sound_thread(int fd)
{
        int i;
        static char buf = 0;
        while (1)
        {
                for(i=0; i&lt;DELAY; i++);
                buf = 0xff;
                rtf_put(FIFO_NO, &amp;buf, 1);

                for(i=0;i&lt;DELAY;i++);
                buf = 0x0;
                rtf_put(FIFO_NO, &amp;buf, 1);
        }
        return 0;
}

int init_module(void)
{
        return pthread_create(&amp;thread, NULL, sound_thread, NULL);
}

void cleanup_module(void)
{
        pthread_delete_np(thread);
}
</pre> </td></tr></table></div>
</p><p>
Eðer hala yapmadýysanýz <b><tt>sound.o</tt></b> modülünü çekirdeðe ekleyin. Yukarýdaki programý bir Makefile yazarak (daha önce söylediðimiz gibi) derleyin, böylece <b><tt>rtaudio.o</tt></b> modülü üretilir. Bu modülü eklemeden önce birkaç þey daha lazým. Yukarýdaki programýn sonsuz döngü içinde çalýþtýðýna dikkat edelim. Evreyi uyutmak ya da sonlandýrmak için kodumuz olmadýðý için evre çalýþmasýný durdurmayacaktýr. Bu yolla sizin PC hoparlörünüz bu tonu üretmeye devam edecek ve siz baþka bir þeyler yapmak için bilgisayarýnýzý yeniden baþlatmak zorunda kalacaksýnýz.
</p><p>
Bu yüzden evrenin kendi kendine tonlar arasýnda gecikme yapmayý soran küçük bir kod deðiþikliði (sadece <tt>sound_thread()</tt> iþlevinde) yapalým.
</p><p>
<div class="programlisting" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="programlisting">
void * sound_thread(int fd)
{
        static char buf = 0;
        pthread_make_periodic_np (pthread_self(), gethrtime(), 500000000);

        while (1)
        {
                pthread_wait_np();
                buf = (int)buf^0xff;
                rtf_put(FIFO_NO, &amp;buf, 1);
        }
        return 0;

}
</pre> </td></tr></table></div>
</p><p>
Artýk 'rmmod' komutu ile modülü yalnýzca kaldýrarak süreci sonlandýrabiliriz.
</p><p>
Burada süreçlerarasý iletiþim için gerçek zamanlý FIFOlarýn nasýl kullanýlacaðýný gördük. Ayrýca RTLinux'a olan gerçek ihtiyaç yukarýdaki örnekten anlaþýlabilir.
</p></dd></div></dl></dd></div></dl><h1></h1><table width="100%" summary="Navigation header" cellpadding="1" cellspacing="0" border="0"><tr><td bgcolor="black" class="navoutline"><table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td bgcolor="white" class="navinline"><table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td width="40%" align="left"><a accesskey="p" href="../howto/rtlinux-howto-compile.html">Önceki</a> </td><td width="20%" align="center"><a accesskey="u" href="../howto/rtlinux-howto.html">Üst Ana Baþlýk</a></td><td width="40%" align="right"> <a accesskey="n" href="../howto/rtlinux-howto-whatisnext.html">Sonraki</a></td></tr><tr><td width="40%" align="left" valign="top">Derleme ve Çalýþtýrma </td><td width="20%" align="center"><a accesskey="h" href="../KiTAPLIK/index.html">Baþlangýç</a></td><td width="40%" align="right" valign="top"> Sonrasý</td></tr><tr><td colspan="3" align="center">
                  Bir <a href="http://www.belgeler.org/">Linux Kitaplýðý</a> Sayfasý
                </td></tr></table></td></tr></table></td></tr></table></body></html>
