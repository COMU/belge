<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-9"><meta name="date" content="2006-04-25T01:56:01+03:00"><title>Nesne Yönelimli Düþünme</title><link rel="icon" type="image/png" href="../images/belgeler-logo.png"><link rel="stylesheet" href="../belgeler.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V-special(derived from 1.49 for Turkish Linux Documentation WG by Nilgün Belma Bugüner - nilgun@superonline.com)"><link rel="home" href="../KiTAPLIK/index.html" title="Linux Kitaplýðý"><link rel="up" href="../howto/ruby-ug.html" title="Ruby Kullanýcý Kýlavuzu"><link rel="previous" href="../howto/ruby-ug-iterators.html" title="Yineleyiciler"><link rel="next" href="../howto/ruby-ug-methots.html" title="Yöntemler"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><table width="100%" summary="Navigation header" cellpadding="1" cellspacing="0" border="0"><tr><td bgcolor="black" class="navoutline"><table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td bgcolor="white" class="navinline"><table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><th colspan="3" align="center">Nesne Yönelimli Düþünme</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="../howto/ruby-ug-iterators.html">Önceki</a> </td><th width="60%" align="center">Ruby Kullanýcý Kýlavuzu</th><td width="20%" align="right"> <a accesskey="n" href="../howto/ruby-ug-methots.html">Sonraki</a></td></tr></table></td></tr></table></td></tr></table><dl><div class="sect1"><dt><div> <h2 class="title" style="clear: both"><a name="ruby-ug-oothinking"></a>Nesne Yönelimli Düþünme</h2></div></dt><dd><p>
Nesne yönelimlilik kavramý çekici bir kavramdýr. Herþeyi nesneye yönelik olarak çaðýrmak kulaðýnýza hoþ gelebilir. Ruby nesne yönelimli bir betik dili olarak adlandýrýlýr, ancak gerçekte bu "nesne yönelimlilik" kavramý nedir?
  </p><p>
Bu soruya aþaðý yukarý hepsi ayný kapýya çýkan bir sürü cevap bulunabilir. Çabukça toparlamak yerine, isterseniz öncelikle geleneksel yazýlým paradigmasý üzerinde duralým.
  </p><p>
Geleneksel olarak, bir yazýlým geliþtirme sorunu bazý verilerin gösterimleri ile bu veriler üzerinde çalýþan yordamlar olarak karþýmýza çýkar. Bu model altýnda, veri hareketsiz, edilgen ve beceriksizdir; tamamen etkin, mantýksal ve güçlü bir yordamýn merhametine kalmýþtýr.
  </p><p>
Bu yaklaþýmdaki sorun, yazýlýmlarý geliþtiren yazýlýmcýlarýn sadece insan olmasý ve dolayýsýyla bir çok ayrýntýyý sadece bir sefer kafalarýnda net olarak tutabilmeleridir. Proje geniþledikçe, yordamsal öz daha karmaþýk ve hatýrlamasý zor bir noktaya gelir.
  </p><p>
Küçük düþünce kusurlarý ve yazým yanlýþlarýyla sonuçta elinizde iyi-gizlenmiþ yazýlým hatalarý kalýr.
  </p><p>
Zamanla yordam çekirdeðinde istenmeyen etkileþimler doðabilir; bu iþ dokunaçlarýnýn yüzünüze deðmesine izin vermeden sinirli bir mürekkep balýðý taþýmaya benzer.
  </p><p>
Bu geleneksel paradigmalarla yazýlým geliþtirirken hatalarý azaltmak ve sýnýrlamak için kýlavuzlar bulunmaktadýr, ancak yöntemi kökten deðiþtirmek daha iyi bir çözüm olacaktýr.
  </p><p>
Peki nesneye yönelik yazýlým geliþtirme, mantýksal iþin sýradan ve tekrarlayan yönünü verinin kendisine emanet etmemizi mümkün kýlmak ve veriyi edilgen durumdan etkin duruma sokmamýz için ne yapar? Baþka bir açýdan,
  </p><p><div class="itemizedlist"><ul type="disc"><li>
Her veri parçasýna, eriþip içindekileri etrafa fýrlatmamýza izin veren
kapaðý açýk bir kutu gibi davranmayý býraktýk.
    </li><li>
Her veri parçasýna kapaðý kapalý ve iyi iþaretlenmiþ düðmeleri bulunan çalýþan bir makine gibi davranmaya baþladýk.
    </li></ul></div>
  </p><p>
"Makine" olarak tanýmladýðýmýz þey çok basit ya da çok karmaþýk olabilir ancak bunu dýþarýdan bakarak söyleyemeyiz ve makineyi açmayý (tasarýmýyla ilgili bir sorun olduðunu düþünmedikçe) istemeyiz. Bu yüzden veriyle etkileþimde bulunmak için düðme çeviriyor gibi iþlem yapmamýz gerekir. Makine bir kere kurulduðu zaman  nasýl çalýþtýðý hakkýnda düþünmememize gerek yoktur.
  </p><p>
Kendimize iþ çýkardýðýmýzý düþünebilirsiniz ancak bu yaklaþýmla bazý þeylerin yanlýþ gitmesini önleyebiliriz.
  </p><p>
Þimdi açýklayýcý olmasý açýsýndan basit ve küçük bir örnek görelim: Arabanýzýn bir yolmetresi olsun. Görevi yeniden baþlatma düðmesine son basýldýðýndan itibaren ne kadar yol katedildiði ölçmektir. Bu durumu bir yazýlým geliþtirme dilinde nasýl tasarlayabiliriz? C'de yolmetre sadece sayýsal bir deðiþken olmalýdýr, muthemelen bir <b><tt>float</tt></b>. Yazýlým bu deðiþkenin deðerini küçük aralýklarla arttýracak, uygun gördüðü zamansa sýfýr yapýp yeniden baþlatacaktýr. Burada yanlýþ olan nedir?  Yazýlýmdaki bir hata bu deðiþkene uydurma bir deðer atayabilir ve beklenmedik sonuçlar ortaya çýkabilir.   C'de yazýlým geliþtirmiþ herhangi biri böylesine küçük ve basit bir hatayý bulmak için saatler ya da günler harcamanýn ne demek olduðunu bilir (hatanýn bulunma sinyali genelde alýnda þaklayan bir tokattýr).
  </p><p>
Ayný problem nesneye yönelik baðlamda da karþýmýza çýkabilirdi. Yolmetreyi tasarlayan bir yazýlýmcýnýn soracaðý ilk þeylerden biri tabii ki "hangi veri yapýsý bu durum için daha uygundur?" olmayacaktýr. Ama "Bunun tam olarak nasýl çalýþmasý gerekiyor?" þeklinde bir soru daha uygun olacaktýr. Aradaki fark daha malumatlý olmaktýr. Bir kilometre sayacýnýn gerçekte ne iþe yaradýðýna ve dýþ dünyanýn onunla nasýl etkileþimde bulunmayý beklediðine karar vermek için biraz zaman ayýrmamýz gereklidir. Þimdi arttýrabileceðimiz, yeniden baþlatabileceðimiz ve deðerini okuyabileceðimiz ve baþka bir þey yapmayan küçük bir makine yapmaya karar verdik.
  </p><p>
Yolmetremize keyfi bir deðer atamak için bir yol tanýmlamadýk; neden? Çünkü yolmetrelerin bu þekilde çalýþmadýðýný biliyoruz. Yolmetreyle yapabileceðiniz pek az þey var, ki bunlarýn hepsini yapmaya izin verdik. Bu þekilde eðer yazýlýmda herhangi birþey yolmetrenin deðerinin yerine geçmeye çalýþýrsa (örneðin arabanýn klimasýnýn derecesi) iþlerin yanlýþ gittiðine dair uyarý alýrsýnýz. Koþan yazýlýmýn (dilin doðasýna göre muhtemelen derleme sýrasýnda) yolmetre nesnelerine keyfi deðerler atamaya izni olmadýðýný söyledik. Mesaj tam olarak bu olmayabilir ama buna yakýn birþeydir. Ancak hatayý engellemiyor, deðil mi? Ancak hatanýn yerini kolayca gösterir. Bu nesneye yönelik yazýlým geliþtirmenin zamanýmýzý boþa harcamaktan kurtaran birkaç yolundan biridir.
  </p><p>
Yukarýda soyutlamanýn yalnýzca bir adýmýný yaptýk, artýk makinelerden oluþan bir fabrika yapmak kolaylaþtý. Tek bir yolmetreyi doðrudan oluþturmak yerine, basit bir kalýptan istediðimiz sayýda yolmetre yapmayý tercih etmeliyiz. Kalýp (ya da isterseniz yolmetre fabrikasý) "sýnýf" olarak adlandýrdýðýmýz kavrama, oluþturduðumuz yolmetre de "nesne" olarak tanýmladýðýmýz kavrama karþýlýk gelmektedir. Bir çok nesneye yönelik yazýlým geliþtirme dili, herhangi bir nesne oluþturmdan önce bir sýnýfýn tanýmlý olmasýný gerekli kýlar, ancak Ruby'de böyle bir durum sözkonusu deðildir.
  </p><p>
Bu kullanýmýn nesneye yönelik tasarýmý kuvvetlendirmediðini de not düþelim. Elbette her dilde, anlaþýlamayan, hatalý, yarým yamalak kod yazmak mümkündür. Ruby'nin sizin için yaptýðý þey (özellikle C++'nýn aksine) nesneye yönelik yazýlým geliþtirme kavramýný sindirmenizi saðlayarak, daha küçük bir ölçekte çalýþýrken çirkin bir kod yazmamak için çaba sarfetmenizi önler. Ýleriki bölümlerde Ruby'nin takdire þayan diðer özelliklerini açýklayacaðýz. Hala bizimle misiniz?
 </p></dd></div></dl><h1></h1><table width="100%" summary="Navigation header" cellpadding="1" cellspacing="0" border="0"><tr><td bgcolor="black" class="navoutline"><table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td bgcolor="white" class="navinline"><table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td width="40%" align="left"><a accesskey="p" href="../howto/ruby-ug-iterators.html">Önceki</a> </td><td width="20%" align="center"><a accesskey="u" href="../howto/ruby-ug.html">Üst Ana Baþlýk</a></td><td width="40%" align="right"> <a accesskey="n" href="../howto/ruby-ug-methots.html">Sonraki</a></td></tr><tr><td width="40%" align="left" valign="top">Yineleyiciler </td><td width="20%" align="center"><a accesskey="h" href="../KiTAPLIK/index.html">Baþlangýç</a></td><td width="40%" align="right" valign="top"> Yöntemler</td></tr><tr><td colspan="3" align="center">
                  Bir <a href="http://www.belgeler.org/">Linux Kitaplýðý</a> Sayfasý
                </td></tr></table></td></tr></table></td></tr></table></body></html>
