<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-9"><meta name="date" content="2008-10-27T09:55:01+02:00"><title>Yazýlým Geliþtirme (Uygulama Geliþtirme Arayazü ile)</title><link rel="icon" type="image/png" href="../images/belgeler-logo.png"><link rel="stylesheet" href="../belgeler.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V-special(derived from 1.49 for Turkish Linux Documentation WG by Nilgün Belma Bugüner - nilgun@superonline.com)"><link rel="home" href="../KiTAPLIK/index.html" title="Linux Kitaplýðý"><link rel="up" href="../howto/ipv6-howto.html" title="Linux IPv6 NASIL"><link rel="previous" href="../howto/ipv6-howto-hints-daemons-others.html" title="Diðer artalan süreçleri"><link rel="next" href="../howto/ipv6-howto-interoperability.html" title="Birlikte çalýþabilirlik"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><table width="100%" summary="Navigation header" cellpadding="1" cellspacing="0" border="0"><tr><td bgcolor="black" class="navoutline"><table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td bgcolor="white" class="navinline"><table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><th colspan="3" align="center">Yazýlým Geliþtirme (Uygulama Geliþtirme Arayazü ile)</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="../howto/ipv6-howto-hints-daemons-others.html">Önceki</a> </td><th width="60%" align="center">Linux IPv6 NASIL</th><td width="20%" align="right"> <a accesskey="n" href="../howto/ipv6-howto-interoperability.html">Sonraki</a></td></tr></table></td></tr></table></td></tr></table><dl><div class="sect1"><dt><div> <h2 class="title" style="clear: both"><a name="ipv6-howto-programming-using-api"></a>Yazýlým Geliþtirme (Uygulama Geliþtirme Arayazü ile)</h2></div></dt><dd><dl><div class="sect2"><dt><div> <h3 class="title"><a name="id1"></a>C uygulama geliþtirme arayüzünü(API) kullanarak uygulama geliþtirme</h3></div></dt><dd><p>Ýlgili RFC'ler </p><p><div class="itemizedlist"><ul type="disc"><li><a href="http://www.faqs.org/rfcs/rfc3493.html" target="_top">RFC 3493 /IPv6 için temel yuva(socket) arayüz eklentileri</a></li><li><a href="http://www.faqs.org/rfcs/rfc3542.html" target="_top">RFC 3542 / IPv6 için ileri yuva uygulama geliþtirme arayüzü</a></li></ul></div>
    </p><p>Aþaðýdaki bölüm John Wenker<a href="http://www.pt.com" target="_top">http://www.pt.com</a> tarafýndan hazýrlanmýþtýr.
    </p><p> 
Bu bölümde Linux iþletim sisteminde nasýl IPv6 sunucu-istemci uygulamasý geliþtirileceði açýklanmaktadýr.Bu bölümde anlatýlanlar Jun-ichiro itojun Hagino tarafýndan yazýlan "IPv6 Network Programming" kitabýnýn 2, 3 ve 4. bölümlerinden derlenerek hazýrlanmýþtýr. Daha ayrýntýlý bilgi için bu kitabý okuyabilirsiniz. Bu kitap IPv4 uygulamalarýnýn iletiþim kurallarýndan (protocol) baðýmsýz bir þekilde nasýl IPv6 uyumlu hale getirileceðini ve bu çevrimde sýk karþýlaþýlan sorunlar ve çözümlerini içermektedir. Bu yazýnýn hazýrlanmasý sýrasýnda, nasýl IPv6 uygulamalarý geliþtirileceðini anlatan tek kitap budur[ayný zamanda bu yazý hazýrlanýrken uygulamalarýn nasýl IPv6'ya uyarlanacaðý ayný yazarýn yazýsýnda bulunabilir: <a href="http://jungla.dit.upm.es/~ecastro/IPv6-web/ipv6.html" target="_top">http://jungla.dit.upm.es/~ecastro/IPv6-web/ipv6.html</a>]. Fakat 360 sayfalýk bu kitabýn yaklaþýk 60 bölümü kullanýþlý. Bununla birlikte bu kitabýn yol göstermesiyle bu yazý yazýldý ve yazarýn iþlerini yapmasýnda yardýmcý oldu. Hagino kitabýndaki bilgilerin çoðu (fakat hepsi deðil) Linux "man" sayfalarýnda mevcuttur, uygulama geliþtiriciler "man" sayfalarýnda arayarak kaybedecekleri büyük zamaný bu kitabýn ilgili bölümlerini okuyarak kazanabilirler. 
    </p><p>
Hagino kitabýndan baþka bu NASIL belgesinde verilen bilgiler de hatalý veya eksik olabilir. Bazý kýsýmlar ve açýklamalar IPv6 için tamamen doðru niteliði taþýmamaktadýr, fakat kullanýþlý uygulamalarda çalýþtýðý gözlenmektedir.
    </p><p>
Bu kýsýmda okuyucunun TCP/IP soket uygulama geliþtirme arayüzüyle (API) tecrübesinin olduðu varsayýlmaktadýr. Daha fazla bilgi için Comer &amp; Stevens' ýn "Internetworking with TCP/IP"(ISBN 0-13-032071-4) serisi dökümanlarý incelenebilir, özellikle 3. cilt: istemci-sunucu uygulamalarý, Linux/POSIX soket sürümleri. Bu NASIL belgesinde okuyucunun temel IPv6 bilgisinin olduðu ve að adresleme yapýsýný iyi bildiði varsayýlmaktadýr.
    </p><dl><div class="sect3"><dt><div> <h4 class="title"><a name="id11"></a>Adres yapýlarý</h4></div></dt><dd><p> Bu bölüm bir sunucu-istemci uygulamasýndaki Ýnternet iletiþim kurallarýný kullanýrken, að adreslerini temsil eden soket uygulama geliþtirme arayüzünde saðlanan yapýlarý tanýtmayý amaçlamaktadýr.
        </p><div class="sect4"><div> <h5 class="title"><a name="id111"></a>IPv4 sockaddr_in</h5></div><p> 
IPv4'te að adresleri 32 bit uzunluðundadýr ve bir að düðümünü tanýmlar. Adresler noktalý onluk sistemde yazýlmýþtýr, 192.0.2.1 gibi, burada her sayý bir adresin sekiz bitlik bir bölümünü göstermektedir. Örnek IPv4 adresi &lt;netinet/in.h&gt;'da tanýmlanmýþ sockaddr_in veri yapýsýyla gösterilmektedir.
    </p><p>
        <div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">
            struct sockaddr_in
            {
               sa_family_t    sin_family;
               in_port_t      sin_port;
               struct in_addr sin_addr;
               /* Ayrýca uyum için bazý yardýmcýlar */
            };
</pre> </td></tr></table></div>
    </p><p>
sin_family bileþeni adres ailesini belirtmektedir. IPv4 adresleri için bu her zaman AF_INET 'e ayarlanmýþtýr. sin_addr alaný 32 bitlik að adresini barýndýrýr. Son olarak, sin_port bileþeni taþýma katmaný port numarasýný gösterir. Okurlar bu yapýyla zaten tanýþmýþ olmalýdýrlar, çünkü bu standart IPv4 adres yapýsýdýr.
    </p></div><div class="sect4"><div> <h5 class="title"><a name="id211"></a> IPv6 sockaddr_in6 </h5></div><p>
    IPv6'daki en büyük yenilik adres uzunluðunun artmasýdýr. 32 bit að adreslerinin yerine IPv6'da 128 bit ayrýlmýþtýr. Adresler fe80::2c0:8cff:fe01:2345 örneðindeki gibi 16 lýk düzendedir.Bu adres iki nokta üstüste ile ayrýlan her biri 16 bit uzunluðundaki 16'lýk düzendeki sayýlarý içermektedir. Ardýþýk iki tane iki nokta üstüste ardýþýk sýfýrlarýn kýsa gösterimidir, ve bir adreste sadece bir ardýþýk iki nokta üst üste bulunabilir. IPv6 adresleri &lt;netinet/in.h&gt;'de tanýmlanmýþ sockaddr_in6 veri yapýsýyla gösterilmektedir.
    </p><p>
<div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">
    truct sockaddr_in6
    {
       sa_family_t     sin6_family;
       in_port_t       sin6_port;
       uint32_t        sin6_flowinfo;
       struct in6_addr sin6_addr;
       uint32_t        sin6_scope_id;
    };
</pre> </td></tr></table></div>
</p><p>
sin6_family, sin6_port, and sin6_addr bileþenleri sockaddr_in yapýsýndaki karþýlýklarýyla ayný anlamdadýr. Fakat sin6_family üyesi AF_INET6'ya ayarlanmýþtýr, ve sin6_addr alaný 32 bit yerine 128 bit uzunluðundaki bir adresi gösterir.
</p><p>
sin6_flowinfo alaný akýþ kontrolü için kullanýlmaktadýr fakat henüz standartlaþtýrýlamamýþtýr ve ihmal edilebilir.
</p><p>
sin6_scope_id alanýn ise tek bir kullanýmý vardýr, IPv6 tasarýmcýlarýnýn bu alaný geriye uyumluluk için düzenledikleri düþünülmektedir. Görünüþe göre 128 bit IPv6 adresleri tek deðildir. Örneðin farklý aðlarda ayný yerel baðlantý adresine sahip iki düðüm olmasý mümkündür(Þekil 1'e bakýn). Bir düðüme veri göndermek için að adresinden daha fazlasý gerekmektedir; alan belirleyicisi belirtilmelidir. Linux'ta að arayüz ismi alan belirleyicisi olarak kullanýlmaktadýr (mesela eth0) [alan belirleyicilerinin belirlenmesi uygulama baðýmlýdýr]. Geçerli að arayüzlerini görüntülemek için "ifconfig"'i kullanýn.
</p><p>
16lýk að adresleri, kapsamlý bir adres üretmek için alan belirleyicileriyle geniþletilebilir. Yüzde iþareti(%) að adreslerinden alan belirleyicilerini ayýrmak için kullanýlýr. Örneðin fe80::1%eth0, 128 bit að adresini içeren fe80::1 IPv6 adresini ve eth0 da bir að arayüzünü(alan belirleyicisi) göstermektedir. Bu yüzden eðer bir düðüm iki aðda bulunacaksa, örnekteki B düðümü gibi, kullanýcý belli bir düðüme ulaþmak için hangi yolu izlemesi gerektiðini bilmelidir. Birinci þekilde, B düðümü A düðümünü fe80::1%eth0 kapsamlý adresiyle adreslemiþ, C düðümü de fe80::1%eth1 ile adreslenmiþtir.
</p><p>
    <div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">
Host A (fe80::1) ---- eth0 ---- Host B ---- eth1 ---- Host C (fe80::1)
    </pre> </td></tr></table></div>
</p><p>
sockaddr_in6 yapýsýna geri dönersek, sin6_scope_id alaný bulunduðu düðümün að arayüzlerinin listesini içerir. Sunucu uygulamalarýnda bu alan bir baðlantý kabul edildiðinde veya bir veri alýndýðýnda soket uygulama geliþtirme arayüzü(API) tarafýndan kendiliðinden doldurulur. Ýstemci uygulamalarýnda eðer bir kapsamlý adres getaddrinfo(3)'ya (Bu belgede daha ileride açýklanmýþtýr) düðüm parametresi olarak geçerse, sin6_scope_id alaný iþlevden geri dönen deðer ile doldurulur; eðer bir kapsamlý adres gelmemiþse sin6_scope_id alaný daha önce baðlanýlmaya çalýþýlan sunucu olarak atanýr. if_nametoindex(3) iþlevi bir að arayüzünü onun uygun kýsmýna çevirmek için kullanýlýr. Bu &lt;net/if.h&gt;'da tanýmlanmýþtýr.
</p></div><div class="sect4"><div> <h5 class="title"><a name="id311"></a>Genel adresler </h5></div><p>
Her klasik TCP/IP soket uygulama geliþtirme arayüzü geliþtiricisinin bildiði gibi, "generic" iþaretçilerle (pointer) ilgilenen çok sayýda soket metotlarý vardýr. Örneðin genel sockaddr veri yapýsýný gösteren bir iþaretçi bazý soket metotlarýna parametre olarak geçirilebilir(örneðin connect(2) veya bind(2)). Genel sockaddr_in6 yapýsý, genel sockaddr yapýsýndan daha büyük olduðuna dikkat edilmelidir. Bu yüzden eðer uygulamanýz tipi bilinen bir adres alýrsa ( mesela IPv4 adres yapýsý veya IPv6 adres yapýsý), ona uygun saklayýcýyý seçmeniz gerekir. sockaddr_storage veri yapýsý &lt;bits/socket.h&gt;'da bu amaç için tanýmlanmýþtýr. [bu dosyayý projenize dahil etmeyin(#include), her zamanki &lt;sys/socket.h&gt;'ý kullanýn ve &lt;bits/socket.h&gt; zaten dahil edilmelidir.]
        </p><p>
Örneðin uzak bir eþten(peer) ileti almak için kullanýlan recvfrom(2) sistem çaðrýsýný düþünün. Ýþleç taslaðý aþaðýdaki gibidir.
        </p><p>
    <div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">
ssize_t recvfrom( int              s,
                  void            *buf,
                  size_t           len,
                  int              flags,
                  struct sockaddr *from,
                  socklen_t       *fromlen );
    </pre> </td></tr></table></div>
</p><p>from parametresi genel bir sockaddr yapýsýný göstermektedir. Eðer veri bir s ile gösterilen IPv6 eþinden alýnmýþsa, from sockaddr_storage yapýsýný gösterecektir. Aþaðýda örnek bir uygulama bulunmaktadýr.</p><p>
    <div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">
/*
** Uzak bir eþten ileti okur, ve çaðýrana bir tampon göstericisi
** döndürür.
**
** 's' soket için dosya belirleyicisidir.
*/
char *rcvMsg( int s )
{
    static char bfr[ 1025 ]; /* Ýletinin saklandýðý yer. */
    ssize_t count;
    struct sockaddr_storage ss; /* Eþin adresinin bulunduðu kýsým. */
    socklen_t sslen;
    sslen = sizeof( ss );
    count = recvfrom( s,
                      bfr,
                      sizeof( bfr ) - 1,
                      0,
                      (struct sockaddr*) &amp;s,
                      &amp;sslen );
    bfr[ count ] = '\0'; /* Mesajý bitirir. */
    return bfr;
} /* rcvMsg()'ýn sonu */
    </pre> </td></tr></table></div>
</p><p>
Yukarýda görüldüðü gibi ss ( sockaddr_storage veri yapýsý nesnesi ) eþin bilgisini almak için kullanýlmýþtýr, fakat adresi recvfrom(2) çaðrýmýnda sockaddr yapýsýna iþaretçi çevrilmiþtir.</p></div></dd></div></dl><dl><div class="sect3"><dt><div> <h4 class="title"><a name="id21"></a> Arama Metotlarý</h4></div></dt><dd><p>
Çoðunlukla düðüm ismi ve servis ismi çözümlenmesi gethostbyname(3) ve getservbyname(3) metotlarýyla yapýlmaktadýr. Bu metotlar kullanýlmaya uygundur, fakat IPv6'ya ileri uyumluluklarý yoktur. Onun yerine IPv6 soket uygulama geliþtirme arayüzünde yeni arama metotlarý bulunmaktadýr. Bu arama metotlarý ayný zamanda IPv4'e geri uyumludur, bu yüzden geliþtiriciler ayný algoritmayý uygulamalarýnda hem IPv4 hem de IPv6 iletiþim kurallarý için kullanabilirler. Bu önemli bir geliþmedir, çünkü IPv6 altyapýsý birdenbire bir yere yerleþtirilmemektedir. Bu yüzden, IPv4'ten IPv6'ya geçiþ sürecince, istemci-sunucu uygulamalarý her iki iletiþim kuralý için uyumlu olarak tasarlanmalýdýr. Bu bölümün sonundaki örnek uygulama tam olarak bu iþi yapmaktadýr.
</p><p>
Yeni soket uygulama geliþtirme arayüzündeki birincil arama metodu getaddrinfo(3)'dur. Aþaðýda onun taslaðý bulunmaktadýr.
</p><p>
    <div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">
int getaddrinfo( const char             *node,
                 const char             *service,
                 const struct addrinfo  *hints,
                 struct addrinfo       **res );
    </pre> </td></tr></table></div>
</p><p>
node parametresi bir düðüm ismine veya IP adresini gösteren iþaretçidir. Belirtilen dizgi bir düðüm ismi, bir IPv4 adresi veya IPv6 adresi olabilir. service parametresi taþýyýcý katmanýn hizmet ismine veya port numarasýný gösteren iþaretçidir. Bu /etc/services'te bulunan bir isim veya ondalýk bir sayýdýr. getaddrinfo(3) düðüm/hizmet birleþimini çözer ve adres kayýtlarýný içeren bir liste döndürür; res tarafýndan gösterilen konuma bu listeyi gösteren bir iþaretçi koyar. Örneðin bir düðüm hem IPv4 hem de IPv6 ile adreslenmiþ olsun ve ilgili hizmetin /etc/services'te hem TCP hem de UDP girdisi olsun. Bu örnekte anlaþýlamayan 4 adres geri döner; biri TCP/IPv6 için, biri UDP/IPv6 için, biri TCP/IPv4 için ve biri de UDP/IPv6 için.
</p><p>
addrinfo yapýsýnýn tanýmlanmasý &lt;netdb.h&gt; içinde bulunabilir (getaddrinfo(3)'ün tanýmlanmasý ve bu bölümde anlatýlan diðer metotlarýn tanýmlanmasý da bulunabilir). Yapý aþaðýdaki þekildedir.
</p><p>
    <div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">
struct addrinfo
{
   int              ai_flags;
   int              ai_family;
   int              ai_socktype;
   int              ai_protocol;
   socklen_t        ai_addrlen;
   struct sockaddr *ai_addr;
   char            *ai_canonname;
   struct addrinfo *ai_next;
};
</pre> </td></tr></table></div>
</p><p>getaddrinfo(3) ve çeþitli alanlarla ilgili ayrýntýlý bilgi "man" sayfalarýnda mevcuttur; Bu belge sadece bunlarýn bir altkümesini içermektedir, ve IPv6 ile uygulama geliþtirme için temel bilgileri içermektedir.</p><p>ai_family, ai_socktype, ve ai_protocol alanlarý socket(2) sistem çaðrýsýndakilerle tamamen ayný anlamlara gelmektedir. ai_family alaný kayýtla iliþkili iletiþim kural ailesini belirtmektedir (adres ailesini deðil), ve IPv6 için PF_INET6 veya IPv4 için PF_INET olmalýdýr. ai_socktype parametresi kaydý karþýlayan yuvanýn türünü bildirir; Güvenilir baðlantý temelli byte akýþý için SOCK_STREAM, veya baðlantýsýz iletiþim için SOCK_DGRAM. ai_protocol alaný kaydýn öncelikli taþýma soketini belirtmektedir.</p><p>
    ai_addr alaný genel sockaddr yapý nesnesini göstermektedir. ai_family alanýndaki deðere göre bir sockaddr_in (PF_INET) yapýsýný veya bir struct sockaddr_in6 (PF_INET6) yapýsýný gösterecektir. ai_addrlen alaný ise ai_addr alaný tarafýndan gösterilen nesnenin boyutunu tutmaktadýr.</p><p>Bahsedildiði gibi getaddrinfo(3) kayýtlarýn adres listesini geri döndürür. ai_next alaný listedeki bir sonraki kaydý gösterir. </p><p>getaddrinfo(3) iþlecine gönderilen hints parametresi addrinfo yapýsý tipinde ve res'e dönen kayýtlarýn adres filtreleri olarak iþ görür. Eðer hint boþ (NULL) ise, bütün eþleþen kayýrlar geri döner; fakat hint NuLL deðilse, belirtilen yapý getaddrinfo(3)'ya hints i vererek  hangi kayýtlarýn döneceðini belirtir. hints yapýsýnda sadece ai_flags, ai_family, ai_socktype, ve ai_protocol alanlarý önemlidir ve diðer
    bütün alanlar sýfýra ayarlanmalýdýr.
</p><p>
Uygulamalar iletiþim kural ailesini belirlemek için hints-&gt;ai_family 'yi kullanýr. Mesela eðer PF_INET6'ya ayarlanmýþsa bundan sonra sadece IPv6 adresleri dönecektir. Ayný þekilde hints-&gt;ai_family 'nin PF_INET'e ayarlanmasý sadece IPv4 adreslerinin dönmesini saðlayacaktýr. Eðer bir uygulama hem IPv4 hem de IPv6 adreslerinin kayýtlarýný istiyorsa, bu alan PF_UNSPEC olarak ayarlanmalýdýr.
</p><p>
hints-&gt;socktype alaný eðer sadece baðlantý temelli byte akýþý isteniyorsa SOCK_STREAM olarak ayarlanmalýdýr, eðer baðlantýsýz iletiþimle ilgili kayýtlar isteniyorsa SOCK_DGRAM olarak, her iki durum için 0 olarak ayarlanmalýdýr.
</p><p>

Ýnternet iletiþim kurallarý için baðlantý temelli soketlerle iliþkili bir(TCP) iletiþim kuralý vardýr ve baðlantýsýz soketler için de bir tanedir (UDP), bu yüzden hints-&gt;ai_socktype'ý SOCK_STREAM veya SOCK_DGRAM olarak ayarlamak "Bana sadece TCP kayýtlarýný ver" veya "Bana UDP kayýtlarýný ver" demektir. Ýnternet iletiþim kurallarýnda hints-&gt;ai_protocol alaný ve hints-&gt;ai_socktype alanlarý çok da önemli deðildir. Yine de hints-&gt;ai_protocol sadece TCP kayýtlarý için IPPROTO_TCP veya sadece UDP kayýtlarý için IPPROTO_UDP veya her ikisi için de 0 olarak ayarlanabilir.
</p><p>

    gethostbyname(3)'deki node veya service parametrelerinden yalnýzca biri NULL deðer alabilir. Eðer node NULL ise hints parametresinin ai_flags alaný að adresinin dönen bir kayýtta nasýl ayarlanacaðýný belirtir(örneðin dönen kaydýn ai_addr bileþeninin gösterdiði nesnenin sin_addr veya sin6_addr alaný). Eðer hints'de AI_PASSIVE bayraðý kurulmuþsa dönen að adresi soldan çözümlenir(hepsi sýfýr). Bu, sunucu uygulamalarýnýn getaddrinfo(3)'yu nasýl kullanacaðýdýr. Eðer bayrak kurulmamýþsa adres yerel geri dönüþ adresine ayarlanýr(IPv6 için ::1 veya IPv4 için 127.0.0.1). Bu bir istemci uygulamanýn ayný sistem üzerindeki hedef sunucunun çalýþýp çalýþmadýðýný belirlemesi için kullanýr. Eðer service parametresi NULL ise dönen adresteki port numarasý çözümlenmez.
</p><p>
getaddrinfo(3) metodu baþarýlý olursa sýfýr deðerini veya bir hata numarasýný döndürür. Bir hata oluþmasý durumunda hata koduna karþýlýk gelen iletiye bir iþaretçi döndüren gai_strerror(3) metodu kullanýlabilir, standat C kütüphanesindeki strerror(3) gibi.
</p><p>
Eðer adres listesine ihtiyaç kalmadýysa uygulama tarafýndan yok edilmelidir. Bu iþlem freeaddrinfo(3) metoduyla yapýlabilir.
</p><p>
Bu bölümde bahsedilecek son metot getnameinfo(3)'tir. Bu metot getaddrinfo(3)'nin tersi iþlem yapar; sockaddr veri yapýsý nesnesinden bir düðüm ismi veya hizmet dizgisi yaratmakta kullanýlýr. Aþaðýda taslaðý mevcuttur.
</p><p>
    <div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">
int getnameinfo( const struct sockaddr *sa,
                 socklen_t              salen,
                 char                  *host,
                 size_t                 hostlen,
                 char                  *serv,
                 size_t                 servlen,
                 int                    flags );
</pre> </td></tr></table></div>
</p><p>
sa parametresi sorgudaki adres yapýsýný göstermektedir, ve salen de onun boyutunu tutmaktadýr. host parametresi null ile sonlanan bir konak  adý tamponuna iþaret etmektedir, hostlen parametresi ise bu tamponun boyunu tutmaktadýr. Eðer adrese karþýlýk gelen bir konak ismi yoksa, að adresi düðüme yerleþtirilir. Ayrýca ser parametresi yine null ile sonlanan hizmet adý dizge tamponunu iþaret etmektedir, ve servlen parametresi ise bu tamponun boyunu vermektedir. flags parametresi ise metodun davranýþýný deðiþtirmektedir; NI_NUMERICHOST parametresi çevrilen düðüm isimlerinin sayýsal biçimde olacaðýný belirtir, ve NI_NUMERICSERV bayraðý ise çevrilmiþ hizmetin sayýsal biçimde olacaðýný belirtir(port numarasý).
</p><p>
    NI_MAXHOST ve NI_MAXSERV sembolleri uygulamalarda çevrilmiþ düðüm isimlerinin veya hizmet isimlerinin en çok ne kadar olacaðýný belirtir.    getnameinfo(3) için çýkýþ tamponlarý belirtirken bunlarý kullanýnýz.
</p></dd></div></dl><dl><div class="sect3"><dt><div> <h4 class="title"><a name="id31"></a>Karþýlaþýlan Durumlar </h4></div></dt><dd><p>
    Programlama örneðine geçmeden önce okuyucunun IPv6 ile ilgili bilmesi gereken bir kaç durum söz konusudur. Bu durumlarýn çok karþýlaþýlanlarý (daha önce anlatýlan IPv6 að adreslerinin tekilliði konusuna ek olarak) aþaðýda açýklanmýþtýr.
</p><div class="sect4"><div> <h5 class="title"><a name="id131"></a>IPv4 eþlenmiþ(IPv4 Mapped) adresler</h5></div><p>
Güvenlik nedeniyle IPv6 uyumlu sunucu uygulamalarýnda IPv4 eþlenmiþ adreslerin kullanýmýna izin verilmemektedir. Herkesin anlayabileceði bir þekilde ifade etmek gerekirse bu bir IPv6 soketine gelen IPv4 trafiðinin kabul edilmeyeceði anlamýna gelir. IPv4 eþlenmiþ adresler karmaþýk bir biçimde ouþturulmuþ adreslerdir.
    </p><p>
        <div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">
            ::ffff:192.0.2.1
        </pre> </td></tr></table></div>
    </p><p>
Ýlk bölüm IPv6 16'lýk düzendeyken son kýsým IPv4 10'luk düzendedir. Noktalý 10'luk düzendeki IPv6 adresi gerçek bir að adresidir fakat IPv6 uyumlu bir þekle eþlenmiþ biçimdedir.
 </p><p>
Bir IPv6 soketinde IPv4 eþlenmiþ adreslerin kabul edildiðini varsayarsak, sunucu uygulamalarýnda oluþturulan bütün IPv6 soketlerinin IPV6_V6ONLY soket yapýsý seçeneðine ayarlanmalýdýr [ Hagino kitabýnda bu durumun sadece sunucu uygulamalarýný ilgilendirdiði belirtilmektedir. Fakat eðer bir istemci uygulamasý hedefi belirlerken IPv4 eþlenmiþ adresini kullanýrsa , hedef sunucunun IPv4 eþlenmiþ adresleri kabul etmediði düþünülürse, her þeye raðmen baðlantýnýn saðlandýðý yapýlan denemelerde gözlenmiþtir. Sunucu tarafýnda baðlantý bitim noktasý IPv4 soketidir; fakat istemci tarafýnda ise baðlantýnýn bitim noktasý bir IPv6 soketidir. Hem sunucu tarafýnda hem de istemci tarafýnda IPV6_V6ONLY soket seçeneði ayarlanýrsa herhangi bir baðlantýnýn kabul edilmesi önlenmiþ olur]. Burada ufak bir problem var. Görünen o ki IPV6_V6ONLY seçeneði bütün sistemlerde tanýmlý deðildir [en azýndan 2005'te Hagino kitabýnda yazýlana göre]. Bu bölümün soundaki sunucu örneði bu problemle nasýl baþa çýkýlacaðýný götermektedir.
 </p><p>
Eðer IPv4 trafiði IPv6 soketlerine uygun deðilse, buna göre bir sunucu uygulamasý eðer her iletiþim kuralýndan gelen isteklere cevap vermek istiyorsa ilgili að hizmeti için hem IPv4 hem de IPv6 soketini kullanmalýdýr. Bu daha önce açýklanan esneklik konusuna bizi götürmektedir. Eðer getaddrinfo(3) çoklu adres kayýtlarý geri döndürüyorsa, sunucu uygulamalarý bir liste oluþturmalý ve elde edilen her adres için uygun bir soket atanmalýdýr.
 </p></div><div class="sect4"><div> <h5 class="title"><a name="id231"></a>/etc/hosts 'dosyasýndaki alan tanýmlayýcýlarýný belirtmeyin </h5></div><p>
         /etc/hosts dosyasýnda bir IPv6 að adresini bir sistem adýna atamak mümkündür. Örneðin yazarýn kullandýðý sistemin /etc/hosts dosyasýndan bir alýntý aþaðýda mevcuttur.
     </p><p>
         <div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">
                     ::1                        localhost
                     127.0.0.1                  localhost
                     fe80::2c0:8cff:fe01:2345   pt141
                     192.0.2.1                  pt141
         </pre> </td></tr></table></div>
     </p><p>
         "localhost" ve "pt141" konak isimleri hem IPv4 hem de IPv6 adreslerine dönüþtürülebilir. Örneðin getaddrinfo(3)'ya düðüm parametresi olarak "pt141" geçirilirse, metot düðüm için hem IPv4 hem de IPv6 adres kaydý geri döndürecektir (eðer hint parametresi belirtilmemiþse ). Fakat alan adresleri /etc/hosts dosyasýnda kullanýlamamaktadýr. Kullanýldýðýnda ise getaddrinfo(3) sadece bir IPv4 kaydý döndürmektedir.
     </p></div><div class="sect4"><div> <h5 class="title"><a name="id331"></a> Ayný sitem üzerindeki istemci ve sunucular</h5></div><p>
         Bir sistemin 192.0.2.1 IPv4 adresine sahip olduðunu düþünelim. Bu sistemdeki çalýþan bir istemci uygulamasý ayný sistemdeki sunucu uygulamasýna yerel geri dönüþ (loopback) adresini (127.0.0.1) veya hedef sunucunun að adresini(192.0.2.1) kullanarak baðlanabilir. Fakat sürpriz bir þekilde yazar, eðer bir IPv6 istemci uygulamasý hedef olarak ayný sistemin að adresini kullarak sunucu uygulamasýna baðlanamamýþtýr. Bu yüzden yerel geri dönüþ adresi(::1) kullanýlmalýdýr.
     </p></div></dd></div></dl><dl><div class="sect3"><dt><div> <h4 class="title"><a name="id41"></a>Anlattýklarýmýzý Biraraya Getirelim (istemci-sunucu uygulama örneði) </h4></div></dt><dd><p>    Þimdiye kadar konuþtuklarýmýzý bir sunucu-istemci uygulamasýyla toparlayalým. Bu bölümün kalaný bir uzak gün ve zaman uygulamasýna baðlýdýr ('daytime' internet hizmeti)[Ms Castro Porting applications to IPv6 HowTo kitabýnda bir 'daytime' örneði vermiþtir. Þu bilinmelidir ki buradaki kaynak kod özgündür, en baþýndan geliþtirilmiþtir, ve bu ve herhangi eriþilebilen 'daytime' örneði arasýndaki benzerlik tamamen rastlantýdýr.]. Bu bölümde sunulan kaynak kod 2.6 (hatta 2.6.9) çekirdek kullanan bir RedHat Linux sürümünde geliþtirilmiþ ve denenmiþtir. Okuyucular bu kaynak kodu özüne sadýk kalýndýklarý sürece ücretsiz olarak kullanabilirler, fakat elbette ilk önce standart telif hakký verilmelidir.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0"><tr><td rowspan="2" align="center" valign="top" width="25"><img src="../images/xsl/note.png"></td><th>Not</th></tr><tr><td colspan="2" align="left" valign="top"><p>
        Her ne kadar örnek kaynak kodun hatasýz çalýþtýðý düþünülse de yazar bunun güvenilirliðiyle ilgili hiç bir garanti vermemektedir, özellikle bazý hatalar bilerek kýsaca geçilmiþtir.
    </p></td></tr></table></div><p>
    Bunu kavradýðýnýz zaman, IPv4 ve IPv6 uygulamalarý arasýnda çok da farklýlýk olmadýðýný göreceksiniz. IPv6 uygulamalarýný kodlarken asýl iþ bunu iletiþim kuralýna baðlý kalmadan yapmaktýr, öyle ki ayný zamanda hem IPv4 ve hem IPv6 ile çalýþabilsin. Bu örnek uygulama tam olarak bunu yapýyor. Örnekteki iletiþim kuralý baðýmlý kod sadece ayrýntýlý biçimde að adreslerini yazdýrýken kullanýldý; fakat sadece addrinfo yapýsýndaki ai_family alaný kontrol edildikten sonra, böylelikle uygulama o anda tam olarak hangi adres tipiyle çalýþtýðýný bilebilsin.
</p><div class="sect4"><div> <h5 class="title"><a name="id141"></a>'Daytime' Sunucu Kodu</h5></div><p>
        Sunucu kodu tod6d.c dosyasýnda bulunmaktadýr. Ýlk önce, sunucu aþaðýdaki komut söz dizimi kullanýlarak çalýþtýrýlabilir (tod6d'nin çalýþtýrýlabilir bir dosya olduðunu varsayýyorum).
    </p><p>
        <div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">tod6d [-v] [service]</pre> </td></tr></table></div>
    </p><p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0"><tr><td rowspan="2" align="center" valign="top" width="25"><img src="../images/xsl/note.png"></td><th>PARAMETRELER:</th></tr><tr><td colspan="2" align="left" valign="top"><p>Dinlenmesini istediðiniz hizmet (veya iyi bilinen port). Varsayýlan "daytime" dýr. </p><p>Ayrýntýlý kipi açar. </p></td></tr></table></div>
    </p><p>
        Sunucu aðdaki hem Ipv4 hem de IPv6 isteklerine cevap verebilmektedir. Sunucu kaynak kodu tod6d.c dosyasýnda aþaðýdaki þekildedir.
    </p><div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">

/******************************************************************************
* Dosya: tod6d.c
* Açýklama: IPv6 uyumlu "daytime" sunucusu için kaynak kodu içerir.
* Yazar: John Wenker, Uzman yazýlým mühendisi,
* Performance Technologies, San Diego, USA
******************************************************************************/
/*
** Sistem baþlýk dosyalarý.
*/
#include &lt;errno.h&gt; /* errno bildirimi &amp; hata kodlarý. */
#include &lt;netdb.h&gt; /* getaddrinfo(3) */
#include &lt;netinet/in.h&gt; /* sockaddr_in &amp; sockaddr_in6 tanýmlarý. */
#include &lt;stdio.h&gt; /* printf(3) */
#include &lt;stdlib.h&gt; /* exit(2) */
#include &lt;string.h&gt; /* Dizge iþleçleri &amp; hafýza iþleçleri. */
#include &lt;sys/poll.h&gt; /* poll(2) ve ilgili bildirimler. */
#include &lt;sys/socket.h&gt; /* Soket metotlarý (socket(2), bind(2), etc).*/
#include &lt;time.h&gt; /* time(2) &amp; ctime(3). */
#include &lt;unistd.h&gt; /* getopt(3), read(2), vb. */
/*
** Sabitler.
*/
#define DFLT_SERVICE "daytime" /* Varsayýlan hizmet ismi. */
#define INVALID_DESC -1 /* Geçersiz dosya tanýmlayýcýsý . */
#define MAXCONNQLEN 3 /* Kuyruktaki en fazla baðlantý isteði sayýsý. */
#define MAXTCPSCKTS 2 /* IPv4 için bir TCP yuvasý &amp; bir tane de IPv6 için. */
#define MAXUDPSCKTS 2 /* IPv4 için bir UDP yuvasý &amp; bir tane de IPv6 için. */
#define VALIDOPTS "v" /* Geçerli komut seçeneði. */
/*
** Temel Boolean tip bildirimleri.
*/
typedef enum { false = 0, true } boolean;
/*
**Dahili yardýmcý iþleçlerin taslaklarý.
*/
static int openSckt( const char *service,
                     const char *protocol,
                     int desc[ ],
                     size_t *descSize );
static void tod( int tSckt[ ],
                 size_t tScktSize,
                 int uSckt[ ],
                 size_t uScktSize );
/*
** Genel (bu dosya için) veri nesneleri.
*/
static char hostBfr[ NI_MAXHOST ]; /* w/getnameinfo(3)'nin kullanýmý için. */
static const char *pgmName; /* Program ismi w/o dizin öneki. */
static char servBfr[ NI_MAXSERV ]; /* For use w/getnameinfo(3). */
static boolean verbose = false; /* Ayrýntýlý mod iþareti. */
/*
** Komut sözdizim ihlalleri için makro kullanýmý.
*/
#define USAGE                                   \
            {                                   \
                 fprintf( stderr,               \
                 "Usage: %s [-v] [service]\n",  \
                 pgmName );                     \
                 exit( 127 );                   \
            } /* USAGE makrosunun sonu. */
/*
** Eðer bir sistem çaðrýsý hatasý meydana gelirse uygulamayý sonlandýracak makro. Sistem çaðrýsý
** hata oluþmasý durumunda -1 döndüren bilinen bir tipte olmalýdýr. Bu makro
** Dr. V. Vinge'nin, SDSU Bilgisayar Bilimleri bölümü (emekli), yazdýðý makronun deðiþtirilmiþ bir sürümüdür... gördüðüm en iyi profesör.
** Kararlý kodlara ek olarak bilim kurgu yazdýðýný da öðrendim.
*/
#define CHK(expr)                                                    \ 
        do                                                           \
        {                                                            \
              if ( (expr) == -1 )                                    \
              {                                                      \
                 fprintf( stderr,                                    \
                          "%s (line %d): System call ERROR - %s.\n", \
                          pgmName,                                   \
                          __LINE__,                                  \
                          strerror( errno ) );                       \
                 exit( 1 );                                          \
               } /* Sistem çaðrýsýnýn baþarýsýz olmasý sonu. */      \
        } while ( false )
/******************************************************************************
* Metot: main
*
* Açýklama:
*  gün ve zaman sunucusunun ayarlanmasý ve að isteklerine cevap verme. Bu sunucu
* hem TCP hem de UDP isteklerine cevap verebilmektedir.
*
* Parametreler:
* main() iþlecine geçirilen klasik argc and argv parametreleri.
*
* Dönüþ deðeri:
* Bu deðer döndürmeyen artalan bir süreçtir. Fakat soket açýlamasý
* konusunda baþarýsýz olursa, sýfýr deðeri döndürür.
******************************************************************************/
int main( int argc,
          char *argv[ ] )
{
    int opt;
    const char *service = DFLT_SERVICE;
    int tSckt[ MAXTCPSCKTS ]; /* TCP soket belirleyici dizisi. */
    size_t tScktSize = MAXTCPSCKTS; /* uSckt'nin boyu (# öðelerin). */
    int uSckt[ MAXUDPSCKTS ]; /* UDP soket belirleyici dizisi. */
    size_t uScktSize = MAXUDPSCKTS; /* uSckt'nin boyu (# öðelerin). */
    /*
    ** Uygulama isminin ayarlanmasý (w/o dizin önekleri).
    */
    pgmName = strrchr( argv[ 0 ], '/' );
    pgmName = pgmName == NULL ? argv[ 0 ] : pgmName + 1;
    /*
    ** iþlem komut seçenekleri.
    */
    opterr = 0; /* "invalid option" hata mesajlarýný kapatýr. */
    while ( ( opt = getopt( argc, argv, VALIDOPTS ) ) &gt;= 0 )
    {
       switch ( opt )
       {
           case 'v': /* Ayrýntýlý biçim. */
           {
                  verbose = true;
                  break;
            }
            default:
            {
                  USAGE;
            }
       } /* Komut seçeneðinde SWITCH sonu. */
    } /* Ýþlem seçeneklerinde WHILE sonu. */
    /*
    ** Ýþlem komut satýrý parametreleri.
    */
    switch ( argc - optind )
    {
        case 0: break;
        case 1: service = argv[ optind ]; break;
        default: USAGE;
    } /* Komut satýrý parametrelerinin sayýsýnýn belirlenmesi SWITCH sonu. */
    /*
    ** hem IPv4 hem de IPv6 için hizmet isteklerinin
    ** kabul edileceði hem TCP hem de UDP yuvasýný açar.
    */
    if ( ( openSckt( service, "tcp", tSckt, &amp;tScktSize ) &lt; 0 ) ||
         ( openSckt( service, "udp", uSckt, &amp;uScktSize ) &lt; 0 ) )
    {
        exit( 1 );
    }
    /*
    ** "time-of-day" sunucusunu çalýþtýrýr.
    */
    if ( ( tScktSize &gt; 0 ) || ( uScktSize &gt; 0 ) )
    {
         tod( tSckt,           /* tod() geri dönmez. */
              tScktSize,
              uSckt,
              uScktSize );
    }
    /*
    ** tod() geri dönmediðinden, eðer hiç yuva açýlamazsa uygulama bu satýra gelir.
    */
    if ( verbose )
    {
        fprintf( stderr,
                 "%s: No sockets opened... terminating.\n",
                  pgmName );
    }
    return 0;
} /* main() sonu */

/******************************************************************************
* Metot: openSckt
*
* Açýklama:
* Belirtilen inet hizmet &amp; iletiþim kuralý için pasif (sunucu) soketlerini açar.
* Son cümledeki "soketlerini" sözcüðünün çoðul olduðuna dikkat edin. Herkesin IPv6'ya
* geçiþi tamamlanana kadar sunucu uygulamasý baðlantýlarý dinlemek için
* iki soketi de açmak zorundadýr...
* IPv4 trafiði için bir tane ve IPv6 trafiði için de bir tane.
*
* Parametreler:
* service - Dinlenmek istenen iyi bilinen soketi temsil eden karakter dizisine
* iþaretçidir. (bir hizmet ismi veya 10'luk bir sayý olabilir).
* protocol - Ulaþým katmaný iletiþim kuralýný belirten karakter dizisine
* iþaretçi (sadece "tcp" veya "udp" kullanýlabilir).
* desc - Açýldýðýnda yerleþtirilecek soket açýklayýcýsýný belirten dizgeye
* iþaretçi.
* descSize - deðer-sonuç parametresidir. Girdi olmasý durumunda 'desc'e yerleþtirilen açýklayýcýlarýn
* sayýlarýndan en fazla olanýdýr (örneðin dizgedeki elemanlarýn sayýsý).
* Döndüðü takdirde, açýlan tanýmlayýcýlarýn sayýsýný içerecektir.
* "desc"te kullanýlmayan slotlar INVALID_DESC deðerini alacaktýr.
*
* Dönüþ deðeri:
* Baþarýlý olmasý durumunda 0, hata oluþmasý durumunda -1.
******************************************************************************/
static int openSckt( const char *service,
                     const char *protocol,
                     int desc[ ],
                     size_t *descSize )
{
    struct addrinfo *ai;
    int aiErr;
    struct addrinfo *aiHead;
    struct addrinfo hints = { .ai_flags = AI_PASSIVE, /* Sunucu biçimi */
                              .ai_family = PF_UNSPEC }; /* IPv4 veya IPv6. */
    size_t maxDescs = *descSize;
    /*
    ** Çýktý parametrelerinin baþlatýlmasý. Döngü tamamlandýðýnda *descSize ýn deðeri 0'dýr.
    */
    while ( *descSize &gt; 0 )
    {
        desc[ --( *descSize ) ] = INVALID_DESC;
    }
    /*
    ** Hangi iletiþim kuralýnýn seçildiðini konrol edelim (sadece TCP ve UDP seçilebilir).
    */
    if ( strcmp( protocol, "tcp" ) == 0 ) /* TCP iletiþim kuralý. */
    {
          hints.ai_socktype = SOCK_STREAM;
          hints.ai_protocol = IPPROTO_TCP;
    }
    else if ( strcmp( protocol, "udp" ) == 0 ) /* UDP iletiþim kuralý. */
    {
        hints.ai_socktype = SOCK_DGRAM;
        hints.ai_protocol = IPPROTO_UDP;
    }
    else /* Geçersiz iletiþim kuralý. */
    {
        fprintf( stderr,
                 "%s (line %d): ERROR - Unknown transport "
                 "layer protocol \"%s\".\n",
                 pgmName,
                 __LINE__,
                 protocol );
        return -1;
    }

    /*
    ** Hizmetlerin bilinen port numaralarýný inceleyin. NULL'un 'node' parametresi
    ** olarak geçirildiðine dikkat edin, ve 'hints'teki AI_PASSIVE bayraðý belirlenmiþtir.
    ** Böylelikle uygulama adres bilgisini pasif olarak elde etmektedir.
    ** IPv6 kayýtlarý için að adresi :: (hepsi sýfýr) deðeriyle, veya
    ** IPv4 kayýtlarý için 0.0.0.0 deðeriyle baþlatýlmýþtýr.
    */
    if ( ( aiErr = getaddrinfo( NULL,
                                service,
                                &amp;hints,
                                &amp;aiHead ) ) != 0 )
    {
        fprintf( stderr,
                 "%s (line %d): ERROR - %s.\n",
                 pgmName,
                 __LINE__,
                 gai_strerror( aiErr ) );
        return -1;
    }
    /*
    ** Dönen adres kayýtlarýnýn her biri için, bir pasif yuva kurmayý denemektedir.
    */
    for ( ai = aiHead;
            ( ai != NULL ) &amp;&amp; ( *descSize &lt; maxDescs );
          ai = ai-&gt;ai_next )
    {
        if ( verbose )
        {
            /*
            ** O anki adres bilgisini görüntüleme. Ýlk önce iletiþim kuralý baðýmsýz
            ** alanlardan baþlayalým.
            */
            fprintf( stderr,
                     "Setting up a passive socket based on the "
                     "following address info:\n"
                     " ai_flags = 0x%02X\n"
                     " ai_family = %d (PF_INET = %d, PF_INET6 = %d)\n"
                     " ai_socktype = %d (SOCK_STREAM = %d, SOCK_DGRAM = %d)\n"
                     " ai_protocol = %d (IPPROTO_TCP = %d, IPPROTO_UDP = %d)\n"
                     " ai_addrlen = %d (sockaddr_in = %d, "
                     "sockaddr_in6 = %d)\n",
                     ai-&gt;ai_flags,
                     ai-&gt;ai_family,
                     PF_INET,
                     PF_INET6,
                     ai-&gt;ai_socktype,
                     SOCK_STREAM,
                     SOCK_DGRAM,
                     ai-&gt;ai_protocol,
                     IPPROTO_TCP,
                     IPPROTO_UDP,
                     ai-&gt;ai_addrlen,
                     sizeof( struct sockaddr_in ),
                     sizeof( struct sockaddr_in6 ) );
            /*
            ** Þimdi iletiþim kuralýna özel þekillendirilmiþ soket adreslerini görüntüleyelim. Unutmayýn ki
            ** uygulama, konak ve hizmetleri sayýsal dizgelere çevirmek için getnameinfo(3)'yu kullanmaktadýr.
            */
            getnameinfo( ai-&gt;ai_addr,
                         ai-&gt;ai_addrlen,
                         hostBfr,
                         sizeof( hostBfr ),
                         servBfr,
                         sizeof( servBfr ),
                         NI_NUMERICHOST | NI_NUMERICSERV );
            switch ( ai-&gt;ai_family )
            {
                case PF_INET: /* IPv4 adres kaydý. */
                {
                    struct sockaddr_in *p = (struct sockaddr_in*) ai-&gt;ai_addr;
                    fprintf( stderr,
                             " ai_addr = sin_family: %d (AF_INET = %d, "
                             "AF_INET6 = %d)\n"
                             " sin_addr: %s\n"
                             " sin_port: %s\n",
                             p-&gt;sin_family,
                             AF_INET,
                             AF_INET6,
                             hostBfr,
                             servBfr );
                    break;
                } /* IPv4 CASE sonu. */
                case PF_INET6: /* IPv6 adres kaydý. */
                {
                    struct sockaddr_in6 *p = (struct sockaddr_in6*) ai-&gt;ai_addr;
                    fprintf( stderr,
                             " ai_addr = sin6_family: %d (AF_INET = %d, "
                             "AF_INET6 = %d)\n"
                             " sin6_addr: %s\n"
                             " sin6_port: %s\n"
                             " sin6_flowinfo: %d\n"
                             " sin6_scope_id: %d\n",
                             p-&gt;sin6_family,
                             AF_INET,
                             AF_INET6,
                             hostBfr,
                             servBfr,
                             p-&gt;sin6_flowinfo,
                             p-&gt;sin6_scope_id );
                    break;
                } /* IPv6 CASE sonu. */
                default: /* Buraya hiçbir zaman gelinmeyecek ama sadece tamamlayýcý olmasý açýsýndan dolduruldu.*/
                {
                    fprintf( stderr,
                             "%s (line %d): ERROR - Unknown protocol family (%d).\n",
                             pgmName,
                             __LINE__,
                             ai-&gt;ai_family );
                    freeaddrinfo( aiHead );
                    return -1;
                } /* (bilinmeyen iletiþim kuralý ailesi) DEFAULT durumu sonu (unknown protocol family). */
            } /* Ýletiþim kuralý ailesi SWITCH sonu. */
        } /*  Ayrýntýlý biçim IF sonu. */
        /*
        ** addrinfo yapýsýndaki bilgiyi kullanarak bir yuva yaratýlmasý.
        */
        CHK( desc[ *descSize ] = socket( ai-&gt;ai_family,
                                         ai-&gt;ai_socktype,
                                         ai-&gt;ai_protocol ) );
        /*
        ** 22.1.3.1 numaralý bölümde açýklandýðý gibi, "IPv4 haritalanmýþ adresler" i engellemek için kod aþaðýdadýr.
        ** Eðer bir IPv6 yuvasý henüz oluþturulmuþsa, IPV6_V6ONLY soket seçeneðini
        ** iþaretleyin.
        */
        if ( ai-&gt;ai_family == PF_INET6 )
        {
#if defined( IPV6_V6ONLY )
            /*
            ** IPv4 haritalanmýþ adresleri geçersiz kýlýn.
            */
            int v6Only = 1;
            CHK( setsockopt( desc[ *descSize ],
                             IPPROTO_IPV6,
                             IPV6_V6ONLY,
                             &amp;v6Only,
                             sizeof( v6Only ) ) );
#else

/*
** IPV6_V6ONLY seçilmemiþse, böylelikle soket seçeneði belirlenemez ve bu yüzden 
** IPv4 haritalanmýþ adresler etkisizleþtirilemez. Bir uyarý mesajý verin ve
** soketi kapatýn. Tasarým notu: Eðer
** #if...#else...#endif yapýlarý kaldýrýlýrsa, bu uygulama
** derlenmeyecektir. (çünkü IPV6_V6ONLY tanýmlanmamýþ). Bu
** kabul edilebilir bir yaklaþým; eðer uygulama kurulamamýþsa 
** IPv4 haritalanmýþ adresler kesinlikle uygulanabilir deðildir.Fakat uygulamanýn hem IPv6 hem de IPv4 soketleri
** için çalýþmasý tasarlandýðýndan, uygulamanýn IPV6_V6ONLY tanýmlanmamýþ olsa bile
** derlenmesinine izin vermeye karar verdim, ve
** bunu derleme zamaný hatasý yerine bir çalýþma zamaný uyarýsýna çevirdim.
** IPv4 haritalanmýþ adresler hala kullanýlabilir deðildir çünkü bütün IPv6 trafiði
** kapatýlmýþtýr (burada bütün IPv6 soketleri kapatýlmýþtýr), fakat en azýndan sunucu bu yönden
** IPv4 að trafiðine hala hizmet verebilmektedir.
*/
    fprintf( stderr,
             "%s (line %d): WARNING - Cannot set IPV6_V6ONLY socket "
             "option. Closing IPv6 %s socket.\n",
             pgmName,
             __LINE__,
             ai-&gt;ai_protocol == IPPROTO_TCP ? "TCP" : "UDP" );
    CHK( close( desc[ *descSize ] ) );
    continue; /* w/o ve *descSize'ýn güncellenmesi için FOR döngüsünün baþýna git! */
#endif /* IPV6_V6ONLY */
    } /* Bir IPv6 yuvasý ise IF'i bitir. */
    /*
    ** Soketi baðla. addrinfo yapýsýndan alýnan bilgi kullanýlmýþtýr.
    */
    CHK( bind( desc[ *descSize ],
         ai-&gt;ai_addr,
         ai-&gt;ai_addrlen ) );
    /*
    ** Eðer bu bit TCP yuvasý ise, yuvayý pasif dinleme durumuna getirin
    ** (dinleme sadece baðlantý temelli yuvalarda kullanýlabilir).
    */
    if ( ai-&gt;ai_socktype == SOCK_STREAM )
    {
        CHK( listen( desc[ *descSize ],
                     MAXCONNQLEN ) );
    }
    /*
    ** Soketin kurulmasý iþlemi tamamlandý. Dizinin bir sonraki elemanýný ele alalým.
    */
    descSize += 1;
    } /* Her adres bilgi yapýsý döndüðünde FOR'u bitirelim. */

/*
** Kullanýlmayan adres yapýlarý olup olmadýðýnýn kontrolü.
*/
if ( verbose &amp;&amp; ( ai != NULL ) )
{
    fprintf( stderr,
             "%s (line %d): WARNING - Some address records were "
             "not processed due to insufficient array space.\n",
             pgmName,
             __LINE__ );
} /* Ýþlenilmeden kalan adres kayýtlarý kalmasý ve IF sonu. */
/*
** Temizleme iþlemi.
*/
freeaddrinfo( aiHead );
return 0;
} /* openSckt() sonu */

/******************************************************************************
* Metot: tod
*
* Açýklama:
* Belirtilen soketleri dinleyen ve o anki zaman bilgisini istemcilere
* gönderir. Bu metot bir deðer döndürmez.
*
* Parametreler:
* tSckt - Dinlenilmesi istenen TCP yuvalarýný gösteren dizi.
* tScktSize - tSckt dizisinin boyu (elementlerin sayýsý).
* uSckt - Dinlenilmesi istenen UDP yuvalarýný gösteren dizi.
* uScktSize - uSckt dizisinin boyu (elementlerin sayýsý).
*
* Dönüþ deðeri: Yok.
******************************************************************************/
static void tod( int tSckt[ ],
                 size_t tScktSize,
                 int uSckt[ ],
                 size_t uScktSize )
{
    char bfr[ 256 ];
    ssize_t count;
    struct pollfd *desc;
    size_t descSize = tScktSize + uScktSize;
    int idx;
    int newSckt;
    struct sockaddr *sadr;
    socklen_t sadrLen;
    struct sockaddr_storage sockStor;
    int status;
    size_t timeLen;
    char *timeStr;
    time_t timeVal;
    ssize_t wBytes;
/*
** poll(2) dizisi için bellek ayýralým.
*/
desc = malloc( descSize * sizeof( struct pollfd ) );
if ( desc == NULL )
{
fprintf( stderr,
         "%s (line %d): ERROR - %s.\n",
         pgmName,
         __LINE__,
         strerror( ENOMEM ) );
exit( 1 );
}
/*
** poll(2) dizisini baþlatalým.
*/
for ( idx = 0; idx &lt; descSize; idx++ )
{
desc[ idx ].fd = idx &lt; tScktSize ? tSckt[ idx ]
: uSckt[ idx - tScktSize ];
desc[ idx ].events = POLLIN;
desc[ idx ].revents = 0;
}
/*
** Ana zaman sunucusu döngüsü. Hem TCP hem de UDP isteklerine cevap verir. Bu
** etkileþimli bir sunucudur, ve bütün istekler doðrudan ana döngü içerisinde
** ele alýnýr.
*/
while ( true ) /* Sonsuz Döngü. */
{
    /*
    ** Yuvalarýn birinde bir etkinlik olmasý beklenir. DO..WHILE yapýsý
    ** bir sinyal tarafýndan kesilmiþ iþlemdeki sistem çaðrýsýný yeniden baþlatmak için
    ** kullanýlýr.
    */
    do
    {
        status = poll( desc,
                       descSize,
                       -1 /* Herhangi bir girdi olmasý beklenir. */ );
    } while ( ( status &amp; 0 ) &amp;&amp; ( errno == EINTR ) );
    CHK( status ); /* Gerçekten bir sistem çaðrýsý hatasý olup olmadýðýnýn kontrolü. */
    /*
    ** o anki zaman.
    */
    timeVal = time( NULL );
    timeStr = ctime( &amp;timeVal );
    timeLen = strlen( timeStr );
    /*
    ** Yeni bir að etkinliði olduðunu belirtin.
    */
    if ( verbose )
    {
        char *s = malloc( timeLen+1 );
        strcpy( s, timeStr );
        s[ timeLen-1 ] = '\0'; /* zaman dizgesindeki '\n' in üzerine yazma.*/
        fprintf( stderr,
                 "%s: New network activity on %s.\n",
                 pgmName,
                 s );
        free( s );
    } /* IF sonu. */
    /*
    ** Kullanýlabilir bir girdi olmuþ iþlem yuvasý.
    */
    for ( idx = 0; idx &lt; descSize; idx++ )
    {
        switch ( desc[ idx ].revents )
        {
            case 0: /* Bu sokette iþlem yok; sonrakini deneyin. */
                continue;
            case POLLIN: /* Að etkinliði. Bunu iþleyelim. */
                break;
            default: /* Geçersiz eylem. */
            {
                fprintf( stderr,
                         "%s (line %d): ERROR - Invalid poll event (0x%02X).\n",
                         pgmName,
                         __LINE__,
                         desc[ idx ].revents );
                exit( 1 );
            }
        } /* Dönen olay için SWITCH sonu. */
    /*
    ** Bunun bir TCP isteði mi yoksa bir UDP isteði mi olduðuna karar verme.
    */
    if ( idx &lt; tScktSize )
    {
        /*
        ** TCP baðlantý isteði. Kabul edin. sockaddr_storage veri tipinin
        ** kullanýmýný inceleyin.
        */
        sadrLen = sizeof( sockStor );
        sadr = (struct sockaddr*) &amp;sockStor;
        CHK( newSckt = accept( desc[ idx ].fd,
                               sadr,
                               &amp;sadrLen ) );
        CHK( shutdown( newSckt, /* Sunucu herhangi bir þey kabul etmez. */
                       SHUT_RD ) );
        if ( verbose )
        {
            /*
            ** Uzak istemcinin soket adresinin gösterilmesi. Adresten baðýmsýz
            ** alanlarla baþlar.
            */
            fprintf( stderr,
                     "Sockaddr info for new TCP client:\n"
                     " sa_family = %d (AF_INET = %d, AF_INET6 = %d)\n"
                     " addr len = %d (sockaddr_in = %d, "
                     "sockaddr_in6 = %d)\n",
                     sadr-&gt;sa_family,
                     AF_INET,
                     AF_INET6,
                     sadrLen,
                     sizeof( struct sockaddr_in ),
                     sizeof( struct sockaddr_in6 ) );
            /*
            ** Adrese özel alanlarýn gösterilmesi.
            */
            getnameinfo( sadr,
                         sadrLen,
                         hostBfr,
                         sizeof( hostBfr ),
                         servBfr,
                         sizeof( servBfr ),
                         NI_NUMERICHOST | NI_NUMERICSERV );
            /*
            ** Þu an adres ailesini deðiþtirdiðimizi unutmayýn, iletiþim kuralý
            ** ailesini deðil.
            */
            switch ( sadr-&gt;sa_family )
            {
                case AF_INET: /* IPv4 address. */
                {
                    struct sockaddr_in *p = (struct sockaddr_in*) sadr;
                    fprintf( stderr,
                             " sin_addr = sin_family: %d\n"
                             " sin_addr: %s\n"
                             " sin_port: %s\n",
                             p-&gt;sin_family,
                             hostBfr,
                             servBfr );
                    break;
                } /* End CASE of IPv4. */
                case AF_INET6: /* IPv6 adresi. */
                {
                    struct sockaddr_in6 *p = (struct sockaddr_in6*) sadr;
                    fprintf( stderr,
                             " sin6_addr = sin6_family: %d\n"
                             " sin6_addr: %s\n"
                             " sin6_port: %s\n"
                             " sin6_flowinfo: %d\n"
                             " sin6_scope_id: %d\n",
                             p-&gt;sin6_family,
                             hostBfr,
                             servBfr,
                             p-&gt;sin6_flowinfo,
                             p-&gt;sin6_scope_id );
                    break;
                    } /* IPv6 için CASE sonu. */ 

                    default:   /*  Buraya asla girilmez, fakat bütünlük için yazýlmýþtýr. */
                 {
                    fprintf( stderr,
                             "%s (line %d): ERROR - Unknown address "
                             "family (%d).\n",
                             pgmName,
                             __LINE__,
                             sadr-&gt;sa_family );
                     break;


                  }  /* adres ailesi için SWITCH sonu. */
            }  /* Ayrýntýlý kip IF sonu. */

            /*
            ** Ýstemciye TOD gönderilmesi.
            */
            wBytes = timeLen;
            while ( wBytes &gt; 0 )
            {
                  do
                  {
                        count = write( newSckt,
                                       timeStr,
                                       wBytes );
                  } while ( ( count &lt; 0 ) &amp;&amp; ( errno == EINTR ) );
                  CHK( count );   /* Gerçekten bir hata  olup olmadýðýnýn kontrolü. */
                  wBytes -= count;
            } /* Gönderilecek veri için WHILE sonu. */
            CHK( close( newSckt ) );
        }  /* Bir TCP baðlantý isteði için IF sonu. */
        else
        {
            /*
            ** Bu bir UDP soketidir, ve bir veri bloðu kullanýlabilir durumdadýr. UDP istekleri 
            ** ile ilgili  eðlenceli konu sunucunun herhangi istemci girdisine gerek 
            ** duymamasýdýr; fakat ayný zamanda istemciden veri için istek gelmeden sunucu TOD'u 
            ** gönderemez, ve UDP ile bu iþlem sunucunun istemciden bir veri bloðu 
            ** almasý ile gerçekleþebilir. Sonuçta, sunucu herhangi bir þey almalý,
            ** fakat bu veri bloðunun içeriði önemli deðildir.
            ** Veri bloðu okunur. Yeniden adresleri almak için sockaddr_storage'ýn kullanýlmasýna
            ** dikkat edilmelidir.
            */

            sadrLen = sizeof( sockStor );
            sadr    = (struct sockaddr*) &amp;sockStor;
            CHK( count = recvfrom( desc[ idx ].fd,
                                   bfr,
                                   sizeof( bfr ),
                                   0,
                                   sadr,
                                   &amp;sadrLen ) );
            /*
            ** Stdout'ta her ne alýndýysa gösterilmesi.
            */
            if ( verbose )
            {
                ssize_t rBytes = count;
                fprintf( stderr,
                         "%s: UDP datagram received (%d bytes).\n",
                         pgmName,
                         count );
                while ( count &gt; 0 )
                {
                    fputc( bfr[ rBytes - count-- ],
                           stdout );
                }
                if ( bfr[ rBytes-1 ] != '\n' )
                fputc( '\n', stdout );   /* Yeni satýr stdout'u boþaltýr. */
                /*
                ** Uzak istemcinin soket adresinin gösterilmesi. Ýlk önce
                ** adresten baðýmsýz alanlar.
                */
                fprintf( stderr,
                         "Remote client's sockaddr info:\n"
                         "   sa_family = %d (AF_INET = %d, AF_INET6 = %d)\n"
                         "   addr len  = %d (sockaddr_in = %d, "
                         "sockaddr_in6 = %d)\n",
                         sadr-&gt;sa_family,
                         AF_INET,
                         AF_INET6,
                         sadrLen,
                         sizeof( struct sockaddr_in ),
                         sizeof( struct sockaddr_in6 ) );
                         /*
                         ** Adrese özel bilgilerin gösterilmesi.
                         */
                         getnameinfo( sadr,
                                      sadrLen,
                                      hostBfr,
                                      sizeof( hostBfr ),
                                      servBfr,
                                      sizeof( servBfr ),
                                      NI_NUMERICHOST | NI_NUMERICSERV );
                         switch ( sadr-&gt;sa_family )
                         {
                            case AF_INET:   /* IPv4 adresi. */
                            {
                                struct sockaddr_in *p = (struct sockaddr_in*) sadr;
                                fprintf( stderr,
                                         "   sin_addr  = sin_family: %d\n"
                                         "               sin_addr:   %s\n"
                                         "               sin_port:   %s\n",
                                         p-&gt;sin_family,
                                         hostBfr,
                                         servBfr );
                                break;
                            }  /* IPv4 adresinin CASE sonu. */
                            case AF_INET6:   /* IPv6 adresi. */
                            {
                                struct sockaddr_in6 *p = (struct sockaddr_in6*) sadr;
                                fprintf( stderr,
                                         "   sin6_addr = sin6_family:   %d\n"
                                         "               sin6_addr:     %s\n"
                                         "               sin6_port:     %s\n"
                                         "               sin6_flowinfo: %d\n"
                                         "               sin6_scope_id: %d\n",
                                         p-&gt;sin6_family,
                                         hostBfr,
                                         servBfr,
                                         p-&gt;sin6_flowinfo,
                                         p-&gt;sin6_scope_id );
                                break;
                            }  /* IPv6 adresinin CASE sonu. */
                            default:   /* Buraya hiçbir zaman girilmez, fakat bütünlük için doldurulmuþtur. */
                            {
                                fprintf( stderr,
                                         "%s (line %d): ERROR - Unknown address "
                                         "family (%d).\n",
                                         pgmName,
                                         __LINE__,
                                         sadr-&gt;sa_family );
                                break;
                            }  /* DEFAULT case sonu(bilinmeyen adres ailesi). */
                          /* Adres ailesi için SWITCH sonu. */
                    }  /* Ayrýntýlý kip için IF sonu. */
                    /*
                    ** Ýstemciye zaman bilgisinin gönderilmesi.
                    */
                    wBytes = timeLen;
                    while ( wBytes &gt; 0 )
                    {
                        do
                        {
                            count = sendto( desc[ idx ].fd,
                                            timeStr,
                                            wBytes,
                                            0,
                                            sadr,        /* Adres &amp; adres uzunluðu   */
                                            sadrLen );   /* recvfrom() ile alýnan. */
                        } while ( ( count &lt; 0 ) &amp;&amp; ( errno == EINTR ) );
                        CHK( count );   /* Gerçekten bir hata olup olmadýðýnýn kontrolü. */
                        wBytes -= count;
                    }  /* Gönderilecek bir veri var ise WHILE sonu. */
                }  /* UDP veri bloðu kullanýlabilir ise ELSE sonu. */
                desc[ idx ].revents = 0;   /* Dönen olaylarýn temizlenmesi. */
            }  /* Her soket belirleyicisi için FOR sonu. */
        }  /* Sonsuz döngü sonu. */
    }  /* tod() sonu */
</pre> </td></tr></table></div></div><div class="sect4"><div> <h5 class="title"><a name="id241"></a>TCP Ýstemci Kodu </h5></div><p>TCP istemci kodu tod6tc.c (IPv6 TCP istemcisi) dosyasýnda bulunabilir. Kurduktan sonra, TCP istemcisi aþaðýdaki komut sözdizimi kullanýlarak baþlatýlabilir (tod6tc'nin çalýþtýrýlabilir bir dosya olduðu varsayýlýyor):  </p><p>
<div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">
tod6tc [-v] [-s scope_id] [host [service]]
</pre> </td></tr></table></div>
</p><p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0"><tr><td rowspan="2" align="center" valign="top" width="25"><img src="../images/xsl/note.png"></td><th>PARAMETRELER:</th></tr><tr><td colspan="2" align="left" valign="top"><p>Hizmeti saðlayan uzak düðümün bilgisayar adý veya IP adresi (IPv4 adresi veya IPv6 adresi olabilir). Varsayýlan "localhost"tur. </p><p> Baðlantý isteði yapýlan TCP hizmeti (veya iyi bilinen port numarasý). Varsayýlan "daytime"dýr. </p><p>Bu seçenek sadece IPv6 adresleri için anlamlýdýr, ve kapsam belirleyicisini ayarlamak için kullanýlmýþtýr (örneðin baðlantýnýn onaylandýðý að arayüzü). Varsayýlan "eth0"dýr. Eðer konak kapsamlý bir adres ise, bu seçenek yoksayýlabilir.  </p><p>Ayrýntýlý kipi açar. </p></td></tr></table></div>
    </p><p>TCP istemcinin tod6tc.c içindeki kaynak kodu aþaðýdadýr:
<div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">
/******************************************************************************
* Dosya: tod6tc.c
* Açýklama: TCP istemcisi için IPv6 uyumlu kaynak kodu barýndýrýr.
* Yazar: John Wenker, Sr. Yazýlým Mühendisi
*         Performance Technologies, San Diego, USA
******************************************************************************/
/*
** Sistem baþlýk dosyalarý.
*/
#include &lt;errno.h&gt;        /* errno bildirimi ve hata kodlarý.             */
#include &lt;net/if.h&gt;       /* if_nametoindex(3).                             */
#include &lt;netdb.h&gt;        /* getaddrinfo(3) ve ilgili tanýmlar.     */
#include &lt;netinet/in.h&gt;   /* sockaddr_in ve sockaddr_in6 tanýmlarý.      */
#include &lt;stdio.h&gt;        /* printf(3) .                               */
#include &lt;stdlib.h&gt;       /* exit(2).                                       */
#include &lt;string.h&gt;       /* Dizge iþleme ve hafýza metotlarý.      */
#include &lt;sys/socket.h&gt;   /* Soket metotlarý (socket(2), connect(2), etc). */
#include &lt;unistd.h&gt;       /* getopt(3), read(2), v.s.                       */
/*
** Sabitler ve makrolar.
*/
#define DFLT_HOST      "localhost"   /* Varsayýlan sunucu ismi.              */
#define DFLT_SCOPE_ID  "eth0"        /* Varsayýlan alan belirleyicisi.       */
#define DFLT_SERVICE   "daytime"     /* Varsayýlan hizmet ismi.             */
#define INVALID_DESC   -1            /* Geçersiz dosya (soket) belirleyicisi. */
#define MAXBFRSIZE     256           /* Uzak TOD'dan okunacak en fazla tampon boyutu.    */
#define VALIDOPTS      "s:v"         /* Geçerli komut seçenekleri.            */
/*
** Tip tanýmlarý (kullanýlabilirlik için).
*/
typedef enum { false = 0, true } boolean;
typedef struct sockaddr_in       sockaddr_in_t;
typedef struct sockaddr_in6      sockaddr_in6_t;
/*
** Ýç yardým metotlarý için taslaklar.
*/
static int  openSckt( const char   *host,
                      const char   *service,
                      unsigned int  scopeId );
static void tod( int sckt );
/*
** Genel(sadece bu dosya için) veri nesneleri.
*/
static const char *pgmName;           /* Uygulama ismi (w/o dizini). */
static boolean     verbose = false;   /* Ayrýntýlý kip.                 */
/*
** Makro kullanýmý.
*/
#define USAGE
        {
           fprintf( stderr,
                    "Usage: %s [-v] [-s scope_id] [host [service]]\n",
                    pgmName );
           exit( 127 );
        }  /* Makro kullanýmý sonu. */
/*
** Bu "makro" (aslýnda bir metot olmasýna raðmen) genel olarak Dr. V. Vinge'nin CHK() 
** makrosuna (sunucu koduna bakýn) dayanmaktadýr. Status parametresi
** hata durumunda -1 deðer dönen mantýksal ifade gösteren klasik sistem çaðrýlarýndan
** biridir. Eðer bir sistem hatasý oluþursa, stderr'e bir uyarý
** yazýlýr. Sistem çaðrýsýnýn baþarýlý olmasý veya hata oluþmasý durumunda mantýksal 
** bir deðer döndürülür.
**
** Örnek: if ( !SYSCALL( "write",
**                         count = write( fd, bfr, size ) ) )
**          {
**             // Hata iþleniyor... fakat SYSCALL() stderr'da bir hata mesajý 
**             // gösterdi bile.
**          }
*/
static __inline boolean SYSCALL( const char *syscallName,
                                 int         lineNbr,
                                 int         status )
{
   if ( ( status == -1 ) &amp;&amp; verbose )
   {
      fprintf( stderr,
               "%s (line %d): System call failed ('%s') - %s.\n",
               pgmName,
               lineNbr,
               syscallName,
               strerror( errno ) );
   }
   return status != -1;   /* Sistem çaðrýsý baþarýlý olursa true deðer alýr. */
}  /* End SYSCALL() */
/******************************************************************************
* Metot: main
*
* Açýklama:
*    Uzak bir zaman hizmetine baðlanýr ve stdout'a uzak düðümün TOD'u
*    yazar.
*
* Parametre:
*    Main() uygulamasýna geçirilen klasik argc &amp; argv parametreleri.
*
* dönüþ deðeri:
*    Bu metot daima sýfýr deðerini döndürür.
******************************************************************************/
int main( int   argc,
          char *argv[ ] )
{
   const char   *host     = DFLT_HOST;
   int           opt;
   int           sckt;
   unsigned int  scopeId  = if_nametoindex( DFLT_SCOPE_ID );
   const char   *service  = DFLT_SERVICE;
   /*
   ** Uygulama ismine karar verelim (w/o dizin öneki).
   */
   pgmName = (const char*) strrchr( argv[ 0 ], '/' );
   pgmName = pgmName == NULL  ?  argv[ 0 ]  :  pgmName+1;
   /*
   ** Komut satýrý seçenekleri iþleyelim.
   */
   opterr = 0;   /* "invalid option" hata mesajýný kapatalým. */
   while ( ( opt = getopt( argc, argv, VALIDOPTS ) ) != -1 )
   {
      switch ( opt )
      {
         case 's':   /* Alan belirleyicisi (IPv6 çözümü(kluge)). */
         {
            scopeId = if_nametoindex( optarg );
            if ( scopeId == 0 )
            {
               fprintf( stderr,
                        "%s: Unknown network interface (%s).\n",
                        pgmName,
                        optarg );
               USAGE;
            }
            break;
         }
         case 'v':   /* Ayrýntýlý kip. */
         {
            verbose = true;
            break;
         }
         default:
         {
            USAGE;
         }
      }  /* Komut seçeneði için SWITCH sonu. */
   } /* Komut seçenekleri iþlenmesi WHILE sonu. */
   /*
   ** Komut parametrelerinin iþlenmesi. Üstteki döngünün sonunda, optind 
   ** seçenek olmayan ilk argv elementidir.
   */
   switch ( argc - optind )
   {
      case 2:   /* Hem düðüm hem de hizmet komut satýrýnda belirtilmiþtir. */
     {
          service = argv[ optind + 1 ];
          /***** Baþarýsýz *****/
      }
      case 1:   /* Host is specified on the command line. */
      {
          host = argv[ optind ];
          /***** Baþarýsýz *****/
      }
      case 0:   /* Varsayýlan düðüm ve hizmetin kullanýlmasý. */
      {
          break;
      }
      default:
      {
         USAGE;
      }
   }  /* komut parametreleri için SWITCH sonu. */
   /*
   ** Belirtilen düðüm ve hizmete bir baðlantý oluþturalým.
   **
   ** Aþaðýdaki üç durumdan her birinin gerçekleþmesi olasýdýr, burada
   ** alan belirleyicisi çözümlenmemiþ durumdadýr.
   **    1) Varsayýlan að arayüzü bir sebepten dolayý tanýnmýyor olabilir.
   **    2) Komut satýrýnda -s seçeneði kullanýlmamýþtýr.
   **    3) Komut satýrýnda IPv6 kapsamlý adres belirtilmemiþ olabilir.
   ** Eðer yukarýdaki üç durumla karþýlaþýlýrsa, bu yüzden sadece IPv4 soketi
   ** açýlabilir (Ipv6 soketleri için uygun kapsam adresi ayarlanmamýþsa connect(2) 
   ** baþarýsýz olur).
   */
  if ( ( sckt = openSckt( host,
                           service,
                           scopeId ) ) == INVALID_DESC )
   {
      fprintf( stderr,
               "%s: Sorry... a connection could not be established.\n",
               pgmName );
      exit( 1 );
   }
   /*
   ** Uzak zaman bilgisinin alýnmasý.
   */
   tod( sckt );
   /*
   ** Baðlantýyý kapatýn ve sonlandýrýn.
   */
   (void) SYSCALL( "close",
                   __LINE__,
                   close( sckt ) );
   return 0;
}  /* main() sonu */
/******************************************************************************
* Metot: openSckt
*
* Açýklama:
*    Uzak sunucuya bir TCP baðlantýsý kurar. Getaddrinfo(3) arama metotlarýný
*    gerçekleþtirmek için kullanýlmaktadýr ve çoklu adres kayýtlarý döndürebilir
*    (örneðin addrinfo yapýsýndan kayýtlarýn listesi). Metot listeyi gezer ve
*    uzak sunucuya bir baðlantý oluþturmaya çalýþýr. Metot bir baðlantý kurulduktan
*    veya listedeki bütün kayýtlar iþlendikten sonra sonlanýr.
*
* Parametreler:
*    host    - Uzak sunucunun sistem  adý veya IP adresini(IPv4 veya Ipv6) gösteren 
*              dizgeye iþaretçi.
*    service &#8211; Hizmet adý veya iyi bilinen port numarasýný gösteren dizgeye iþaretçi. 
*    scopeId &#8211; Sadece Ipv6 soketleri için geçerlidir. Baðlantý kurulacak olan að a-
*              rayüzüne karþýlýk gelen iþaret. Bu parametre Ipv4 soketleri için veya
*              düðümde belirtilen IPv6 kapsamlý adresler için ihmal edilmektedir
*              (örneðin kapsam adresi ile arttýrýlmýþ iki nokta üst üsteli 
*              onaltýlýk að adresi).
*
* Dönüþ deðeri:
*    Baðlantý için bir soket açýklayýcýsý döndürür, veya bütün adres kayýtlarý iþlenirse 
*    ve bir baðlantý kurulamazsa INVALID_DESC döndürür.
******************************************************************************/
static int openSckt( const char   *host,
                     const char   *service,
                     unsigned int  scopeId )
{
   struct addrinfo *ai;
   int              aiErr;
   struct addrinfo *aiHead;
   struct addrinfo  hints;
   sockaddr_in6_t  *pSadrIn6;
   int              sckt;
   /*
   ** Getaddrinfo(3) için 'hints' yapýsýný baþlatýr.
   **
   ** Düðüm ve hizmetler için hem IPv4 hem Ipv6 adres kayýtlarý döndürmesi saðlayarak 
   ** 'ai_family' alanýnýn PF_UNSPEC'e ayarlanmýþ olduðundan emin olun. Çoðu zaman
   ** kullanýcý  baðlantýnýn IPv4 baðlantýsý mý IPv6 baðlantýsý mý olduðuna dikkat 
   ** etmeyecektir; kullanýcý sadece uzak düðüme veri göndermek istemektedir ve bunun 
   ** nasýl yapýlacaðý ile ilgilenmez. Fakat bazen kullanýcý özel olarak kullanýlacak 
   ** soket tipini belirtmek isteyebilir. Bu okuyucuya komut satýrýna kullanýcýya IP 
   ** iletiþim kuralýný seçmesine izin veren bir seçenek koymasý hakkýnda fikir 
   ** verebilir, ve daha sonra adres listesi iþlenmelidir(Bu o kadar zor deðil).
   */
   memset( &amp;hints, 0, sizeof( hints ) );
   hints.ai_family   = PF_UNSPEC;     /* IPv4 veya IPv6 kayýtlarý (önemli deðil). */
   hints.ai_socktype = SOCK_STREAM;   /* Baðlantý temelli byte akýþý.   */
   hints.ai_protocol = IPPROTO_TCP;   /* Sadece TCP taþýma katmaný iletiþim kuralý. */
   /*
   ** Düðüm ve hizmet bilgisini arama.
   */
   if ( ( aiErr = getaddrinfo( host,
                               service,
                               &amp;hints,
                               &amp;aiHead ) ) != 0 )
   {
      fprintf( stderr,
               "%s (line %d): ERROR - %s.\n",
               pgmName,
               __LINE__,
               gai_strerror( aiErr ) );
      return INVALID_DESC;
   }
   /*
   ** Bir baðlantý açmak için listeyi gezin. Bir baðlantý kurulana kadar
   ** veya liste sonlanana kadar devam edin.
   */
   for ( ai = aiHead,   sckt = INVALID_DESC;
         ( ai != NULL ) &amp;&amp; ( sckt == INVALID_DESC );
         ai = ai-&gt;ai_next )
   {
      /*
      ** IPv6 çözümü. Scope ID'nin ayarlanmýþ olduðundan emin olun.
      */
      if ( ai-&gt;ai_family == PF_INET6 )
      {
         pSadrIn6 = (sockaddr_in6_t*) ai-&gt;ai_addr;
         if ( pSadrIn6-&gt;sin6_scope_id == 0 )
         {
            pSadrIn6-&gt;sin6_scope_id = scopeId;
         }  /*  scope ID gönderilmemiþse iþlemi IF sonu. */
      }  /* IPv6 çözümü sonu. */
      /*
      ** Uzak düðümün adres bilgisinin gösterilmesi.
      */
      if ( verbose )
      {
         /*
         ** Düðüm ve hizmet için geçici dizge tamponu.
         */
         char hostBfr[ NI_MAXHOST ];
         char servBfr[ NI_MAXSERV ];
         /*
         ** Alýnan adres bilgisinin gösterilmesi. Ýlk önce yaygýn olanlarla (iletiþim 
         ** kuralý baðýmsýz) baþlayýn.
         */
         fprintf( stderr,
                  "Address info:\n"
                  "   ai_flags     = 0x%02X\n"
                  "   ai_family    = %d (PF_INET = %d, PF_INET6 = %d)\n"
                  "   ai_socktype  = %d (SOCK_STREAM = %d, SOCK_DGRAM = %d)\n"
                  "   ai_protocol  = %d (IPPROTO_TCP = %d, IPPROTO_UDP = %d)\n"
                  "   ai_addrlen   = %d (sockaddr_in = %d, "
                  "sockaddr_in6 = %d)\n",
                  ai-&gt;ai_flags,
                  ai-&gt;ai_family,
                  PF_INET,
                  PF_INET6,
                  ai-&gt;ai_socktype,
                  SOCK_STREAM,
                  SOCK_DGRAM,
                  ai-&gt;ai_protocol,
                  IPPROTO_TCP,
                  IPPROTO_UDP,
                  ai-&gt;ai_addrlen,
                  sizeof( struct sockaddr_in ),
                  sizeof( struct sockaddr_in6 ) );
         /*
         ** Ýletiþim kuralýna özgü adreslerin gösterilmesi.
         */
         getnameinfo( ai-&gt;ai_addr,
                      ai-&gt;ai_addrlen,
                      hostBfr,
                      sizeof( hostBfr ),
                      servBfr,
                      sizeof( servBfr ),
                      NI_NUMERICHOST | NI_NUMERICSERV );
         switch ( ai-&gt;ai_family )
         {
            case PF_INET:   /* IPv4 adres kaydý. */
            {
               sockaddr_in_t *pSadrIn = (sockaddr_in_t*) ai-&gt;ai_addr;
               fprintf( stderr,
                        "   ai_addr      = sin_family: %d (AF_INET = %d, "
                        "AF_INET6 = %d)\n"
                        "                  sin_addr:   %s\n"
                        "                  sin_port:   %s\n",
                        pSadrIn-&gt;sin_family,
                        AF_INET,
                        AF_INET6,
                        hostBfr,
                        servBfr );
               break;
            }  /* End CASE of IPv4 record. */
            case PF_INET6:   /* IPv6 adres kaydý. */
            {
               pSadrIn6 = (sockaddr_in6_t*) ai-&gt;ai_addr;
               fprintf( stderr,
                        "   ai_addr      = sin6_family:   %d (AF_INET = %d, "
                        "AF_INET6 = %d)\n"
                        "                  sin6_addr:     %s\n"
                        "                  sin6_port:     %s\n"
                        "                  sin6_flowinfo: %d\n"
                        "                  sin6_scope_id: %d\n",
                        pSadrIn6-&gt;sin6_family,
                        AF_INET,
                        AF_INET6,
                        hostBfr,
                        servBfr,
                        pSadrIn6-&gt;sin6_flowinfo,
                        pSadrIn6-&gt;sin6_scope_id );
               break;
            }  /* IPv6 kaydý için CASE sonu. */
            default:   /* Buraya asla girilmez fakat bütünlük saðlamasý için doldurulmuþtur. */
            {
               fprintf( stderr,
                        "%s (line %d): ERROR - Unknown protocol family (%d).\n",
                        pgmName,
                        __LINE__,
                        ai-&gt;ai_family );
               break;
            }  /* DEFAULT CASE sonu (bilinmeyen iletiþim kuralý ailesi). */
         }  /* Ýletiþim kuralý ailesi için SWITCH sonu. */
      }  /* Ayrýntýlý kip IF sonu. */
      /*
      ** Bir soket oluþturun.
      */
      if ( !SYSCALL( "socket",
                     __LINE__,
                     sckt = socket( ai-&gt;ai_family,
                                    ai-&gt;ai_socktype,
                                    ai-&gt;ai_protocol ) ) )
      {
         sckt = INVALID_DESC;
         continue;   /* Listedeki sýradaki adres kaydýný deneyin. */
      }
      /*
      ** Uzak düðüme baðlanýn.
      */
      if ( !SYSCALL( "connect",
                     __LINE__,
                     connect( sckt,
                              ai-&gt;ai_addr,
                              ai-&gt;ai_addrlen ) ) )
      {
         (void) close( sckt );   /* Burada SYSCALL() tekrar kullanýlabilir, fakat niçin? */
         sckt = INVALID_DESC;
         continue;   /* Listedeki sýradaki adres kaydýný deneyin. */
      }
   }  /* Getaddrinfo(3)'dan dönen her adres kaydý için FOR sonu. */
   /*
   ** Temizleme ve dönüþ
   */
   freeaddrinfo( aiHead );
   return sckt;
}  /* openSckt() sonu */
/******************************************************************************
* Metot: tod
*
* Açýklama:
*    Uzak sunucudan zaman bilgisinin alýnmasý ve bunun stdout a yazýlmasý.
*
* Parametreler:
*    sckt &#8211; Baðlantý için soket belirleyicisi.
*
* Dönüþ deðeri: Yok.
******************************************************************************/
static void tod( int sckt )
{
   char bfr[ MAXBFRSIZE+1 ];
   int  inBytes;
   /*
   ** Ýstemci hiçbir þey yollamaz, bu yüzden baðlantýnýn yazma kýsmýný kapatalým.
   */
   if ( !SYSCALL( "shutdown",
                  __LINE__,
                  shutdown( sckt, SHUT_WR ) ) )
   {
      return;
   }
   /*
   ** Uzak sunucudan zaman bilgisinin okunmasý.
   */
   do
   {
      if ( !SYSCALL( "read",
                     __LINE__,
                     inBytes = read( sckt,
                                     bfr,
                                     MAXBFRSIZE ) ) )
      {
         return;
      }
      bfr[ inBytes ] = '\0';   /* Alýnan dizgenin null ile sonlandýrýlmasý. */
      fputs( bfr, stdout );    /* Dosya sonu(EOF) ise boþ dizge(inBytes == 0).  */
   } while ( inBytes &gt; 0 );
   fflush( stdout );
}  /* tod() sonu */
</pre> </td></tr></table></div></p></div><div class="sect4"><div> <h5 class="title"><a name="id341"></a>UDP Ýstemci Kodu</h5></div><p>UDP istemci kodu tod6uc.c (UDP Ýstemci Kodu) dosyasýnda bulunabilir. Bu kodun büyük bir kýsmý TCP  istemci kodundan alýnmýþtýr (ve aslýnda bundan türetilmiþtir), fakat bütünlük açýsýndan bu NASIL belgesine eklenmiþtir. Uygulama derlendikten sonra UDP istemcisi aþaðýdaki komut sözdizimi ile çalýþtýrýlabilir ( tod6uc'un çalýþtýrýlabilir olduðu kabul edilmektedir):
 
<div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">tod6uc [-v] [-s scope_id] [host [service]]</pre> </td></tr></table></div>
</p><p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0"><tr><td rowspan="2" align="center" valign="top" width="25"><img src="../images/xsl/note.png"></td><th>PARAMETRELER:</th></tr><tr><td colspan="2" align="left" valign="top"><p>Hizmeti saðlayan uzak düðümün bilgisayar adý veya IP adresi (IPv4 veya Ipv6). Varsayýlan &#8220;localhost&#8221;tur.</p><p>Gönderilecek veri iletieri için UDP hizmeti (veya iyi bilinen port numarasý). Varsayýlan  "daytime"dýr. </p><p>Bu seçenek sadece IPv6 adresleri için anlamlýdýr, ve alan belirleyicisini belirtmek için kullanýlýr   (örneðin gönderilecek veri bloklarýnýn kullanacaðý að arayüzü). Varsayýlan "eth0"dýr. Eðer konak kapsamlý bir adrese sahip ise bu seçenek yoksayýlýr.</p><p>Ayrýntýlý kipi açar. </p></td></tr></table></div>
</p><p>tod6uc.c dosyasýnda bulunan UDP istemci kaynak kodu aþaðýdadýr:
    <div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">/******************************************************************************
* Dosya: tod6uc.c
* Açýklama: Ipv6 uyumlu UDP istemci için kaynak kodu bulundurur.
* Yazar: John Wenker, Sr. Yazýlým Mühendisi
*         Performance Technologies, San Diego, USA
******************************************************************************/
/*
** Sistem baþlýk dosyalarý.
*/
#include &lt;errno.h&gt;        /* errno bildirimi ve hata kodlarý.               */
#include &lt;net/if.h&gt;       /* if_nametoindex(3).                             */
#include &lt;netdb.h&gt;        /* getaddrinfo(3) ve ilgili tanýmlar.     */
#include &lt;netinet/in.h&gt;   /* sockaddr_in ve sockaddr_in6 tanýmlarý.      */
#include &lt;stdio.h&gt;        /* printf(3) .                               */
#include &lt;stdlib.h&gt;       /* exit(2).                                       */
#include &lt;string.h&gt;       /* Dizge iþleme ve hafýza metotlarý.      */
#include &lt;sys/socket.h&gt;   /* Soket metotlarý (socket(2), connect(2), vs.). */
#include &lt;unistd.h&gt;       /* getopt(3), recvfrom(2), sendto(2), vs.        */
/*
** Sabitler ve makrolar.
*/
#define DFLT_HOST      "localhost"   /* Varsayýlan sunucu ismi.              */
#define DFLT_SCOPE_ID  "eth0"        /* Varsayýlan alan belirleyicisi.         */
#define DFLT_SERVICE   "daytime"     /* Varsayýlan hizmet ismi.             */
#define INVALID_DESC   -1            /* Geçesiz dosya(soket) tanýmlayýcýsý. */
#define MAXBFRSIZE     256           /* Uzak TOD'u okumak için en çok tampon büyüklüðü.    */
#define VALIDOPTS      "s:v"         /* Geçerli komut seçenekleri.            */
/*
** Tür tanýmlarý (kullanýlabilirlik için).
*/
typedef enum { false = 0, true } boolean;
typedef struct sockaddr_in       sockaddr_in_t;
typedef struct sockaddr_in6      sockaddr_in6_t;
/*
** Dahili yardýmcý metotlar için taslaklar.
*/
static int  openSckt( const char   *host,
                      const char   *service,
                      unsigned int  scopeId );
static void tod( int sckt );
/*
** Genel (sadece bu dosya için) veri nesneleri.
*/
static const char *pgmName;           /* Uygulama ismi (w/o dizini). */
static boolean     verbose = false;   /* Ayrýntýlý kip.                 */
/*
** Makro kullanýmý.
*/
#define USAGE                                                            \
        {                                                                \
           fprintf( stderr,                                              \
                    "Usage: %s [-v] [-s scope_id] [host [service]]\n",   \
                    pgmName );                                           \
           exit( 127 );                                                  \
        }  /* USAGE makro sonu. */
/*
** Bu "makro" (aslýnda bir metot olmasýna raðmen) genel olarak Dr. V. Vinge'nin CHK() 
** makrosuna (sunucu koduna bakýn) dayanmaktadýr. Status parametresi
** hata durumunda -1 deðer dönen mantýksal ifade gösteren klasik sistem çaðrýlarýndan
** biridir. Eðer bir sistem hatasý oluþursa, stderr'e bir uyarý
** yazýlýr. Sistem çaðrýsýnýn baþarýlý olmasý veya hata oluþmasý durumunda mantýksal 
** bir deðer döndürülür.
** Example: if ( !SYSCALL( "write",
**                         count = write( fd, bfr, size ) ) )
**          {
**             // Hata iþleniyor... fakat SYSCALL() stderr'da bir hata mesajý 
**             // gösterdi bile.

**          }
*/
static __inline boolean SYSCALL( const char *syscallName,
                                 int         lineNbr,
                                 int         status )
{
   if ( ( status == -1 ) &amp;&amp; verbose )
   {
      fprintf( stderr,
               "%s (line %d): System call failed ('%s') - %s.\n",
               pgmName,
               lineNbr,
               syscallName,
               strerror( errno ) );
   }
   return status != -1;   /*  Sistem çaðrýsý baþarýlý olursa true deðer alýr.*/
}  /* End SYSCALL() */
/******************************************************************************
* Metot: main
*
* Açýklama:
*    Uzak bir zaman hizmetine baðlanýr ve stdout'a uzak düðümün TOD'u
*    yazar.
*
* Parametre:
*    Main() uygulamasýna geçirilen klasik argc &amp; argv parametreleri.
*
* dönüþ deðeri:
*    Bu metot daima sýfýr deðerini döndürür.
******************************************************************************/
int main( int   argc,
          char *argv[ ] )
{
   const char   *host     = DFLT_HOST;
   int           opt;
   int           sckt;
   unsigned int  scopeId  = if_nametoindex( DFLT_SCOPE_ID );
   const char   *service  = DFLT_SERVICE;
   /*
   ** Uygulama ismine karar verelim (w/o dizin öneki).
   */
   pgmName = (const char*) strrchr( argv[ 0 ], '/' );
   pgmName = pgmName == NULL  ?  argv[ 0 ]  :  pgmName+1;
   /*
   ** Komut satýrý seçenekleri iþleyelim.
   */
   opterr = 0;   /* "invalid option" hata mesajýný kapatalým. */
   while ( ( opt = getopt( argc, argv, VALIDOPTS ) ) != -1 )
   {
      switch ( opt )
      {
         case 's':   /* Alan belirleyicisi (IPv6 çözümü). */
         {
            scopeId = if_nametoindex( optarg );
            if ( scopeId == 0 )
            {
               fprintf( stderr,
                        "%s: Unknown network interface (%s).\n",
                        pgmName,
                        optarg );
               USAGE;
            }
            break;
         }
         case 'v':   /* Ayrýntýlý kip. */
         {
            verbose = true;
            break;
         }
         default:
         {
            USAGE;
         }
      }  /* Komut seçeneði için SWITCH sonu. */
   } /* Komut seçenekleri iþlenmesi WHILE sonu. */
   /*
   ** Komut parametrelerinin iþlenmesi. Üstteki döngünün sonunda, optind 
   ** seçenek olmayan ilk argv elementidir.
   */
   switch ( argc - optind )
   {
      case 2:   /* Hem düðüm hem de hizmet komut satýrýnda belirtilmiþtir. */
      {
          service = argv[ optind + 1 ];
          /***** Baþarýsýz *****/
      }
      case 1:   /* Komut satýrýnda belirtilen konak. */
      {
          host = argv[ optind ];
          /***** Baþarýsýz *****/
      }
      case 0:   /* Varsayýlan düðüm ve hizmetin kullanýlmasý. */
      {
          break;
      }
      default:
      {
         USAGE;
      }
   }  /* komut parametreleri için SWITCH sonu. */
   /*
   ** Belirtilen düðüm ve hizmete baðlantý açalým.
   **
   ** Aþaðýdaki üç durumdan herbirinin gerçekleþmesi olasýdýr, burada
   ** alan belirleyicisi çözümlenmemiþ durumdadýr.
   **    1) Varsayýlan að arayüzü bir sebepten dolayý tanýnmýyor olabilir.
   **    2) Komut satýrýnda -s seçeneði kullanýlmamýþtýr.
   **    3) Komut satýrýnda IPv6 kapsamlý adres belirtilmemiþ olabilir.
   ** Eðer yukarýdaki üç durumla karþýlaþýlýrsa, bu yüzden sadece IPv4 yuvasý 
   ** açýlabilir (Ipv6 yuvalarý için uygun kapsam adresi ayarlanmamýþsa connect(2) 
   ** baþarýsýz olur).
  */
   if ( ( sckt = openSckt( host,
                          service,
                           scopeId ) ) == INVALID_DESC )
   {
      fprintf( stderr,
               "%s: Sorry... a connectionless socket could "
               "not be set up.\n",
               pgmName );
      exit( 1 );
   }
   /*
   **  Uzak zaman bilgisinin alýnmasý.
   */
   tod( sckt );
   /*
   ** Baðlantýyý kapatýn ve sonlandýrýn.
   */
   (void) SYSCALL( "close",
                   __LINE__,
                   close( sckt ) );
   return 0;
}  /* End main() */
/******************************************************************************
* Metot: openSckt
*
* Açýklama:
*    Uzak sunucuya bir TCP baðlantýsý oluþturur. Getaddrinfo(3) arama metotlarýný
*    gerçekleþtirmek için kullanýlmaktadýr ve çoklu adres kayýtlarý döndürebilir
*    (örneðin addrinfo yapýsýndan kayýtlarýn listesi). Metot listeyi gezer ve
*    uzak sunucuya bir baðlantý oluþturmaya çalýþýr. Metot bir baðlantý kurulduktan
*    veya listedeki bütün kayýtlar iþlendikten sonra sonlanýr.
*
* Parametreler:
*    host    - Uzak sunucunun sistem  adý veya IP adresini(IPv4 veya Ipv6) gösteren 
*              dizgeye iþaretçi.
*    service &#8211; Hizmet adý veya iyi bilinen kapý numarasýný gösteren dizgeye iþaretçi. 
*    scopeId &#8211; Sadece Ipv6 soketleri için geçerlidir. Baðlantý kurulacak olan að 
*              arayüzüne karþýlýk gelen iþaret. Bu parametre Ipv4 soketleri için veya
*              düðümde belirtilen IPv6 kapsamlý adresler için ihmal edilmektedir
*              (örneðin kapsam adresi ile arttýrýlmýþ iki nokta üst üsteli 
*              onaltýlýk að adresi).
*
* Dönüþ deðeri:
*    Baðlantý için bir soket açýklayýcýsý döndürür, veya bütün adres kayýtlarý iþlenirse 
*    ve bir baðlantý kurulamazsa INVALID_DESC döndürür.
******************************************************************************/
static int openSckt( const char   *host,
                     const char   *service,
                     unsigned int  scopeId )
{
   struct addrinfo *ai;
   int              aiErr;
   struct addrinfo *aiHead;
   struct addrinfo  hints;
   sockaddr_in6_t  *pSadrIn6;
   int              sckt;
   /*
   ** Getaddrinfo(3) için 'hints' yapýsýný baþlatýr.
   **
   ** Düðüm ve hizmetler için hem IPv4 hem IPv6 adres kayýtlarýný döndürmesini saðlayarak 
   ** 'ai_family' alanýnýn PF_UNSPEC'e ayarlanmýþ olduðundan emin olun. Çoðu zaman
   ** kullanýcý  baðlantýnýn IPv4 baðlantýsý mý IPv6 baðlantýsý mý olduðuna dikkat 
   ** etmeyecektir; kullanýcý sadece uzak düðüme veri göndermek istemektedir ve bunun 
   ** nasýl yapýlacaðý ile ilgilenmez. Fakat bazen kullanýcý özel olarak kullanýlacak 
   ** soket tipini belirtmek isteyebilir. Bu okuyucuya komut satýrýnda kullanýcýya IP 
   ** iletiþim kuralýný seçmesine izin veren bir seçenek koymasý hakkýnda fikir 
   ** verebilir, ve daha sonra adres listesi iþlenmelidir(Bu o kadar zor deðil).
   */
   memset( &amp;hints, 0, sizeof( hints ) );
   hints.ai_family   = PF_UNSPEC;     /* IPv4 veya IPv6 kayýtlarý (önemli deðil). */
   hints.ai_socktype = SOCK_DGRAM;    /* Baðlantý temelli iletiþim.      */
   hints.ai_protocol = IPPROTO_UDP;   /* Sadece UDP taþýma katmaný iletiþim kuralý. */
   /*
   ** Konak ve hizmet bilgisini arama.
   */
   if ( ( aiErr = getaddrinfo( host,
                               service,
                               &amp;hints,
                               &amp;aiHead ) ) != 0 )
   {
      fprintf( stderr,
               "%s (line %d): ERROR - %s.\n",
               pgmName,
               __LINE__,
               gai_strerror( aiErr ) );
      return INVALID_DESC;
   }
   /*
   ** Bir baðlantý açmak için listeyi gezin. Bir baðlantý kurulana kadar
   ** veya liste sonlanana kadar devam edin.
   */
   for ( ai = aiHead,   sckt = INVALID_DESC;
         ( ai != NULL ) &amp;&amp; ( sckt == INVALID_DESC );
         ai = ai-&gt;ai_next )
   {
      /*
      ** IPv6 çözümü. Scope ID'nin ayarlanmýþ olduðundan emin olun.
      */
      if ( ai-&gt;ai_family == PF_INET6 )
      {
         pSadrIn6 = (sockaddr_in6_t*) ai-&gt;ai_addr;
         if ( pSadrIn6-&gt;sin6_scope_id == 0 )
         {
            pSadrIn6-&gt;sin6_scope_id = scopeId;
         }  /* scope ID atanmamýþ ise þartý için IF sonu. */
      }  /* IPv6 çözümü sonu. */
      /*
      ** Uzak düðümün adres bilgisinin gösterilmesi.
      */
      if ( verbose )
      {
         /*
         ** Konak ve hizmet için geçici dizge tamponu.
         */
         char hostBfr[ NI_MAXHOST ];
         char servBfr[ NI_MAXSERV ];
         /*
         ** Alýnan adres bilgisinin gösterilmesi. Ýlk önce yaygýn olanlarla (iletiþim 
         ** kuralý baðýmsýz) baþlayýn.
         */
         fprintf( stderr,
                  "Address info:\n"
                  "   ai_flags     = 0x%02X\n"
                  "   ai_family    = %d (PF_INET = %d, PF_INET6 = %d)\n"
                  "   ai_socktype  = %d (SOCK_STREAM = %d, SOCK_DGRAM = %d)\n"
                  "   ai_protocol  = %d (IPPROTO_TCP = %d, IPPROTO_UDP = %d)\n"
                  "   ai_addrlen   = %d (sockaddr_in = %d, "
                  "sockaddr_in6 = %d)\n",
                  ai-&gt;ai_flags,
                  ai-&gt;ai_family,
                  PF_INET,
                  PF_INET6,
                  ai-&gt;ai_socktype,
                  SOCK_STREAM,
                  SOCK_DGRAM,
                  ai-&gt;ai_protocol,
                  IPPROTO_TCP,
                  IPPROTO_UDP,
                  ai-&gt;ai_addrlen,
                  sizeof( struct sockaddr_in ),
                  sizeof( struct sockaddr_in6 ) );

         /*
         ** Ýletiþim kuralýna özgü adreslerin gösterilmesi.
         */
         getnameinfo( ai-&gt;ai_addr,
                      ai-&gt;ai_addrlen,
                      hostBfr,
                      sizeof( hostBfr ),
                      servBfr,
                      sizeof( servBfr ),
                      NI_NUMERICHOST | NI_NUMERICSERV );
         switch ( ai-&gt;ai_family )
         {
            case PF_INET:   /* IPv4 adres kaydý. */
            {
               sockaddr_in_t *pSadrIn = (sockaddr_in_t*) ai-&gt;ai_addr;
               fprintf( stderr,
                        "   ai_addr      = sin_family: %d (AF_INET = %d, "
                        "AF_INET6 = %d)\n"
                        "                  sin_addr:   %s\n"
                        "                  sin_port:   %s\n",
                        pSadrIn-&gt;sin_family,
                        AF_INET,
                        AF_INET6,
                        hostBfr,
                        servBfr );
               break;
            }  /* IPv4 adres kaydý sonu. */
            case PF_INET6:   /* IPv6 adres kaydý. */
            {
               pSadrIn6 = (sockaddr_in6_t*) ai-&gt;ai_addr;
               fprintf( stderr,
                        "   ai_addr      = sin6_family:   %d (AF_INET = %d, "
                        "AF_INET6 = %d)\n"
                        "                  sin6_addr:     %s\n"
                        "                  sin6_port:     %s\n"
                        "                  sin6_flowinfo: %d\n"
                        "                  sin6_scope_id: %d\n",
                        pSadrIn6-&gt;sin6_family,
                        AF_INET,
                        AF_INET6,
                        hostBfr,
                        servBfr,
                        pSadrIn6-&gt;sin6_flowinfo,
                        pSadrIn6-&gt;sin6_scope_id );
               break;
            }  /* IPv6 kaydýnýn sonu. */
            default:   /* Buraya asla girilmez fakat bütünlük saðlamasý için doldurulmuþtur. */
            {
               fprintf( stderr,
                        "%s (line %d): ERROR - Unknown protocol family (%d).\n",
                        pgmName,
                        __LINE__,
                        ai-&gt;ai_family );
               break;
            }  /* DEFAULT CASE sonu (bilinmeyen iletiþim kuralý ailesi). */
         }  /* Ýletiþim kuralý ailesi için SWITCH sonu. */
      }  /* Ayrýntýlý kip IF sonu. */
      /*
      ** Bir soket yaratalým.
      */
      if ( !SYSCALL( "socket",
                     __LINE__,
                     sckt = socket( ai-&gt;ai_family,
                                    ai-&gt;ai_socktype,
                                    ai-&gt;ai_protocol ) ) )
      {
         sckt = INVALID_DESC;
         continue;   /* Listedeki sýradaki adres kaydýný deneyin. */
      }
      /*
      ** Bu sokette uzak konak için hedef belirlenir. Bu soket
      ** sadece belirlenmiþ konak ile iletiþim kurmak içindir.
      */
      if ( !SYSCALL( "connect",
                     __LINE__,
                     connect( sckt,
                              ai-&gt;ai_addr,
                              ai-&gt;ai_addrlen ) ) )
      {
         (void) close( sckt );   /* Burada SYSCALL() tekrar kullanýlabilir, fakat niçin? */
         sckt = INVALID_DESC;
         continue;   /* Listedeki sýradaki adres kaydýný deneyin. */
      }
   }  /* Getaddrinfo(3)'dan dönen her adres kaydý için FOR sonu. */
   /*
   ** Temizleme ve dönüþ.
   */
   freeaddrinfo( aiHead );
   return sckt;
}  /* openSckt() sonu */
/******************************************************************************
* Metot: tod
*
* Açýklama:
*    Uzak sunucudan zaman bilgisinin alýnmasý ve bunun stdout a yazýlmasý.
*
* Parametreler:
*    sckt &#8211; Baðlantý için soket belirleyicisi.
*
* Dönüþ deðeri: Yok.
******************************************************************************/
static void tod( int sckt )
{
   char bfr[ MAXBFRSIZE+1 ];
   int  inBytes;
   /*
   ** Sunucuyu uyandýrmak için bir veri bloðu yollayýn. Ýçeriði önemli deðil,
   ** fakat TOD bilgisini istediðimizi belirten bir þey yollanmalýdýr.
   */
   if ( !SYSCALL( "write",
                  __LINE__,
                  write( sckt, "Are you there?", 14 ) ) )
   {
      return;
   }
   /*
   ** Uzak konaktandan zaman bilgisinin okunmasý.
   */
   if ( !SYSCALL( "read",
                  __LINE__,
                  inBytes = read( sckt,
                                  bfr,
                                  MAXBFRSIZE ) ) )
   {
      return;
   }
   bfr[ inBytes ] = '\0';   /* Alýnan dizgenin null ile sonlandýrýlmasý. */
   fputs( bfr, stdout );    /* Dosya sonu(EOF) ise boþ dizge(inBytes == 0).  */
   fflush( stdout );
}  /* tod() sonu */</pre> </td></tr></table></div>
</p></div></dd></div></dl></dd></div></dl><dl><div class="sect2"><dt><div> <h3 class="title"><a name="id2"></a> Diðer Programalama Dilleri</h3></div></dt><dd><dl><div class="sect3"><dt><div> <h4 class="title"><a name="id12"></a>JAVA</h4></div></dt><dd><p>
Sun Java sürümleri 1.4'ten itibaren IPv6'yý desteklemektedir, örneðin <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/net/Inet6Address.html" target="_top">Inet6Address (1.5/5.0)</a> sýnýfýna bakabilirsiniz. Ýncelemek isterseniz Networking IPv6 User Guide for JDK/JRE <a href="http://java.sun.com/j2se/1.4.2/docs/guide/net/ipv6_guide/index.html" target="_top">1.4</a> ve <a href="http://java.sun.com/j2se/1.5.0/docs/guide/net/ipv6_guide/index.html" target="_top">1.5 (5.0)</a> baðlantýlarýný incelebilirsiniz.
</p></dd></div></dl><dl><div class="sect3"><dt><div> <h4 class="title"><a name="id22"></a>Perl</h4></div></dt><dd><p>2007'nin Mayýs'ýndan beri Perl çekirdeðinin IPv6'yý desteklediði bilinmektedir. Bu destek aþaðýdaki modül eklenerek saðlanabilir. </p><p><div class="itemizedlist"><ul type="disc"><li><a href="http://search.cpan.org/%7Eumemoto/Socket6/" target="_top">Socket6</a></li></ul></div></p><p>
Zaten IPv6 desteði için baþka modüller de mevcut (mesela Net::IP) <a href="http://search.cpan.org/" target="_top">http://search.cpan.org/</a> adresinde "IPv6" diyerek aratabilirsiniz.
</p></dd></div></dl></dd></div></dl></dd></div></dl><h1></h1><table width="100%" summary="Navigation header" cellpadding="1" cellspacing="0" border="0"><tr><td bgcolor="black" class="navoutline"><table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td bgcolor="white" class="navinline"><table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td width="40%" align="left"><a accesskey="p" href="../howto/ipv6-howto-hints-daemons-others.html">Önceki</a> </td><td width="20%" align="center"><a accesskey="u" href="../howto/ipv6-howto.html">Üst Ana Baþlýk</a></td><td width="40%" align="right"> <a accesskey="n" href="../howto/ipv6-howto-interoperability.html">Sonraki</a></td></tr><tr><td width="40%" align="left" valign="top">Diðer artalan süreçleri </td><td width="20%" align="center"><a accesskey="h" href="../KiTAPLIK/index.html">Baþlangýç</a></td><td width="40%" align="right" valign="top"> Birlikte çalýþabilirlik</td></tr><tr><td colspan="3" align="center">
                  Bir <a href="http://www.belgeler.org/">Linux Kitaplýðý</a> Sayfasý
                </td></tr></table></td></tr></table></td></tr></table></body></html>
