<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-9"><meta name="date" content="2008-10-23T02:29:03+03:00"><title>Çaðrý Uzlaþýmlarý</title><link rel="icon" type="image/png" href="../images/belgeler-logo.png"><link rel="stylesheet" href="../belgeler.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V-special(derived from 1.49 for Turkish Linux Documentation WG by Nilgün Belma Bugüner - nilgun@superonline.com)"><link rel="home" href="../KiTAPLIK/index.html" title="Linux Kitaplýðý"><link rel="up" href="../howto/assembly-howto.html" title="Linux Makina Dili NASIL"><link rel="previous" href="../howto/assembly-howto-s-meta.html" title="Düþük seviye programlama"><link rel="next" href="../howto/assembly-howto-s-quick.html" title="Hýzlý baþlangýç"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><table width="100%" summary="Navigation header" cellpadding="1" cellspacing="0" border="0"><tr><td bgcolor="black" class="navoutline"><table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td bgcolor="white" class="navinline"><table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><th colspan="3" align="center">Çaðrý Uzlaþýmlarý</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="../howto/assembly-howto-s-meta.html">Önceki</a> </td><th width="60%" align="center">Linux Makina Dili NASIL</th><td width="20%" align="right"> <a accesskey="n" href="../howto/assembly-howto-s-quick.html">Sonraki</a></td></tr></table></td></tr></table></td></tr></table><dl><div class="sect1"><dt><div> <h2 class="title" style="clear: both"><a name="assembly-howto-s-call"></a>Çaðrý Uzlaþýmlarý</h2></div></dt><dd><dl><div class="sect2"><dt><div> <h3 class="title"><a name="assembly-howto-linux"></a>Linux</h3></div></dt><dd><dl><div class="sect3"><dt><div> <h4 class="title"><a name="id11"></a>GCC'ye ilintileme</h4></div></dt><dd><p>
C-asm karýþýmý projeler üretiyorsanýz bu tercih edilen yoldur. GAS açýklamalarý olan Linux çekirdeði .s dosyalarýndan örnekleri ve GCC belgelerini inceleyiniz (as86 ile ilgili olanlarý).
</p><p>
32 bitlik geridönüþ adresi üzerinde, 32 bitlik baðýmsýz deðiþkenler yýðýta (stack) ters sözdizimsel sýrada itilirler (push) (böylece doðru sýrada eriþilir/çýkarýlýrlar (pop)). <tt>%ebp</tt>, <tt>%esi</tt>, <tt>%edi</tt> ve <tt>%ebx</tt> çaðrýlan tarafýndan kullanýlýr, diðer yazmaçlar ise çaðýrýcý tarafýndan kullanýlýr; <tt>%eax</tt> sonuçlarý tutmak içindir veya <tt>%edx:%eax</tt> 64 bitlik sonuçlar için kullanýlýr.
</p><p>
FP yýðýtý (FP stack): Emin deðilim ama, sanýrým tüm sonuç, saklanmýþ çaðrýcýlarýn tamamý <tt>st(0)</tt> içindeydi. Eðer daha fazla ayrýntý istiyorsanýz <a href="http://www.caldera.com/developer/devspecs/" target="_top">http://www.caldera.com/developer/devspecs/</a> adresindeki SVR4 i386 ABI belirtimi iyi bir baþvuru kaynaðýdýr.
</p><p>
GCC'nin çaðrý uzlaþýmlarýný deðiþtirmek için, yazmaçlarý önceden ayýrtan, yazmaçlarda baðýmsýz deðiþkenler barýndýrýlmasýný saðlayan, FPU'yu dikkate almayan, v.b. seçenekleri olduðunu unutmayýn. i386 <tt>.info</tt> sayfalarýna bakýnýz.
</p><p>
Standart GCC çaðrý uzlaþýmlarýný izleyecek bir iþlev için <tt>cdecl</tt> ve <tt>regparm(0)</tt> bildirimlerini yapmanýz gerektiðine dikkat edin. GCC info sayfasýndan <tt>C Extensions::Extended Asm::</tt> kýsmýna bakýnýz. Ayný zamanda Linux'un kendi <tt>asmlinkage</tt> makrosunu da nasýl tanýmladýðýna bakýnýz.
</p></dd></div></dl><dl><div class="sect3"><dt><div> <h4 class="title"><a name="id21"></a>ELF ve a.out arasýndaki sorunlar</h4></div></dt><dd><p>
Bazý C derleyicileri, diðerleri yapmadýðý halde, her sembolden önce bir alt çizgi yerleþtirirler.
</p><p>
Özellikle, Linux a.out GCC böylesi bir ön yerleþtirmeyi yapar, oysa ki Linux ELF GCC yapmamaktadýr.
</p><p>
Eðer her iki davranýþ biçimiyle de ayný anda uðraþmak isterseniz, varolan paketlerin bunu nasýl yaptýklarýna bakýnýz. Mesela, Elk, qthreads, OCaml... gibi eski bir Linux kaynak aðacý edinin.
</p><p>
Ayrýca, örneðin, <tt>foo()</tt> iþlev çaðrýsýnýn gerçekte bir makine dili kodu olan <tt>bar</tt>'ýn çaðrýlmasýný saðlamasý için þu þekilde bir ek ifade ile örtük C-&gt;asm isim deðiþikliðini zorlayabilirsiniz:
</p><p>
<div class="programlisting" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="programlisting">void foo asm("bar") (void);
</pre> </td></tr></table></div>
</p><p>
Binutils paketindeki <b><tt>objcopy</tt></b> uygulamasýnýn a.out nesnelerinizi ELF nesnelerine dönüþtürmeyi mümkün kýlmasý gerektiðini unutmayýn, hatta bazý durumlarda tam tersine de imkan tanýr. Daha genel olarak, pekçok dosya biçimi arasýnda dönüþüm gerçekleþtirir.
</p></dd></div></dl><dl><div class="sect3"><dt><div> <h4 class="title"><a name="id31"></a>Doðrudan Linux sistem çaðrýlarý (syscalls)</h4></div></dt><dd><p>
Genelde C kütüphanesi (libc) kullanmanýn tek yol olduðu ve doðrudan sistem çaðrýlarý yapmanýn kötü olduðu söylenir. Bu doðrudur. Bir bakýma... Genel olarak, libc kütüphanesinin kutsal olmadýðýný bilmelisiniz ve <i>pekçok</i> durumda sadece bazý denetimler yapar, sonra çekirdeðe çaðrý yapar ve  ardýndan errno'ya atama yapar. Bunu kendi programýnýzda da yapabilirsiniz (eðer ihtiyacýnýz varsa) ve programýnýz bir düzine kat daha küçük olacaktýr, bu da geliþmiþ bir baþarým artýþýna sebep olacaktýr, bu da sýrf paylaþýmlý kütüphaneleri kullanmadýðýnýzdan kaynaklanacaktýr (duraðan (static) kütüphaneler daha hýzlýdýr). Sembolik makina dili ile programlamada libc kullanýmý pratik birþeyden çok zevk/inanýþ meselesidir. Linux'un POSIX standartlarýna uygun olmayý hedeflediðini unutmayýn, benzer þekilde libc de. Bu da, hemen her libc "sistem çaðrýsý" sözdizimin gerçek çekirdek sistemi çaðrýlarýndaki sözdizimiyle örtüþmesi anlamýna gelir (ve tam tersi). Buna ek olarak, GNU libc (glibc) sürümden sürüme daha yavaþ hale gelmekte ve daha çok bellek tüketmektedir. Ýlerde siz de kendi, deðiþik türlerde, libc'ye özel iþlevlerinizi (sadece birer sistem çaðrýsý deðil) tanýmlayacaksýnýz (<tt>printf()</tt> ve þürekasý)... ve buna hazýrsýnýz, deðil mi? <tt>:)</tt>
</p><p>
Doðrudan sistem çaðrýlarý yapmanýn artý ve eksileri þu þekilde özetlenebilir:
</p><h5><a name="id31"></a>Artýlar</h5><p>
<div class="itemizedlist"><ul type="disc"><li>olasý en küçük boyut; son baytý sistem dýþýnda býrakmak</li><li>olasý en yüksek hýz; favori karþýlaþtýrmalý deðerlendirme (benchmark) dýþý döngüleri bunun dýþýnda býrakmak</li><li>tam denetim: program/kütüphanenizi size özgü dile veya bellek gereksinimlerine veya herhangi bir þeye uydurabilirsiniz.</li><li>libc çerçöplerinin yol açacaðý bir kirlilik olmaz</li><li>C çaðrý uzlaþýmlarýnýn yol açacaðý bir kirlilik olmaz (eðer kendi dilinizi veya ortamýnýzý tasarlýyorsanýz)</li><li>duraðan kütüphaneler libc yükseltmelerinden ve çökmelerinden veya yorumlayýcýya <tt>#!</tt> yolu ile asýlmanýzdan sizi baðýmsýz kýlar. (ve daha hýzlýdýr)</li><li>biraz da eðlence içindir (sembolik makina dili dýþýnda heyecanlanmaz mýsýnýz?)</li></ul></div>
</p><h5><a name="id31"></a>Eksiler</h5><p>
<div class="itemizedlist"><ul type="disc"><li>
Eðer bilgisayarýnýzda bir baþka program da libc kullanýyorsa, libc kodunun yinelenmesi otomatik olarak belleðin, korunmasý yerine, boþa harcanmasýna sebep olacaktýr.
<p></p><p></p></li><li>
Pekçok duraðan ikilikte (static binary) gereksiz yere tanýmlanan servisler bellek israfýdýr. Fakat kendi libc yerdeðiþtirmenizin bir paylaþýmlý kütüphane olmasýný saðlayabilirsiniz. (NBB: Bu  yukarýdaki iddiasýný yalanlamýyor mu? <tt>;-)</tt>)
<p></p><p></p></li><li>
Herþeyi sembolik makina dili ile yazmak yerine, bir çeþit bayt kodu, sözcük kodu veya yapýsal yorumlayýcýya sahip olmakla, boyut çok daha iyi korunur. (derleyicinin kendisi C veya sembolik makina dilinde yazýlabilir). Ýkilik çeþitliliðini küçük tutmanýn en iyi yolu, çoklu ikilikler yapmamaktýr, yerine <tt>#!</tt> önekiyle baþlayan yorumlanan iþlem dosyalarý kullanmaktýr. Bu, OCaml'ýn sözcük kodu kipinde çalýþtýðýndaki durumdur (eniyilenmiþ doðal kod kipine karþýn) ve de libc kullanýmýyla uyumludur. Bu ayný zamanda unix araçlarýnýn yeniden gerçeklenimi olan Tom Christiansen'in Perl Güç Araçlarý (Perl PowerTools)'nýn nasýl çalýþtýðýnýn açýklamasýdýr. Son olarak, bunlarý küçük tutmanýn bir yolu da, tam olarak yolu kodlanmýþ harici bir dosyaya baðýmlý olmamaktýr, bu da kütüphane veya yorumlayýcý olsun, tek bir ikilik dosyaya sahip olmak ve buna sabit veya sembolik baðlar yapmaktýr: ayný ikilik size en makul alanda, alt yordamlarýn gereksiz kullanýmý veya gereksiz ikilik baþlýklarý olmadan,  ihtiyacýnýz olan herþeyi sunacaktýr; kendine özel davranýþý <i><tt>argv[0]</tt></i> deðerine bakarak yönlendirecektir; bu durumda tanýnan ismiyle çaðrýlmaz, bir kabuða öntanýmlý olabilir ve muhtemelen bir yorumlayýcý olarak da kullanýþlý olmuþ olur!
<p></p><p></p></li><li>
Nadir linux sistem çaðrýlarý yanýnda libc'nin sunduðu pekçok iþlevsellikten faydalanamazsýnýz: malloc, thread, locale, password, yüksek-seviyeli að yönetimi, v.b. iþlevsellikler, kýlavuz sayfalarýnýn 2. bölümünde deðil, 3. bölümünde yer alýr.
<p></p><p></p></li><li>
Bu yüzden, libc'nin, <tt>printf()</tt>'den <tt>malloc()</tt> ve <tt>gethostbyname</tt>'e uzanan çok sayýda parçalasýný yeniden gerçeklemek zorunda kalabilirsiniz. libc varken bu gereksizdir, hatta <i>oldukça</i> sýkýcý olabilir. Bazýlarýnýn libc'nin bazý kýsýmlarý için "hafif" (ligth) yerdeðiþtirmeler yazdýklalarýna dikkat ediniz - bunlarý inceleyiniz! (Redhat'in minilibc'si, Rick Hohensee'nin <a href="ftp://linux01.gwdg.de/pub/cLIeNUX/interim/libsys.tgz" target="_top">libsys</a>'si, Felix von Leitner'in <a href="http://www.fefe.de/dietlibc/" target="_top">dietlibc</a>'si, Christian Fowelin'in <a href="http://www.fowelin.de/christian/computer/libASM/" target="_top">libASM</a>'si, <a href="http://linuxassembly.org/asmutils.html" target="_top">asmutils</a> projesi de tamamen saf sembolik makina libc'si ile çalýþmaktadýr)
<p></p><p></p></li><li>
Duraðan kütüphaneler sizi, libc güncellemelerinden ve ayný zamanda, gzip-sýkýþtýrýlmýþ dosyalarýný düzgün þekilde ihtiyaç olduðunca açmanýzý saðlayan,  zlib paketi gibi libc eklentilerinden faydalanmaktan alýkoyar.
<p></p><p></p></li><li>
libc tarafýndan eklenen çok az sayýdaki komutun sistem çaðrýlarýnýn maliyetine kýyasla <i>küçük</i> bir hýz yükü olabilir. Eðer hýz gözönüne alýnýrsa, temel sorununuz, onlarýn sarmalayýcý iþlevlerini deðil, kendi sistem çaðrýlarýnýzýn kullanýmýdýr.
<p></p><p></p></li><li>
Kendi çaðrý uzlaþýmlarý olan ve standart uzlaþým kullanýmýnda kural dönüþüm yüküne (high convention-translation overhead) büyük önem veren L4Linux gibi Linux'un mikro çekirdek sürümleri çalýþtýrýlýrken, sistem çaðrýlarý için standart sembolik makina dili API'leri kullanmak, libc API'leri kullanmaktan daha yavaþtýr (L4Linux, sistem çaðrý API'leri ile yeniden derlenmiþ þekilde gelir; elbette kendi kodunuzu onun API'leriyle tekrar derleyebilirsiniz).
<p></p><p></p></li><li>
Genel hýz eniyileme konularýyla ilgili olarak önceki konulara bakýnýz.
<p></p><p></p></li><li>
Eðer sistem çaðrýlarý size göre çok yavaþsa, kullanýcý adasýnda kalmak yerine çekirdek kaynak kodlarýný (C dilindeki) elden geçirmeyi isteyebilirsiniz.
<p></p><p></p></li></ul></div>
</p><p>
Eðer yukarýdaki artý ve eksileri zihninizde iyice ölçüp tarttýysanýz ve hala doðrudan sistem çaðrýlarýný kullanmak istiyorsanýz, size bazý önerilerim olacak:
</p><p>
<div class="itemizedlist"><ul type="disc"><li>
Sistem çaðrý iþlevlerinizi taþýnabilir bir þekilde, C dilinde (sembolik makina dilinin taþýnamaz özelliðine karþýn) <tt>asm/unistd.h</tt> ile sunulan makrolarý kullanarak tanýmlayabilirsiniz.
<p></p><p></p></li><li>
Sistem çaðrýsý iþlevlerini deðiþtirmeyi deneyecekseniz, libc'den kaynak kodunu alýp inceleyin. (Ve daha iyisini yapabileceðinizi düþünüyorsanýz, bunu yazarlara bildirin!)
<p></p><p></p></li><li>
Ýstediðiniz her iþi yapan bir sembolik makina kodu için <a href="../howto/assembly-howto-s-res.html" title="Özkaynaklar"> Özkaynaklar</a>ýna bakýnýz.
<p></p><p></p></li></ul></div>
</p><p>
Temelde, <tt>eax</tt> içerisine <tt>__NR_</tt>sistemçaðrý_ismi numarasý (<tt>asm/unistd.h</tt> dosyasýndadýrlar) ile <tt>int 0x80</tt> deðeri ve parametreleri de sýrasýyla (<a href="../howto/assembly-howto-s-call.html#assembly-howto-six-arg">altý</a>ya kadar) <tt>ebx</tt>, <tt>ecx</tt>, <tt>edx</tt>, <tt>esi</tt>, <tt>edi</tt>, <a href="../howto/assembly-howto-s-call.html#assembly-howto-six-arg">ebp</a> içine konur.
</p><p>
Sonuç <tt>eax</tt> içerisinde döndürülür, negatif sonuçlarda hata ile döner, bunun karþýlýðý da libc içerisinde <tt>errno</tt>'dur. Kullanýcý yýðýtýna dokunulmaz, dolayýsiyle bir sistem çaðrýsý yaparken geçerli bir kullanýcý yýðýtýna ihtiyacýnýz yoktur.
</p><p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0"><tr><td rowspan="2" align="center" valign="top" width="25"><img src="../images/xsl/note.png"></td><th>Not</th></tr><tr><td colspan="2" align="left" valign="top"><a name="assembly-howto-six-arg"></a><p>
<tt>ebp</tt>'ye 6 parametre aktarýmý Linux 2.4 sürümünde mümkün olmuþtur, daha önceki Linux sürümleri yazmaçlarda sadece 5 parametreye bakýyordu.
</p></td></tr></table></div>
</p><p>
<a href="http://www.linuxdoc.org/LDP/lki/" target="_top">Linux Çekirdeðinin Dahili Yapýsý (Linux Kernel Internals)</a> belgesi ve özellikle <a href="http://www.linuxdoc.org/LDP/lki/lki-2.html#ss2.11" target="_top">i386 Mimarisinde Sistem Çaðrýlarý Nasýl Gerçeklenir? (How System Calls Are Implemented on i386 Architecture?)</a> bölümü çok daha saðlýklý bilgi verecektir.
</p><p>
Baþlatýrken bir sürece parametrelerin aktarýlmasýnda olduðu gibi, genel prensip, yýðýtýn orjinal olarak argüman sayýsýný (<i><tt>argc</tt></i>) ve ardýndan <i><tt>*argv</tt></i>'ler halinde argüman göstericilerini, bundan sonra da <i><tt>environ</tt></i> (ortam) için boþ gösterici ile sonlandýrýlmýþ boþ karakter sonlandýrmalý <tt>isim=deger</tt> dizgelerini
içereceðidir. Daha ayrýntýlý bilgi için, <a href="../howto/assembly-howto-s-res.html" title="Özkaynaklar"> Özkaynaklar</a> bölümünü okuyunuz, libc'nizdeki C baþlatma (<tt>crt0.S</tt> veya <tt>crt1.S</tt>) kodlarýný veya bunlarýn Linux çekirdeðinde olanlarýný (<tt>exec.c</tt> ve <tt>linux/fs</tt> içindeki <tt>binfmt_*.c</tt>) inceleyiniz.
</p></dd></div></dl><dl><div class="sect3"><dt><div> <h4 class="title"><a name="id41"></a>Linux altýnda donanýmsal G/Ç</h4></div></dt><dd><p>
Eðer Linux altýnda doðrudan port eriþimi ile G/Ç iþlemleri gerçekleþtirmek istiyorsanýz, bu ya iþletim sisteminde bir deðiþiklik gerektirmeyen basit bir iþtir ve bununla ilgili <tt>G/Ç portlarý ve programlama (IO-Port-Programming)</tt> küçük nasýl belgesini okumanýz yeterli olur ya da bir çekirdek aygýt sürücüsü gereklidir ve çekirdek kaynak kodlarýný elden geçirme, aygýt sürücüsü geliþtirme, çekirdek modülleri, v.b.  ile ilgili daha fazla bilgi edinmeniz gerekir. Bunlarla ilgili pek çok belge ve NASILlar LDP sayfalarýnda bulunmaktadýr.
</p><p>
Belki de, grafik programlama yapmak istersiniz, o zaman <a href="http://www.ggi-project.org/" target="_top">GGI</a> veya <a href="http://www.xfree86.org/" target="_top">XFree86</a> projelerinden birine katýlýn.
</p><p>
Bazýlarý daha iyisini bile yapabilir, yorumlanmýþ belli bir alana özgü bir dilde, GAL, küçük ve güçlü XFree86 sürücüleri yazabilirler, bazý deðerlendirmelerden sonra da C ile yazýlmýþ sürücülerin verimini arttýrabilirler (sürücüler ne sadece asm'dir ne de sadece C!). Burada sorun, verimi arttýrmak için kullanýlacak bazý deðerlendiricilerin özgür olmamasýdýr. Bunlarýn özgür sürümlerini gerçekleþtirecek olan var mý?
</p><p>
Herneyse, tüm bu durumlarda, herþeyi sembolik makina kodu ile yazmak yerine GCC satýriçi sembolik makina dilini <tt>linux/asm/*.h</tt> dosyalarýndaki makrolarla kullanmak daha iyi olacaktýr.
</p></dd></div></dl><dl><div class="sect3"><dt><div> <h4 class="title"><a name="id51"></a>Linux/i386'daki 16 bitlik sürücülere eriþim</h4></div></dt><dd><p>
Böyle bir þey teorik olarak doðrudur (kanýt: <a href="http://www.dosemu.org/" target="_top">DOSEMU</a>'nun programlara seçici bir þekilde port atamalarýný nasýl yaptýðýný inceleyiniz) ve ben de bir yerlerde birilerinin bunu yaptýðý söylentilerini de duydum (bir PCI sürücüsü mü? bir VESA eriþim aracý mý?  ISA PnP mi? bilmiyorum). Eðer bunun hakkýnda çok net bilginiz varsa, o zaman çok daha memnun olacaksýnýz. Herneyse, daha ayrýntýlý bilgi için bakýlmasý gereken kaynaklar Linux çekirdeðinin kaynak kodlarý, DOSEMU kaynaklarý (ve DOSEMU deposundaki diðer programlar) ve de Linux altýnda pekçok düþük seviyeli programýn kaynaklarýdýr ... (belki CGI'da olabilir, eðer VESA desteði varsa).
</p><p>
Temel olarak ya 16 bitlik korumalý kipi veya vm86 kipini kullanmalýsýnýz.
</p><p>
Ýlkinin yapýlandýrýlmasý daha basittir, fakat sadece segman aritmetiði veya mutlak segman adreslemesi (özellikle 0. segmaný adreslerken) ile ilgili iþlemler yapmayacak iyi davranýþlý kodla çalýþýr, fakat þans eseri tüm segmanlar kullanýlýrsa, LDT ile ileri düzey ayarlama yapýlabilir.
</p><p>
Ýkincisi ise harcýalem 16 bitlik ortamlarla daha bir uyumluluk saðlar, fakat idaresi daha karmaþýktýr.
</p><p>
Her iki durumda da 16 bitlik koda geçmeden önce, þunlarý yapmalýsýnýz:
</p><p>
<div class="itemizedlist"><ul type="disc"><li>
16 bitlik kod içerisinde kullanýlan herhangi bir mutlak adresi (ROM, video tamponlarý, DMA hedefleri ve bellek eþlemli G/Ç gibi) <tt>/dev/mem</tt>'den sürecinizin adres uzayýna <tt>mmap</tt>'leyin.
</li><li>
LDT ve/veya vm86 kipi gözlemleyici ayarlayýn
</li><li>
çekirdekten uygun G/Ç izinlerini kapýn (üst bölümlere bakýnýz)
</li></ul></div>
</p><p>
Tekrar, DOSEMU projesiyle sunulan belgeleri dikkatlice okuyunuz, özellikle Linux/i386 altýnda ELKS ve/veya <tt>.COM</tt> programlarýný çalýþtýrmak için kullanýlan küçük emülatörlerle ilgili kýsýmlarý.
</p></dd></div></dl></dd></div></dl><dl><div class="sect2"><dt><div> <h3 class="title"><a name="assembly-howto-dos"></a>DOS ve Windows</h3></div></dt><dd><p>
Pekçok DOS çoðaltýcýlarý (extenders) DOS servisleri için bazý servislerle beraber gelir. Bununla ilgili belgeleri okuyunuz, fakat genelde, <tt>int 0x21</tt> ve benzerine benzetim yaparlar (simulate) ve siz de sanki gerçek kipteymiþ gibi çalýþýrsýnýz (Az geliþmiþlik dýþýnda birþeyleri olduðundan ve iþlemleri 32 bitlik terimlerle çalýþýr hale getirdiklerinden þüpheliyim, daha çok gelen kesmeleri gerçek kip veya vm86 eylemcisine yansýtýyor gibiler.)
</p><p>
DPMI hakkýndaki belgeler (ve fazlasý) <a href="ftp://x2ftp.oulu.fi/pub/msdos/programming/" target="_top">ftp://x2ftp.oulu.fi/pub/msdos/programming/</a> adresinde bulunabilir (yine, asýl x2ftp sitesi kapanýyor (kapandý?), onun için <a href="ftp://ftp.lip6.fr/pub/pc/x2ftp/README.mirror_sites" target="_top">yansýyý</a> kullanýn).
</p><p>
DJGPP kendi (sýnýrlý) glibc türev/altküme/yerdeðiþtirmeleri v.b.leri ile gelmektedir.
</p><p>
Linux'tan DOS'a çapraz-derleme (cross-compile) yapmak mümkündür, metalab.unc.edu için olan yerel FTP yansýnýzýn <tt>devel/msdos/</tt> dizinine bakýnýz; Ayný zamanda Utah üniversitesindeki <a href="http://www.cs.utah.edu/projects/flux/" target="_top">Flux Projesi</a>'nden MOSS DOS-extender (DOS-geniþletici)'ye de bakýnýz.
</p><p>
Diðer belgeler ve SSS, DOS merkezlidir; biz DOS geliþimini tavsiye etmiyoruz.
</p><dl><br><b>Windows ve Þürekasý</b><br><dd>
Bu belge Windows programlama hakkýnda deðildir, bununla ilgili pekçok belgeyi heryerde bulabilirsiniz... Bilmeniz gereken, GNU programlarýnýn Win32 altýnda çalýþmasý için, <a href="http://www.cygwin.com/" target="_top">cygwin32.dll</a> kütüphanesini olduðudur, böylece sizler GCC, GAS ve tüm GNU araçlarý ile pekçok diðer Unix uygulamasýný kullanabilmektesiniz.
<p></p></dd></dl></dd></div></dl><dl><div class="sect2"><dt><div> <h3 class="title"><a name="assembly-howto-ownos"></a>Kendi iþletim sisteminiz</h3></div></dt><dd><p>
Denetim duygusu pekçok iþletim sistemi geliþtiricisini sembolik makina diline çeken þeydir, bu da genelde sembolik makina dili kodlarý elden geçirmeye yol açmakta veya ondan kaynaklanmaktadýr. Her ne kadar temelini oluturan bir sistemin tepesinde çalýþabiliyor olsa da (Mac üzerindeki Linux veya Unix üzerindeki OpenGenera), kendi kendine geliþime izin veren bir sistem ancak iþletim sistemi olarak isimlendirilebilir.
</p><p>
Böylece, kolay hata ayýklama amaçlarý için, ilk baþlarda kendi iþletim sisteminizi Linux üzerinde çalýþýr þekilde tasarlayabilirsiniz (yavaþlýðýna raðmen), daha sonra <a href="http://www.cs.utah.edu/projects/flux/oskit/" target="_top">Flux OS aracý</a>ný kullanarak (kendi iþletim sisteminizde Linux ve BSD sürücülerinin kullanýmýný garanti eder), onu kendi baþýna çalýþýr hale getirebilirsiniz. Ýþletim sisteminiz kararlý olduðunda, artýk gerçekten sevdiyseniz, kendi donaným sürücülerinizi yazmanýn vaktidir.
</p><p>
Bu NASIL belgesi önyükleyici (bootloader) kodlarýný, 32 bitlik kipe geçmeyi, kesmelerle iþlem yapmayý, Intel'in temel güvenli kipini veya V86/R86 beyinölümlülüðünü (braindeadness), nesne biçiminizi tanýmlamayý ve çaðrý uzlaþýmlarýný kapsaMAmaktadýr.
</p><p>
Tüm bunlar için güvenli bilgi bulabileceðiniz yer halihazýrdaki iþletim sisteminin veya önyükleyicinin kaynak kodlarýdýr. Pekçok konu þu adreste mevcuttur: <a href="http://www.tunes.org/Review/OSes.html" target="_top">http://www.tunes.org/Review/OSes.html</a>
</p></dd></div></dl></dd></div></dl><h1></h1><table width="100%" summary="Navigation header" cellpadding="1" cellspacing="0" border="0"><tr><td bgcolor="black" class="navoutline"><table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td bgcolor="white" class="navinline"><table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td width="40%" align="left"><a accesskey="p" href="../howto/assembly-howto-s-meta.html">Önceki</a> </td><td width="20%" align="center"><a accesskey="u" href="../howto/assembly-howto.html">Üst Ana Baþlýk</a></td><td width="40%" align="right"> <a accesskey="n" href="../howto/assembly-howto-s-quick.html">Sonraki</a></td></tr><tr><td width="40%" align="left" valign="top">Düþük seviye programlama </td><td width="20%" align="center"><a accesskey="h" href="../KiTAPLIK/index.html">Baþlangýç</a></td><td width="40%" align="right" valign="top"> Hýzlý baþlangýç</td></tr><tr><td colspan="3" align="center">
                  Bir <a href="http://www.belgeler.org/">Linux Kitaplýðý</a> Sayfasý
                </td></tr></table></td></tr></table></td></tr></table></body></html>
