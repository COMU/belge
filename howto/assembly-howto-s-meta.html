<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-9"><meta name="date" content="2008-10-23T02:29:03+03:00"><title>Düþük seviye programlama</title><link rel="icon" type="image/png" href="../images/belgeler-logo.png"><link rel="stylesheet" href="../belgeler.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V-special(derived from 1.49 for Turkish Linux Documentation WG by Nilgün Belma Bugüner - nilgun@superonline.com)"><link rel="home" href="../KiTAPLIK/index.html" title="Linux Kitaplýðý"><link rel="up" href="../howto/assembly-howto.html" title="Linux Makina Dili NASIL"><link rel="previous" href="../howto/assembly-howto-s-assem.html" title="Çeviriciler (Assemblers)"><link rel="next" href="../howto/assembly-howto-s-call.html" title="Çaðrý Uzlaþýmlarý"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><table width="100%" summary="Navigation header" cellpadding="1" cellspacing="0" border="0"><tr><td bgcolor="black" class="navoutline"><table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td bgcolor="white" class="navinline"><table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><th colspan="3" align="center">Düþük seviye programlama</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="../howto/assembly-howto-s-assem.html">Önceki</a> </td><th width="60%" align="center">Linux Makina Dili NASIL</th><td width="20%" align="right"> <a accesskey="n" href="../howto/assembly-howto-s-call.html">Sonraki</a></td></tr></table></td></tr></table></td></tr></table><dl><div class="sect1"><dt><div> <h2 class="title" style="clear: both"><a name="assembly-howto-s-meta"></a>Düþük seviye programlama</h2></div></dt><dd><p>
Sembolik makina dili ile programlama, programýn kritik kýsýmlarý için bir can sýkýntýsýdýr.
</p><p>
Doðru görev için uygun araçlarý kullanmalýsýnýz, dolayýsiyle eðer uygun deðilse sembolik makina dilini kullanmak için seçmeyin; pekçok durumda C, OCaml, Perl, Scheme daha iyi birer seçim olabilir.
</p><p>
Yine de, makina üzerinde bu araçlarýn makina üzerinde yeterince iyi olanaklar sunmadýðý anlar vardýr ve sembolik makina dili böylesi durumlar için faydalý veya gereklidir. Böyle bir durumda, sonsuz kere kullanýlabilir tanýmlamalar içerisine yerleþtirilmiþ tekrar eden kalýplara izin veren makroprogramlama ve metaprogramlama sistemini takdir edeceksiniz, ki bu sistem ayný zamanda, daha güvenli programlama, model deðiþiminin otomatik üretimi, vs. saðlamaktadýr. Yalýn çeviriciler genelde yetersizdir, hatta sadece C ile ilintilenecek küçük yordamlar yaparken bile.
</p><dl><div class="sect2"><dt><div> <h3 class="title"><a name="assembly-howto-external"></a>Harici Filtreler</h3></div></dt><dd><p>
Sizin çeviricinizde her ne makro desteði varsa veya her ne dilini (hatta C!) kullanýyorsanýz, eðer dil yeterince sizin için ifadesel deðilse, bir Makefile kuralý ile dosyalarýnýzý harici bir filtreden þu þekilde geçirebilirsiniz:
</p><p>
<div class="programlisting" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="programlisting">%.s:    %.S other_dependencies
        $(FILTER) $(FILTER_OPTIONS) &lt; $&lt; &gt; $@
</pre> </td></tr></table></div>
</p><dl><div class="sect3"><dt><div> <h4 class="title"><a name="assembly-howto-p-cpp"></a>CPP</h4></div></dt><dd><p>
CPP gerçekten çok anlamlý, ifadesel deðildir, fakat kolay þeyler için yeterlidir ve GCC tarafýndan þeffaf þekilde çaðrýlýr.
</p><p>
Kýsýtlamalarýna bir örnek olarak, yokediciler de (destructors), bildirim bloðunun sonunda çaðrýldýklarýndan içinde nesne bildirimleri yapamazsýnýz; bölümlere veya etki alanlarýna, vs. sahip olamazsýnýz.
</p><p>
CPP herhangi bir C derleyicisi ile birlikte gelir. Yine de, ne kadar vasat olduðunu düþünürsek, eðer onu C'siz kullanmayý baþarabilirseniz de, ondan uzak durun.
</p></dd></div></dl><dl><div class="sect3"><dt><div> <h4 class="title"><a name="assembly-howto-p-m4"></a>M4</h4></div></dt><dd><p>
M4 size, Turing dengi bir dil, yinelemeler (recursions), düzenli ifadeler (regular expression) ile,  macro iþlemenin tüm gücünü vermektedir. CPP'nin yapamadýðý herþeyi onunla yapabilirsiniz.
</p><p>
M4 kullanarak yapýlan ileri düzey programlama örnekleri için <a href="ftp://ftp.forth.org/pub/Forth/Compilers/native/unix/this4th.tar.gz" target="_top">macro4th (this4th)</a> veya <a href="ftp://ftp.tunes.org/pub/tunes/obsolete/dist/tunes.0.0.0/tunes.0.0.0.25.src.zip" target="_top">Tunes 0.0.0.25 kaynaklarýna</a> bakýnýz.
</p><p>
Yine de, iþlevsel olmayan týrnak kullanýmý (quoting) ve bunun kaldýrýlmasý (disquoting) þeklindeki anlamsal yapý (semantics), eðer <i>ileri</i> düzey makro programlama yapmak istiyorsanýz sizi süreklilik gösteren içiçe makro tarzý (continuation-passing tail-recursive macro style) kullanmaya zorlamaktadýr (ki bu da insana TeX'i hatýrlatýyor - herneyse, TeX'i yazý yazmak dýþýnda bir makroiþlemci olarak kullanan kimse var mý?). Týrnak ve yineleme (recursion) kullanýmýna hiç izin vermeyen CPP'den daha kötü deðildir.
</p><p>
M4'ü kullanmak için doðru sürüm, en çok özelliði, en az hatasý ve kýsýtlamalarý olan <tt>GNU m4 1.4</tt>'tür (varsa daha sonraki sürümleri). m4 herhangi bir þey için yavaþ çalýþacak þekilde tasarlanmýþtýr fakat en kolay kullanýma sahiptir, ki bu da çoðu sembolik makina dili için makul bir durumdur (milyonlarca satýr sembolik makina kodu yazmýyorsunuz deðil mi?).
</p></dd></div></dl><dl><div class="sect3"><dt><div> <h4 class="title"><a name="id31"></a>Kendi filtreleriniz ile makroprogramlama</h4></div></dt><dd><p>
Bilindik araçlarla kendi basit makro geniþleme filtrelerinizi yazabilirsiniz: perl, awk, sed, v.b. Biraz daha hýzlý gerçeklenebilir ve herþeyi denetmersiniz. Fakat, elbetteki, makroiþlemede güç, "zor yol" anlamýna gelmektedir.
</p></dd></div></dl></dd></div></dl><dl><div class="sect2"><dt><div> <h3 class="title"><a name="assembly-howto-meta"></a>Metaprogramlama</h3></div></dt><dd><p>
Makrolarý geniþleten harici bir filtre kullanmak yerine, iþleri yapmanýn bir yolu da tüm diðer programlarýn bir kýsmýný ya da tamamýný yazan programlar yazmaktýr.
</p><p>
Örneðin, çýktý olarak aþaðýdakileri gerçeklemek için kaynak kod üreten bir program kullanabilirsiniz:
</p><p>
<div class="itemizedlist"><ul type="disc"><li>sinüs/kosinüs/vs. arama tablolarýný üretmek için,</li><li>bir ikilik dosyanýn kaynak kodu gösterimini elde etmek için,</li><li>hýzlý ekran yordamlarýna biteþlemleri derlemek için,</li><li>normal kaynak koddan baþka, belgelendirme, baþlangýç/bitiþ kodlarý, tanýmlama tablolarýný elde etmek için,</li><li>perl/shell/scheme betiðinden üretilen rastgele iþlem yapan özelleþtirilmiþ sembolik makina koduna sahip olmak için,</li><li>çapraz baþvuru tablolarý ve kod bölümlerinden sadece tek noktada tanýmlý veri etkileþimi saðlamak için,</li><li>
v.b.
<p></p><p></p></li></ul></div>
</p><p>
Bunun hakkýnda düþünün!
</p><dl><div class="sect3"><dt><div> <h4 class="title"><a name="id12"></a>Derleyicilerdeki arka uçlar</h4></div></dt><dd><p>
GCC, SML/NJ gibi derleyiciler, Objective CAML (OCAML), MIT-Scheme, CMUCL, v.b.'nin, kullanmayý tercih edebileceðiniz, kendi dahili çevirici arkauçlarý (backend) vardýr, eðer yarý otomatik olarak bu dillere göre ya da elden geçirdiðiniz dillerden kod üretmeye niyetlenirseniz: uzun sembolik makina kodlarý yazmak yerine, bir derleyiciyi deðiþtirebilirsiniz, böylece uzun sembolik makina kodu çöpe gider!
</p></dd></div></dl><dl><div class="sect3"><dt><div> <h4 class="title"><a name="id22"></a>New-Jersey makina kodu araç seti</h4></div></dt><dd><p>
Sembolik makina kodunu deðiþtirecek bir kod üretim tabaný oluþturmak için Icon programlama dilini kullanan (deneme açamasýndaki ML sürümü ile) bir proje vardýr. <a href="http://www.eecs.harvard.edu/~nr/toolkit/" target="_top">http://www.eecs.harvard.edu/~nr/toolkit/</a> adresine bakýnýz.
</p></dd></div></dl><dl><div class="sect3"><dt><div> <h4 class="title"><a name="id32"></a>TUNES</h4></div></dt><dd><p>
Özgür Fikirli Bilgisayar Sistemi (Free Reflective Computing System) için <a href="http://www.tunes.org/" target="_top">TUNES Projesi</a>, kendi geliþim sürecinin bir parçasý þeklinde, Scheme dilinin bir uzantýsý olarak kendi çeviricisini geliþtirmektedir. Henüz hiç çalýþmamýþtýr, fakat yardýmlar kabul edilmektedir.
</p><p>
Çevirici soyut sözdizim aðaçlarýný (abstract syntax trees) deðiþtirmektedir, böylece sembolik makina sözdizimi çeviricisi, tersine çevirici (disassembler), genel sembolik makina dili/derleyici arka ucu, v.b. tabaný olarak eþit þekilde hizmet verebilmektedir. Ayný zamanda, gerçek bir dilin, Scheme, tüm gücü, makroprogramlama ve metaprogramlama için onu karþý konulmaz hale getirmektedir.
</p></dd></div></dl></dd></div></dl></dd></div></dl><h1></h1><table width="100%" summary="Navigation header" cellpadding="1" cellspacing="0" border="0"><tr><td bgcolor="black" class="navoutline"><table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td bgcolor="white" class="navinline"><table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td width="40%" align="left"><a accesskey="p" href="../howto/assembly-howto-s-assem.html">Önceki</a> </td><td width="20%" align="center"><a accesskey="u" href="../howto/assembly-howto.html">Üst Ana Baþlýk</a></td><td width="40%" align="right"> <a accesskey="n" href="../howto/assembly-howto-s-call.html">Sonraki</a></td></tr><tr><td width="40%" align="left" valign="top">Çeviriciler (Assemblers) </td><td width="20%" align="center"><a accesskey="h" href="../KiTAPLIK/index.html">Baþlangýç</a></td><td width="40%" align="right" valign="top"> Çaðrý Uzlaþýmlarý</td></tr><tr><td colspan="3" align="center">
                  Bir <a href="http://www.belgeler.org/">Linux Kitaplýðý</a> Sayfasý
                </td></tr></table></td></tr></table></td></tr></table></body></html>
