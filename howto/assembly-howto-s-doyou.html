<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-9"><meta name="date" content="2008-10-23T02:29:02+03:00"><title>Sembolik makina diline ihtiyacýnýz var mý?</title><link rel="icon" type="image/png" href="../images/belgeler-logo.png"><link rel="stylesheet" href="../belgeler.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V-special(derived from 1.49 for Turkish Linux Documentation WG by Nilgün Belma Bugüner - nilgun@superonline.com)"><link rel="home" href="../KiTAPLIK/index.html" title="Linux Kitaplýðý"><link rel="up" href="../howto/assembly-howto.html" title="Linux Makina Dili NASIL"><link rel="previous" href="../howto/assembly-howto-s-intro.html" title="Giriþ"><link rel="next" href="../howto/assembly-howto-s-assem.html" title="Çeviriciler (Assemblers)"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><table width="100%" summary="Navigation header" cellpadding="1" cellspacing="0" border="0"><tr><td bgcolor="black" class="navoutline"><table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td bgcolor="white" class="navinline"><table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><th colspan="3" align="center">Sembolik makina diline ihtiyacýnýz var mý?</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="../howto/assembly-howto-s-intro.html">Önceki</a> </td><th width="60%" align="center">Linux Makina Dili NASIL</th><td width="20%" align="right"> <a accesskey="n" href="../howto/assembly-howto-s-assem.html">Sonraki</a></td></tr></table></td></tr></table></td></tr></table><dl><div class="sect1"><dt><div> <h2 class="title" style="clear: both"><a name="assembly-howto-s-doyou"></a>Sembolik makina diline ihtiyacýnýz var mý?</h2></div></dt><dd><p>
Aslýnda, her ne yapýyorsanýz bölmek istemem, ama burada zor kazanýlmýþ tecrübelerin sonucu olarak bazý tavsiyelerde bulunacaðým.
</p><dl><div class="sect2"><dt><div> <h3 class="title"><a name="id1"></a>Artýlar ve Eksiler</h3></div></dt><dd><dl><div class="sect3"><dt><div> <h4 class="title"><a name="id11"></a>Sembolik makina dilinin (Assembly) avantajlarý</h4></div></dt><dd><p>
Sembolik makina dili (Assembly) pekçok düþük seviyeli þeyi ifade edebilir:
</p><p><div class="itemizedlist"><ul type="disc"><li>
makinaya baðlý yazmaç ve Giriþ/Çýkýþlara (I/O) erileþilirsiniz
<p></p><p></p></li><li>
çoklu yazýlým parçalarýnýn ya da donaným aygýtlarýnýn ölümcül kilitlenmesini içeren kritik bölümlere özgü kod davranýþlarýný kontrol edebilirsiniz.
<p></p><p></p></li><li>
alýþýldýk derleyicinizin herkesçe kabul görmüþ kurallarýný kýrabilirsiniz, ki bu da bazý eniyilemelere izin vermektedir (bellek tahsisiyle, evrelerle (threading), çaðrý kurallarýyla ilgili kurallarý geçici olarak kýrmak gibi).
<p></p><p></p></li><li>
kod parçalarý arasýnda, uygun olmayan (örn. deðiþik derleyiciler tarafýndan üretilen veya düþük seviye arayüzlerle ayrýlan) kurallar kullanarak arayüzler tasarlayabilirsiniz.
<p></p><p></p></li><li>
iþlemcinizin alýþýlmadýk programlama kiplerine eriþebilirsiniz (örn. açýlýþ arayüzü için 16 bitlik kip, aygýt yazýlýmlarý, Intel bilgisayarlardaki kalýtsal kodlar).
<p></p><p></p></li><li>
kötü ve eniyileme yapmayan derleyicilerle uyumlu çalýþacak sýký döngüler için oldukça hýzlý kodlar üretebilirsiniz. (Ancak, eniyileme yapabilen özgür derleyiciler var!)
<p></p><p></p></li><li>
her ne kadar baþka herhangi birininkine ait olmayacak olsa da, size özel aygýt ayarlarýnýz için el ile eniyilenmiþ mükemmel bir kod üretebilirsiniz
<p></p><p></p></li><li>
yeni dilinizin eniyileme yapabilen derleyicisi için bir kod yazabilirsiniz (bu, çok azýmýzýn yapacaðý ve hatta pek de sýklýkla yapmayacaðý bir iþtir).
<p></p><p></p></li><li>
örn. kendi kodunuzu tamamiyle kontrol altýna alabilirsiniz
<p></p><p></p></li></ul></div>
</p></dd></div></dl><dl><div class="sect3"><dt><div> <h4 class="title"><a name="id21"></a>Sembolik makina dilinin (Assembly) dezavantajlarý</h4></div></dt><dd><p>
Sembolik makina dili, oldukça düþük seviyeli bir dildir (bundan daha aþaðýda ikilik komutlarý el ile kodlamak bulunmaktadýr). Bu da þu manalara gelmektedir:
</p><p><div class="itemizedlist"><ul type="disc"><li>
ilk baþlarda yazmak, oldukça uzun ve can sýkýcýdýr
</li><li>
hata yapmaya oldukça meyillidir
</li><li>
hatalarýnýzý takip etmek oldukça zor olabilir
</li><li>
kodunuzu anlamak ve deðiþtirmek oldukça zordur, örn. bakýmýný yapmak
</li><li>
sonuç, þu anda veya gelecekte var olacak mimarilere taþýnabilir deðildir
</li><li>
kodunuz ayný mimarinin sadece belli bir gerçekleþtirimi için eniyilenecektir: mesela, Intel uyumlu platformlar arasýnda, herbir CPU tasarýmý ve türevi (iþlemci birimlerinin nispi gecikme süresi, üretilen iþ (through-output) ve kapasitesi, önbellekler (cache), RAM, taþýt (bus), diskler, FPU, MMX, 3DNOW, SIMD uzantýlarýnýn varlýklarý, v.b.) tamamiyle farklý eniyileme tekniklerini ifade etmektedir.
Ýþlemci (CPU) tasarýmlarý halihazýrda þunlarý içermektedir: Intel 386, 486, Pentium, PPro, PII, PIII, PIV; Cyrix 5x86, 6x86, M2; AMD K5, K6 (K6-2, K6-III), K7 (Athlon, Duron). Yeni tasarýmlar yukarýlara doðru týrmanmayý sürdürmektedir, dolayýsýyle ne bu listenin ne de kodunuzun güncel kalacaðýný ummayýn.
<p></p><p></p></li><li>
çok az bir ayrýntý üzerinde fazlaca zaman harcarsýnýz, hýzlanmanýn  büyük kýsmýný oluþturan küçük ve geniþ algoritmik tasarýmlar üzerine odaklanamazsýnýz (örn. liste/diziler üzerinde deðiþikler yapan hýzlý ve ilkel nesneler oluþturmak için çokça zaman harcayabilirsiniz; oysa sadece hesaba dayalý bir adresleme (hash) tablosu veya baþka bir yaklaþýmda ikilik aðaç ya da pekçok CPU kümesine daðýtýlmýþ olan yüksek seviyeli bir yapý programýnýzý çok daha hýzlandýrýrdý).
<p></p><p></p></li><li>
algoritmik tasarýmýnýzdaki ufak bir deðiliklik var olan sembolik makina kodunuzu tamamiyle geçersiz hale getirebilir. Bu durumda ya tamamen tekrar yazmaya (yazabilemeye) hazýrsýnýzdýr veya belirli bir algoritmik tasarýmý yapmaktan sýkýlmýþsýnýzdýr.
<p></p><p></p></li><li>
Standart karþýlaþtýrmalý deðerlendirmeden (benchmark) uzak olmayan kod üzerinde, eniyileme yapan ticari derleyiciler elle kodlanmýþ sembolik makina dili gerçekleþtirirler (aslýnda, RISC mimarisine göre bu durum x86 mimarisi üzerinde daha az geçerlidir ve belki de geniþ bir þekilde bulunan/kullanýlan derleyiciler için de daha az doðrudur; herneyse, tipik bir C kodu için GCC oldukça iyidir);
<p></p><p></p></li><li>
Ve her durumda, <a href="news:comp.compilers" target="_top">comp.compilers</a>'da bulunan yönetici John Levine'nin dediði gibi,
<p></p><p>
<pre class="literallayout">
    "derleyiciler karmaþýk veri yapýlarýnýn kullanýmýný oldukça kolay
    hale getirmektedir ve derleyiciler iþin yarýsýndan sonra sýkýlmamakta
    ve güvenilir oldukça güzel kodlar üretmektedir."
</pre>
</p><p>
Prosedür ve modül sýnýrlarý arasýnda kodu eniyilerken, ayný zamanda da tüm (büyük) program boyunca <i>düzgün</i> biçimde kod dönüþümleri üreteceklerdir.
</p><p></p></li></ul></div>
</p></dd></div></dl><dl><div class="sect3"><dt><div> <h4 class="title"><a name="id31"></a>Deðerlendirme</h4></div></dt><dd><p>
Tüm bunlardan sonra, sembolik makina dili kullanmanýn bir ihtiyaç olduðunu düþünebilirsiniz ve hatta ihtiyaç olmadýðý bazý yerlerde kullanmak çok da faydalý olabilir. Þunlarý yapmak isteyeceksiniz:
</p><p>
<div class="itemizedlist"><ul type="disc"><li>
sembolik makina dilinin kullanýmýný küçültmek
</li><li>
iyi tanýmlanmýþ arayüzler içine bu kodlarý koymak (encapsulate)
</li><li>
sembolik makine dili dýþýnda yüksek seviyeli dillerle tanýmlanmýþ yapýlar tarafýndan sembolik makine dili kodunuzun otomatik üretilmesi (örn. GCC satýriçi (inline) makrolar)
</li><li>
bu programlarý otomatik araçlarýn sembolik makine dili koduna dönüþtürmesi
</li><li>
bu kodun eðer mümkünse eniyilenmesi
</li><li>
yukarýdakilerin tümü, örn. bir derleyici (ya da derleyiciye bir eklenti) arka ucu (back-end)
</li></ul></div>
</p><p>
Sembolik makina diline gerek duyulsa (örn. Ýþletim sistemi geliþtirmek) bile, yukarýdakilerin çok daha fazlasýna gerek duyulmayacaðýný göreceksiniz ve de üstteki prensipler de varlýðýný koruyacaktýr.
</p><p>
Bununla ilgili olarak Linux çekirdek kaynaklarýna bakýnýz: ne kadar az sembolik makina diline gerek duyulursa, neticesinde hýzlý, güvenilir, taþýnabilir ve sürdürülebilir iþletim sistemi oluþmaktadýr. Hatta DOOM gibi baþarýlý bir oyun dahi yoðun þekilde C ile yazýlmýþtýr, sadece küçük bir kýsmý hýzý arttýrmak için sembolik makine dili ile yazýlmýþtýr.
</p></dd></div></dl></dd></div></dl><dl><div class="sect2"><dt><div> <h3 class="title"><a name="assembly-howto-howtonot"></a>Sembolik makina dili nasýl kullanýlmaz</h3></div></dt><dd><dl><div class="sect3"><dt><div> <h4 class="title"><a name="id12"></a>Baþarýlý kodu gerçeklemek için adýmlar</h4></div></dt><dd><p>
<a href="news:comp.compilers" target="_top">comp.compilers</a>'daki Charles Fiterman'ýn bilgisayara karþýn insanýn ürettiði sembolik makina kodlarýyla ilgili söylediði gibi:
</p><p>

<blockquote class="blockquote"><p>
<pre class="literallayout">
Ýnsanoðlu her zaman kazanmak zorundadýr ve iþte bu da nedenidir.

Birincisi insanoðlu herþeyi yüksek seviyeli dilde yazar.
Ýkincisi üzerinde zaman harcadýðý sýcak noktalarý bulacak
þekilde programýn taslaðýný hazýrlar.
Üçüncüsü elinde bu kýsýmlar için derleyicinin ürettiði kod vardýr.
Dördüncüsü makina kodu üzerinde ufak geliþmeler saðlayarak onlara
bir canlýlýk kazandýrabilir.

Ýnsanoðlu kazanýr çünkü makinalarý kullanabilmektedir.
</pre></p></blockquote>
</p></dd></div></dl><dl><div class="sect3"><dt><div> <h4 class="title"><a name="id22"></a>Eniyileme yapan derleyiciler ile dilleri</h4></div></dt><dd><p>
Diðerleri arasýnda ObjectiveCAML, SML, CommonLISP, Scheme, ADA, Pascal, C, C++ gibi dillerin programýnýzýn þiþkinliðini eniyileyecek özgür derleyicileri vardýr ve genellikle, sýký döngüler için bile elle yazýlmýþ sembolik makina kodundan daha iyisini üretirler, bu arada da daha yüksek seviyeli ayrýntýlar üzerinde odaklanmanýzý saðlarlar ve de belli bir kararlý düzeye geldikten sonra da yukarýda bahsedilen þekilde belli miktar baþarýma el koymanýzý yasaklamazlar. Elbette, bu dillerin çoðu için eniyileme yapan ticari derleyiciler de vardýr!
</p><p>
Bazý diller C kodu üreten ve sonrasýnda eniyilemesini C derleyicisine yaptýran derleyicilere sahiptir: LISP, Scheme, Perl ve diðer pekçoðu. Hýz oldukça iyidir.
</p></dd></div></dl><dl><div class="sect3"><dt><div> <h4 class="title"><a name="id32"></a>Kodunuzu hýzlandýracak için genel adýmlar</h4></div></dt><dd><p>
Kodunuzun hýzlý çalýþmasýný saðlamak için, analiz araçlarýndan birinin kodunuzun belli bir yerini sürekli bir performans darboðazý olarak tanýmlamasý gerekmektedir.
</p><p>
Bu nedenle, bir kod parçasýný çok yavaþ olarak tanýmladýktan sonra, þunlarý yapmalýsýnýz:
</p><p>
<div class="itemizedlist"><ul type="disc"><li>
öncelikle daha iyi bir algoritma kullanmaya çalýþýn;
</li><li>
yorumlamak yerine onu derleyin;
</li><li>
daha sonra derleyicinizdeki eniyilemeyi etkinleþtirip onunla oynayýn
</li><li>
daha sonra derleyiciye nasýl eniyileme yapacaðýna dair ipuçlarý verin (LISP'de bilgi girmek; GCC ile yazmaç kullanmak; pekçok derleyicideki seçenekler, v.b)
</li><li>
bundan sonra ancak son çare sembolik makina dilidir.
</li></ul></div>
</p><p>
Son olarak, sembolik makina diliyle yazmayý bitirmeden önce, üretilen kodu incelemelisiniz, problemin gerçekten de kötü kod üretiminden kaynaklandýðýný görmelisiniz, ki bu herzaman sanýlan durum olmayabilir: derleyicinin ürettiði kod sizin yazdýðýndan daha iyi olabilir, özellikle modern çoklu ardýþýk düzen (multi-pipelined) mimarilerinde! Programýn yavaþ olan kýsýmlarý esas olarak böyle olabilir. Hýzlý iþlemcili modern mimarilerde temel sorun, bellek eriþim gecikmeleri, önbellek atlamalarý, TLB (TLB-misses) kayýplarý ve sayfa hatalarýndan kaynaklanmaktadýr; yazmaç kullanýmý gereksiz olmaktadýr ve veri yapýlarýný daha kazançlý bir þekilde ve bellek eriþimini daha iyi yapmanýn yollarýný tekrar düþüneceksiniz. Belki de tamamen farklý bir yaklaþým sorunun çözümüne yardýmcý olabilir.
</p></dd></div></dl><dl><div class="sect3"><dt><div> <h4 class="title"><a name="id42"></a>Derleyicinin ürettiði kodu incelemek</h4></div></dt><dd><p>
Derleyicinin ürettiði kodu incelemek için pek çok neden vardýr. Ýþte size bu kodla neler yapacaðýnýz:
</p><p>
<div class="itemizedlist"><ul type="disc"><li>
üretilen kodun el yordamýyla geliþtirilip geliþtirilemeyeceðini kontrol edin (veya derleyici seçenekleriyle oynayarak)
<p></p><p></p></li><li>
durum böyle ise, o zaman üretilmiþ kod ile baþlayýn, onu yeniden yazmak yerine deðiþtirin
<p></p><p></p></li><li>
genel olarak, dýþ dünyaya karþý sizin sembolik makine rutinlerinizi anlayan üretilen kodu deðiþiklik yapmak için bir yama gibi kullanýn
<p></p><p></p></li><li>
derleyicinizdeki hatalarý takip edin (tahminim en az sýklýkla)
<p></p><p></p></li></ul></div>
</p><p>
Sembolik makina dilinizin oluþmasý için standart yol derleyicinizi <tt>-S</tt> parametresiyle çalýþtýrmaktýr. Bu, GCC C derleyicisini de içeren (GCC) pekçok Unix derleyicinde çalýþmaktadýr. GCC'ye gelince, <tt>-fverbose-asm</tt> komut satýrý parametresiyle çok daha anlaþýlabilir sembolik makina kodlarý üretecektir. Elbette, iyi sembolik makina kodu elde etmek istiyorsanýz, herzamanki eniyileme seçeneklerinizi ve ipuçlarýný unutmayýnýz!
</p></dd></div></dl></dd></div></dl><dl><div class="sect2"><dt><div> <h3 class="title"><a name="assembly-howto-landa"></a>Linux ve Assembly</h3></div></dt><dd><p>
Muhtemelen farkettiðiniz üzere, genel olarak, Linux programlamada sembolik makine dilini kullanmaya ihtiyaç duymazsýnýz. DOS'takinin aksine, Linux sürücülerini sembolik makine dili ile yazmanýz zorunlu deðildir (aslýnda, eðer gerçekten istiyorsanýz yapabilirsiniz). Ve günümüzün eniyileme yapan derleyicileriyle, farklý iþlemcilerdeki hýzý dikkate alýyorsanýz, C ile yazmak çok daha basittir. Yine de, bunu okuyorsanýz, C/C++ yerine sembolik makine dili kullanmak için bir nedeniniz olabilir.
</p><p>
Sembolik makine dilini kullanmak <i>ihtiyacýnda</i> olabilirsiniz veya sadece kullanmak <i>isteyebilirsiniz</i>. Kýsaca, sembolik makine dili krallýðýna dalmaktaki temel pratik sebepler (<i>ihtiyaç</i>) <i>kýsa kodlar</i> ve <i>libc</i> <i>baðýmsýzlýklarýdýr</i>. Pratik olarak ve en sýk karþýlaþýlan nedense (<i>istek</i>), 20 yýllýk ve herþeyi sembolik makine dili ile yapma alýþkanlýðý olan eski bir bilgisayar kurdu olmaktýr.
</p><p>
Yine de, eðer Linux'u gömülü bir sisteme yerleþtiriyorsanýz, tüm sistemin büyüklüðüne göre kýsa olabilirsiniz: çekirdeði, libc ve tüm diðer þeylerin (file|find|text|sh|v.b) uygulamalarýný birkaç yüz kilobyte'a oturtmalýsýnýz ve her kilobyte'ýn deðeri çok fazladýr. Bundan dolayý, mümkün olan yollardan birisi, sistemin bazý (veya tüm) kýsýmlarýný sembolik makine dili ile yazmaktýr ve bu durum da pekçok yer tasarrufu saðlayacaktýr. Mesela, basit bir, sembolik makine dili ile yazýlmýþ, <b><tt>httpd</tt></b> 600 byte'tan az tutmaktadýr; kernel, httpd ve ftpd içeren bir sunucuyu 400kb veya daha az boyutta ayarlayabilirsiniz... Bunu düþünün.
</p></dd></div></dl></dd></div></dl><h1></h1><table width="100%" summary="Navigation header" cellpadding="1" cellspacing="0" border="0"><tr><td bgcolor="black" class="navoutline"><table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td bgcolor="white" class="navinline"><table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td width="40%" align="left"><a accesskey="p" href="../howto/assembly-howto-s-intro.html">Önceki</a> </td><td width="20%" align="center"><a accesskey="u" href="../howto/assembly-howto.html">Üst Ana Baþlýk</a></td><td width="40%" align="right"> <a accesskey="n" href="../howto/assembly-howto-s-assem.html">Sonraki</a></td></tr><tr><td width="40%" align="left" valign="top">Giriþ </td><td width="20%" align="center"><a accesskey="h" href="../KiTAPLIK/index.html">Baþlangýç</a></td><td width="40%" align="right" valign="top"> Çeviriciler (Assemblers)</td></tr><tr><td colspan="3" align="center">
                  Bir <a href="http://www.belgeler.org/">Linux Kitaplýðý</a> Sayfasý
                </td></tr></table></td></tr></table></td></tr></table></body></html>
