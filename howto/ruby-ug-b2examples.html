<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-9"><meta name="date" content="2006-04-25T01:56:01+03:00"><title>Örneklere Dönüþ</title><link rel="icon" type="image/png" href="../images/belgeler-logo.png"><link rel="stylesheet" href="../belgeler.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V-special(derived from 1.49 for Turkish Linux Documentation WG by Nilgün Belma Bugüner - nilgun@superonline.com)"><link rel="home" href="../KiTAPLIK/index.html" title="Linux Kitaplýðý"><link rel="up" href="../howto/ruby-ug.html" title="Ruby Kullanýcý Kýlavuzu"><link rel="previous" href="../howto/ruby-ug-arrays.html" title="Diziler"><link rel="next" href="../howto/ruby-ug-control.html" title="Denetim Yapýlarý"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><table width="100%" summary="Navigation header" cellpadding="1" cellspacing="0" border="0"><tr><td bgcolor="black" class="navoutline"><table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td bgcolor="white" class="navinline"><table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><th colspan="3" align="center">Örneklere Dönüþ</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="../howto/ruby-ug-arrays.html">Önceki</a> </td><th width="60%" align="center">Ruby Kullanýcý Kýlavuzu</th><td width="20%" align="right"> <a accesskey="n" href="../howto/ruby-ug-control.html">Sonraki</a></td></tr></table></td></tr></table></td></tr></table><dl><div class="sect1"><dt><div> <h2 class="title" style="clear: both"><a name="ruby-ug-b2examples"></a>Örneklere Dönüþ</h2></div></dt><dd><p>
Þimdi eski örneklere tekrar göz atalým.
  </p><p>
Aþaðýdakini daha önce  <a href="../howto/ruby-ug-examples.html" class="xref" title="Basit Örnekler"> Basit Örnekler</a> kýsmýnda görmüþtük.
  </p><p>
<div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">def fact(n)
  if n == 0
    1
  else
    n * fact(n-1)
  end
end
print fact(ARGV[0].to_i), "\n"
</pre> </td></tr></table></div>
  </p><p>
Bu bizim ilk örneðimiz olduðu için her satýrý teker teker açýklayalým.
  </p><h4><a name="ruby-ug-factorials"></a>Faktöriyeller</h4><p>
<div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">def fact(n)  </pre> </td></tr></table></div>
    </p><p>
Ýlk satýrda bir iþlev (ya da daha özel olarak bir <span class="wordasword"><i>yöntem</i></span>; yöntemin ne olduðunu ileriki kýsýmlarda göreceðiz) tanýmlamak için <b><tt>def</tt></b> deyimini kullanýyoruz. Burada iþlevimiz <tt>fact</tt>'ýn <tt>n</tt> adýnda tek bir argüman aldýðýný görüyoruz.
    </p><p>
<div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">if n == 0</pre> </td></tr></table></div>
    </p><p>
<b><tt>if</tt></b> bir denetim deyimidir. Eðer koþul saðlanýyorsa onu takip eden kod deðerlendirilir, aksi taktide <b><tt>else</tt></b> kýsmýna geçilir.
    </p><p>
<div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">1</pre> </td></tr></table></div>
    </p><p>
Eðer koþul saðlandýysa <b><tt>if</tt></b>'in deðeri 1 olacaktr.
    </p><p>
<div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">else</pre> </td></tr></table></div>
    </p><p>
Saðlanmadýysa, bu deyimle baþlayan <b><tt>end</tt></b> ile biten kod parçasý deðerlendirilir.
    </p><p>
<div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">n * fact(n-1)</pre> </td></tr></table></div>
    </p><p>
Yani, eðer koþul saðlanmamýþsa sonuç <b><tt>n</tt></b> kere <b><tt>fact(n-1)</tt></b> olacaktýr.
    </p><p>
<div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">end</pre> </td></tr></table></div>
    </p><p>
Ýlk <b><tt>end</tt></b>, <b><tt>if</tt></b> deyimini kapatmak için kullanýlýr.
    </p><p>
<div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">end</pre> </td></tr></table></div>
    </p><p>
Ýkinci <b><tt>end</tt></b> <b><tt>def</tt></b> ifadesini kapatmak için kullanýlýr.
    </p><p>
<div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">print fact(ARGV[0].to_i), "\n"  </pre> </td></tr></table></div>
    </p><p>
Bu bizim komut satýrýndan <tt>fact()</tt> iþlevini çalýþtýrmamýzý ve sonuçlarý ekranda görmemizi saðlar.
    </p><p>
<b><tt>ARGV</tt></b> komut satýrý argümanlarýný içeren özel bir dizidir. <b><tt>ARGV</tt></b> dizisinin tüm elemanlarý dizgeler olduðu için, <b><tt>to_i</tt></b> yöntemiyle tamsayýya dönüþtürmek zorundayýz. Ruby Perl'deki gibi dizgeleri tamsayýlara kendiliðinden dönüþtürmez.
    </p><p>
Hmmm... Eðer bu yazýlýma negatif bir sayý girersek ne olur? Sorunu görebildiniz mi? Peki düzeltebilir misiniz?
    </p><h4><a name="id147"></a>Dizgeler</h4><p>
<a href="../howto/ruby-ug-strings.html" class="xref" title="Dizgeler"> Dizgeler</a> bölümündeki bulmaca örneðimizi tekrar inceleyelim. Bu sefer biraz daha uzun, kolaylýk açýsýndan satýrlarý numaralandýrdýk.
    </p><p>
<div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td align="right" width="20" valign="top"><pre class="screen">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre> </td><td width="*"><pre class="screen">
words = ['kestane', 'gurgen', 'palamut']
secret = words[rand(3)]

print "tahmin et? "
while guess = STDIN.gets
  guess.chop!
  if guess == secret
    print "Bildin!\n"
    break
  else
    puts "Üzgünüm kaybettin.\n"
  end
  print "tahmin et? "
end
puts "Kelime ", secret, ".\n"
</pre> </td></tr></table></div>
    </p><p>
Bu yazýlýmda yeni bir denetim yapýsý gördük: <b><tt>while</tt></b>.
Verilen koþul doðru olduðu sürece <b><tt>while</tt></b> ve <b><tt>end</tt></b> arasýndaki kod tekrar tekrar çalýþtýrýlacaktýr.
    </p><p>
2. satýrdaki <tt>rand(3)</tt> iþlevi 0 ile 2 arasýnda rastgele sayý üretir. Bu rastgele sayý <tt>words</tt> dizisinin elemanlarýndan birini çýkarmak için kullanýlýr.
    </p><p>
5. satýrda <tt>STDIN.gets</tt> yöntemiyle standart girdiden bir satýr okuduk. Eðer satýrý alýrken <tt>EOF</tt> (end of file) karakterine rastlanýrsa <tt>gets</tt> iþlevi <b><tt>nil</tt></b> deðerini döndürecektir. <b><tt>while</tt></b> ile iliþkilendirilmiþ kod <tt>^D</tt> (ya da DOS altýnda ^Z) görene kadar tekrarlanacaktýr.
    </p><p>
6. satýrdaki <tt>guess.chop!</tt> iþlevi <tt>guess</tt> deðiþkeninin sonundaki satýrsonu karakterini temizlemeye yarar.
    </p><p>
15. satýrda gizli kelimeyi yazdýrýyoruz. Bunu üç argümanla birlikte bir yazdýrma deyimi olarak kullandýk (birbiri ardýna yazdýrýlarak) ancak bunu daha verimli hale getirmek için <tt>secret</tt> yerine bir tek argüman alan <tt>#(secret)</tt> yöntemini tanýmlayabilirdik:
    </p><p>
<div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">puts "Kelime #{secret}.\n"   </pre> </td></tr></table></div>
    </p><p>
Birçok yazýlýmcý, bu yolun çýktý vermek için daha açýk olduðunu düþünürler. Tek bir dizge oluþturur ve bu dizgeyi <b><tt>puts</tt></b>'a tek bir argüman gibi sunar.
    </p><p>
Standart betik çýktýsýnda <b><tt>puts</tt></b> kullanma düþüncesini iþledik, ancak bu betik 4. ve 13. satýrlarda <b><tt>print</tt></b>'i de kullanýr. Bu ikisi ayný þey deðildir. <b><tt>print</tt></b> dizgeyi kendisine verildiði gibi çýktýlarken, <b><tt>puts</tt></b>; ayný zamanda çýktý satýrýnýn sonlanmasýný saðlar. 4. ve 13. satýrlarda <b><tt>print</tt></b> kullanýldýðý için, iþleç bir sonraki satýrýn baþlangýcýna geçeceði yerde, iþleci ekrana çýktýlanan dizgenin yanýnda býrakýr. Bu durum kullanýcý girdisi için tanýnabilir bir durumdur. Aþaðýdaki dört çýktý çaðrýsý da ayný sonucu verir:
    </p><p>
<div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen">
#satýrsonu karakteri yoksa, puts tarafýndan eklenir:
puts  "Tasi delen suyun kuvveti degil, damlalarin sürekliligidir."

#satýrsonu karakteri print komutuna verilmelidir:
print "Tasi delen suyun kuvveti degil, damlalarin sürekliligidir.\n"

#çýktýyý + ile birleþtirebilirsiniz:
print 'Tasi delen suyun kuvveti degil, damlalarin sürekliligidir.'+"\n"

# ya da birden fazla dizge vererek birleþtirebilirsiniz:
print 'Tasi delen suyun kuvveti degil, damlalarin sürekliligidir.', "\n"
</pre> </td></tr></table></div>
  </p><h4><a name="id147"></a>Düzenli Ýfadeler</h4><p>
Son olarak <a href="../howto/ruby-ug-regex.html" class="xref" title="Düzenli Ýfadeler"> Düzenli Ýfadeler</a> bölümündeki yazýlýmý inceleyeceðiz.
    </p><p>
<div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td align="right" width="20" valign="top"><pre class="screen">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre> </td><td width="*"><pre class="screen">
st = "\033[7m"
en = "\033[m"

while TRUE
  print "str&gt; "
  STDOUT.flush
  str = gets
  break if not str
  str.chop!
  print "pat&gt; "
  STDOUT.flush
  re = gets
  break if not re
  re.chop!
  str.gsub! re, "#{st}\\&amp;#{en}"
  print str, "\n"
end
print "\n"
</pre> </td></tr></table></div>
    </p><p>
4. satýrda <b><tt>while</tt></b>'ýn koþulu sonsuz döngüyü saðlamak için <b><tt>true</tt></b> yapýlmýþtýr. Ancak döngüden çýkabilmek için 8. ve 13. satýrlarda <b><tt>break</tt></b> kullandýk. Bu iki <b><tt>break</tt></b> ayný zamanda <b><tt>if</tt></b> deyiminin niteleyicilerinden biridir. Bir <i>if niteleyicisi</i> sadece ve sadece koþul saðlandýðý zaman sol yandaki terimini çalýþtýrýr.
    </p><p>
<tt>chop!</tt> için (9. ve 14 satýra bakýn) hakkýnda söylenecek çok þey var. Ruby'de geleneksel olarak yöntem isimlerinin sonuna '<b><tt>!</tt></b>' ya da '<b><tt>?</tt></b>' ekleriz. Ünlem iþareti (<b><tt>!</tt></b> bazen "bang!" diye söylenir) potansiyel olarak yýkýcý bir görev görür, daha da açmak gerekirse; dokunduðu deðeri deðiþtiren bir iþleçtir. <tt>chop!</tt> bir dizgeye doðrudan etki eder ancak ünlem iþareti olmayan bir <tt>chop</tt> bir kopya üzerinde çalýþýr. Aþaðýda ikisi arasýndaki fark görülüyor:
    </p><p>
<div class="screen" align="right"><table width="95%" cellpadding="5" cellspacing="1" border="0" class="preoutline"><tr class="preinline"><td> <pre class="screen"> <tt>ruby&gt; </tt><tt class="empinput">s1 = "forth"</tt>
  <tt class="empoutput">"forth"</tt>
<tt>ruby&gt; </tt><tt class="empinput">s1.chop!</tt>       # Bu s1'in deðerini deðiþtirir.
  <tt class="empoutput">"fort"</tt>
<tt>ruby&gt; </tt><tt class="empinput">s2 = s1.chop</tt>   # s2'ye deðiþtirilmiþ bir kopyasýný koyar.
  <tt class="empoutput">"for"</tt>
<tt>ruby&gt; </tt><tt class="empinput">s1</tt>             # ... s1'e dokunmaz.
  <tt class="empoutput">"fort"</tt>
</pre> </td></tr></table></div>
    </p><p>
Ýlerde sonunda soru iþareti olan yöntem isimleriyle karþýlaþacaksýnýz (<b><tt>?</tt></b> genelde "huh?" þeklinde telaffuz edilir). Bu <b><tt>true</tt></b> ya da <b><tt>false</tt></b> döndüren bir 'doðrulama' yöntemidir.
    </p><p>
15. satýrda dikkat edilmesi gereken önemli bir uyarý yer almaktadýr. Öncelikle <tt>gsub!</tt>'in baþka bir sözde 'yýkýcý' yöntem olduðuna dikkat edelim. <tt>re</tt>'ye uyan her ne varsa <tt>str</tt>'nin yerine koyar (<b><tt>sub</tt></b> ikame etmekten (substitute), <b><tt>g</tt></b> ise globalden gelir);  sadece ilk bulunaný deðil, dizgedeki <tt>tüm</tt> eþleþen kýsýmlarý deðiþtirir. Çok iyi, çok güzel; fakat eþleþtirilen kýsýmlarý neyle deðiþtireceðiz? 1. ve 2 satýrda önalan ve artalan renklerini peþpeþe deðiþtiren <tt>st</tt> ve <tt>en</tt> adlý iki dizge tanýmladýk.  15. satýrdaysa bunlarý, olduðu gibi yorumlandýklarýndan emin olmak için <b><tt>#{}</tt></b> arasýna yazdýk (<i>deðiþken isimlerinin yazdýrýldýðýný görmeyiz</i>).  Bunlarýn arasýnda da "<b><tt>\\&amp;</tt></b>" kodunu görüyoruz. Bu küçük bir hiledir. Yer deðiþtirilen dizge çift týrnak arasýnda olduðu için  bir çift ters bölü iþareti tek bir taneymiþ gibi yorumlanýr. Böylece <tt>gsub!</tt>'in göreceði þey "<b><tt>\&amp;</tt></b>" olur ve  bu da ilk konumda ne eþleþtirildiyse onu gösteren özel bir koda dönüþtürülür. Yani yeni dizge eþleþen parçalarý farklý renkte gösterilen eski dizge olur.
  </p></dd></div></dl><h1></h1><table width="100%" summary="Navigation header" cellpadding="1" cellspacing="0" border="0"><tr><td bgcolor="black" class="navoutline"><table width="100%" cellpadding="0" cellspacing="0" border="0"><tr><td bgcolor="white" class="navinline"><table width="100%" cellpadding="3" cellspacing="0" border="0"><tr><td width="40%" align="left"><a accesskey="p" href="../howto/ruby-ug-arrays.html">Önceki</a> </td><td width="20%" align="center"><a accesskey="u" href="../howto/ruby-ug.html">Üst Ana Baþlýk</a></td><td width="40%" align="right"> <a accesskey="n" href="../howto/ruby-ug-control.html">Sonraki</a></td></tr><tr><td width="40%" align="left" valign="top">Diziler </td><td width="20%" align="center"><a accesskey="h" href="../KiTAPLIK/index.html">Baþlangýç</a></td><td width="40%" align="right" valign="top"> Denetim Yapýlarý</td></tr><tr><td colspan="3" align="center">
                  Bir <a href="http://www.belgeler.org/">Linux Kitaplýðý</a> Sayfasý
                </td></tr></table></td></tr></table></td></tr></table></body></html>
